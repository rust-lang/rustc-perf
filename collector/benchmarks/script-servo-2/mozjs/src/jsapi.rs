/* automatically generated by rust-bindgen */

pub use self::root::*;

unsafe impl Sync for root::JSClass {}
unsafe impl Sync for root::JSFunctionSpec {}
unsafe impl Sync for root::JSNativeWrapper {}
unsafe impl Sync for root::JSPropertySpec {}
unsafe impl Sync for root::JSTypedMethodJitInfo {}

pub mod root {
    #[repr(C)]
    #[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct __BindgenBitfieldUnit<Storage, Align> {
        storage: Storage,
        align: [Align; 0],
    }
    impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
        #[inline]
        pub const fn new(storage: Storage) -> Self {
            Self { storage, align: [] }
        }
    }
    impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
    where
        Storage: AsRef<[u8]> + AsMut<[u8]>,
    {
        #[inline]
        pub fn get_bit(&self, index: usize) -> bool {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = self.storage.as_ref()[byte_index];
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            byte & mask == mask
        }
        #[inline]
        pub fn set_bit(&mut self, index: usize, val: bool) {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = &mut self.storage.as_mut()[byte_index];
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            if val {
                *byte |= mask;
            } else {
                *byte &= !mask;
            }
        }
        #[inline]
        pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
            let mut val = 0;
            for i in 0..(bit_width as usize) {
                if self.get_bit(i + bit_offset) {
                    let index = if cfg!(target_endian = "big") {
                        bit_width as usize - 1 - i
                    } else {
                        i
                    };
                    val |= 1 << index;
                }
            }
            val
        }
        #[inline]
        pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
            for i in 0..(bit_width as usize) {
                let mask = 1 << i;
                let val_bit_is_set = val & mask == mask;
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                self.set_bit(index + bit_offset, val_bit_is_set);
            }
        }
    }
    #[allow(unused_imports)]
    use self::super::root;
    pub type FILE = ::libc::FILE;
    pub const JS_64BIT: u32 = 1;
    pub const JS_CODEGEN_X64: u32 = 1;
    pub const JS_DEFAULT_JITREPORT_GRANULARITY: u32 = 3;
    pub const JS_HAS_INTL_API: u32 = 1;
    pub const JS_PUNBOX64: u32 = 1;
    pub const JS_STANDALONE: u32 = 1;
    pub const JS_WITHOUT_NSPR: u32 = 1;
    pub const JS_BITS_PER_WORD: u32 = 64;
    pub const JS_STACK_GROWTH_DIRECTION: i32 = -1;
    pub const JSITER_OWNONLY: u32 = 8;
    pub const JSITER_HIDDEN: u32 = 16;
    pub const JSITER_SYMBOLS: u32 = 32;
    pub const JSITER_SYMBOLSONLY: u32 = 64;
    pub const JSITER_FORAWAITOF: u32 = 128;
    pub const JS_STRUCTURED_CLONE_VERSION: u32 = 8;
    pub const JS_SCERR_RECURSION: u32 = 0;
    pub const JS_SCERR_TRANSFERABLE: u32 = 1;
    pub const JS_SCERR_DUP_TRANSFERABLE: u32 = 2;
    pub const JS_SCERR_UNSUPPORTED_TYPE: u32 = 3;
    pub const JS_SCERR_SHMEM_TRANSFERABLE: u32 = 4;
    pub type __int8_t = ::std::os::raw::c_schar;
    pub type __uint8_t = ::std::os::raw::c_uchar;
    pub type __int16_t = ::std::os::raw::c_short;
    pub type __uint16_t = ::std::os::raw::c_ushort;
    pub type __int32_t = ::std::os::raw::c_int;
    pub type __uint32_t = ::std::os::raw::c_uint;
    pub type __int64_t = ::std::os::raw::c_long;
    pub type __uint64_t = ::std::os::raw::c_ulong;
    pub type __off_t = ::std::os::raw::c_long;
    pub type __off64_t = ::std::os::raw::c_long;
    pub type uint_fast8_t = ::std::os::raw::c_uchar;
    pub type va_list = root::__builtin_va_list;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _IO_marker {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _IO_codecvt {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _IO_wide_data {
        _unused: [u8; 0],
    }
    pub type _IO_lock_t = ::std::os::raw::c_void;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _IO_FILE {
        pub _flags: ::std::os::raw::c_int,
        pub _IO_read_ptr: *mut ::std::os::raw::c_char,
        pub _IO_read_end: *mut ::std::os::raw::c_char,
        pub _IO_read_base: *mut ::std::os::raw::c_char,
        pub _IO_write_base: *mut ::std::os::raw::c_char,
        pub _IO_write_ptr: *mut ::std::os::raw::c_char,
        pub _IO_write_end: *mut ::std::os::raw::c_char,
        pub _IO_buf_base: *mut ::std::os::raw::c_char,
        pub _IO_buf_end: *mut ::std::os::raw::c_char,
        pub _IO_save_base: *mut ::std::os::raw::c_char,
        pub _IO_backup_base: *mut ::std::os::raw::c_char,
        pub _IO_save_end: *mut ::std::os::raw::c_char,
        pub _markers: *mut root::_IO_marker,
        pub _chain: *mut root::_IO_FILE,
        pub _fileno: ::std::os::raw::c_int,
        pub _flags2: ::std::os::raw::c_int,
        pub _old_offset: root::__off_t,
        pub _cur_column: ::std::os::raw::c_ushort,
        pub _vtable_offset: ::std::os::raw::c_schar,
        pub _shortbuf: [::std::os::raw::c_char; 1usize],
        pub _lock: *mut root::_IO_lock_t,
        pub _offset: root::__off64_t,
        pub _codecvt: *mut root::_IO_codecvt,
        pub _wide_data: *mut root::_IO_wide_data,
        pub _freeres_list: *mut root::_IO_FILE,
        pub _freeres_buf: *mut ::std::os::raw::c_void,
        pub __pad5: usize,
        pub _mode: ::std::os::raw::c_int,
        pub _unused2: [::std::os::raw::c_char; 20usize],
    }
    #[test]
    fn bindgen_test_layout__IO_FILE() {
        assert_eq!(
            ::std::mem::size_of::<_IO_FILE>(),
            216usize,
            concat!("Size of: ", stringify!(_IO_FILE))
        );
        assert_eq!(
            ::std::mem::align_of::<_IO_FILE>(),
            8usize,
            concat!("Alignment of ", stringify!(_IO_FILE))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_ptr)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_end)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_ptr)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_end)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_buf_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_buf_end)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_save_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_backup_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_save_end)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_markers)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_chain)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_fileno)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_flags2)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_old_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_cur_column)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
            130usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_vtable_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
            131usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_shortbuf)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_codecvt)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_wide_data)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_freeres_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_freeres_buf)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(__pad5)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_mode)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
            196usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_unused2)
            )
        );
    }
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type integral_constant_value_type<_Tp> = _Tp;
        pub type integral_constant_type = u8;
        pub type false_type = u8;
        pub type conditional_type<_Iftrue> = _Iftrue;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct input_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_input_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<input_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(input_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<input_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(input_iterator_tag))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct forward_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_forward_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<forward_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(forward_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<forward_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(forward_iterator_tag))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct bidirectional_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_bidirectional_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<bidirectional_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(bidirectional_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<bidirectional_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(bidirectional_iterator_tag))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct random_access_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_random_access_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<random_access_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(random_access_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<random_access_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(random_access_iterator_tag))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator {
            pub _address: u8,
        }
        pub type iterator_iterator_category<_Category> = _Category;
        pub type iterator_value_type<_Tp> = _Tp;
        pub type iterator_difference_type<_Distance> = _Distance;
        pub type iterator_pointer<_Pointer> = _Pointer;
        pub type iterator_reference<_Reference> = _Reference;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct reverse_iterator<_Iterator> {
            pub current: _Iterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
        }
        pub type reverse_iterator___traits_type = root::std::iterator_traits;
        pub type reverse_iterator_iterator_type<_Iterator> = _Iterator;
        pub type reverse_iterator_difference_type = root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_pointer = root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_reference = root::std::reverse_iterator___traits_type;
        #[repr(C)]
        #[derive(Debug)]
        pub struct atomic<_Tp> {
            pub _M_i: _Tp,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
        }
        pub type atomic_value_type<_Tp> = _Tp;
    }
    pub mod __gnu_cxx {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    pub mod mozilla {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type IntegralConstant_ValueType<T> = T;
        pub type IntegralConstant_Type = u8;
        #[doc = " Convenient aliases."]
        pub type TrueType = u8;
        pub type FalseType = u8;
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IsVoidHelper {
                pub _base: root::mozilla::FalseType,
            }
            #[test]
            fn __bindgen_test_layout_IsVoidHelper_open0_void_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::IsVoidHelper>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::IsVoidHelper)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::IsVoidHelper>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::IsVoidHelper)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IsIntegralHelper {
                pub _base: root::mozilla::FalseType,
            }
            #[test]
            fn __bindgen_test_layout_IsIntegralHelper_open0_char_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::IsIntegralHelper>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::IsIntegralHelper)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::IsIntegralHelper>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::IsIntegralHelper)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_IsIntegralHelper_open0_signed_char_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::IsIntegralHelper>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::IsIntegralHelper)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::IsIntegralHelper>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::IsIntegralHelper)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_IsIntegralHelper_open0_unsigned_char_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::IsIntegralHelper>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::IsIntegralHelper)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::IsIntegralHelper>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::IsIntegralHelper)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_IsIntegralHelper_open0_short_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::IsIntegralHelper>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::IsIntegralHelper)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::IsIntegralHelper>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::IsIntegralHelper)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_IsIntegralHelper_open0_unsigned_short_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::IsIntegralHelper>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::IsIntegralHelper)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::IsIntegralHelper>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::IsIntegralHelper)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_IsIntegralHelper_open0_int_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::IsIntegralHelper>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::IsIntegralHelper)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::IsIntegralHelper>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::IsIntegralHelper)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_IsIntegralHelper_open0_unsigned_int_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::IsIntegralHelper>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::IsIntegralHelper)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::IsIntegralHelper>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::IsIntegralHelper)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_IsIntegralHelper_open0_long_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::IsIntegralHelper>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::IsIntegralHelper)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::IsIntegralHelper>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::IsIntegralHelper)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_IsIntegralHelper_open0_unsigned_long_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::IsIntegralHelper>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::IsIntegralHelper)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::IsIntegralHelper>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::IsIntegralHelper)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_IsIntegralHelper_open0_long_long_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::IsIntegralHelper>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::IsIntegralHelper)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::IsIntegralHelper>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::IsIntegralHelper)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_IsIntegralHelper_open0_unsigned_long_long_close0_instantiation(
            ) {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::IsIntegralHelper>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::IsIntegralHelper)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::IsIntegralHelper>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::IsIntegralHelper)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_IsIntegralHelper_open0_bool__close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::IsIntegralHelper>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::IsIntegralHelper)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::IsIntegralHelper>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::IsIntegralHelper)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_IsIntegralHelper_open0_wchar_t_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::IsIntegralHelper>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::IsIntegralHelper)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::IsIntegralHelper>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::IsIntegralHelper)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_IsIntegralHelper_open0_char16_t_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::IsIntegralHelper>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::IsIntegralHelper)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::IsIntegralHelper>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::IsIntegralHelper)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_IsIntegralHelper_open0_char32_t_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::IsIntegralHelper>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::IsIntegralHelper)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::IsIntegralHelper>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::IsIntegralHelper)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IsFloatingPointHelper {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IsArrayHelper {
                pub _base: root::mozilla::FalseType,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IsFunPtr {
                pub _base: root::mozilla::FalseType,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IsPointerHelper {
                pub _base: root::mozilla::FalseType,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IsEnumHelper {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IsClassHelper {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IsMemberPointerHelper {
                pub _base: root::mozilla::FalseType,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IsEmptyHelper {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DoIsDefaultConstructibleImpl {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_DoIsDefaultConstructibleImpl() {
                assert_eq!(
                    ::std::mem::size_of::<DoIsDefaultConstructibleImpl>(),
                    1usize,
                    concat!("Size of: ", stringify!(DoIsDefaultConstructibleImpl))
                );
                assert_eq!(
                    ::std::mem::align_of::<DoIsDefaultConstructibleImpl>(),
                    1usize,
                    concat!("Alignment of ", stringify!(DoIsDefaultConstructibleImpl))
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IsDefaultConstructibleImpl {
                pub _address: u8,
            }
            pub type IsDefaultConstructibleImpl_Type<T> = T;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DoIsDestructibleImpl {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_DoIsDestructibleImpl() {
                assert_eq!(
                    ::std::mem::size_of::<DoIsDestructibleImpl>(),
                    1usize,
                    concat!("Size of: ", stringify!(DoIsDestructibleImpl))
                );
                assert_eq!(
                    ::std::mem::align_of::<DoIsDestructibleImpl>(),
                    1usize,
                    concat!("Alignment of ", stringify!(DoIsDestructibleImpl))
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IsDestructibleImpl {
                pub _address: u8,
            }
            pub type IsDestructibleImpl_Type<T> = T;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct BaseOfTester {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ConvertibleTester {
                pub _address: u8,
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum Voidness {
                TIsVoid = 0,
                TIsNotVoid = 1,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CorrespondingSigned {
                pub _address: u8,
            }
            #[test]
            fn __bindgen_test_layout_CorrespondingSigned_open0_char_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::CorrespondingSigned>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::CorrespondingSigned)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::CorrespondingSigned>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::CorrespondingSigned)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_CorrespondingSigned_open0_unsigned_char_close0_instantiation()
            {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::CorrespondingSigned>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::CorrespondingSigned)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::CorrespondingSigned>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::CorrespondingSigned)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_CorrespondingSigned_open0_unsigned_short_close0_instantiation()
            {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::CorrespondingSigned>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::CorrespondingSigned)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::CorrespondingSigned>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::CorrespondingSigned)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_CorrespondingSigned_open0_unsigned_int_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::CorrespondingSigned>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::CorrespondingSigned)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::CorrespondingSigned>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::CorrespondingSigned)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_CorrespondingSigned_open0_unsigned_long_close0_instantiation()
            {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::CorrespondingSigned>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::CorrespondingSigned)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::CorrespondingSigned>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::CorrespondingSigned)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_CorrespondingSigned_open0_unsigned_long_long_close0_instantiation(
            ) {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::CorrespondingSigned>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::CorrespondingSigned)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::CorrespondingSigned>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::CorrespondingSigned)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CorrespondingUnsigned {
                pub _address: u8,
            }
            #[test]
            fn __bindgen_test_layout_CorrespondingUnsigned_open0_char_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::CorrespondingUnsigned>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::CorrespondingUnsigned)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::CorrespondingUnsigned>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::CorrespondingUnsigned)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_CorrespondingUnsigned_open0_signed_char_close0_instantiation()
            {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::CorrespondingUnsigned>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::CorrespondingUnsigned)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::CorrespondingUnsigned>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::CorrespondingUnsigned)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_CorrespondingUnsigned_open0_short_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::CorrespondingUnsigned>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::CorrespondingUnsigned)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::CorrespondingUnsigned>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::CorrespondingUnsigned)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_CorrespondingUnsigned_open0_int_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::CorrespondingUnsigned>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::CorrespondingUnsigned)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::CorrespondingUnsigned>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::CorrespondingUnsigned)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_CorrespondingUnsigned_open0_long_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::CorrespondingUnsigned>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::CorrespondingUnsigned)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::CorrespondingUnsigned>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::CorrespondingUnsigned)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_CorrespondingUnsigned_open0_long_long_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::CorrespondingUnsigned>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::CorrespondingUnsigned)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::CorrespondingUnsigned>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::CorrespondingUnsigned)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct RemovePointerHelper {
                pub _address: u8,
            }
            pub type RemovePointerHelper_Type<T> = T;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AssertionConditionType {
                pub _address: u8,
            }
            pub type AssertionConditionType_ValueT = root::mozilla::RemoveReference;
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum ToSignedness {
                ToIsSigned = 0,
                ToIsUnsigned = 1,
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum FromSignedness {
                FromIsSigned = 0,
                FromIsUnsigned = 1,
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum UUComparison {
                FromIsBigger = 0,
                FromIsNotBigger = 1,
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum USComparison {
                FromIsSmaller = 0,
                FromIsNotSmaller = 1,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AllowDeprecatedAbsFixed {
                pub _base: root::mozilla::FalseType,
            }
            #[test]
            fn __bindgen_test_layout_AllowDeprecatedAbsFixed_open0_int_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::AllowDeprecatedAbsFixed>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::AllowDeprecatedAbsFixed)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::AllowDeprecatedAbsFixed>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::AllowDeprecatedAbsFixed)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_AllowDeprecatedAbsFixed_open0_long_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::AllowDeprecatedAbsFixed>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::AllowDeprecatedAbsFixed)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::AllowDeprecatedAbsFixed>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::AllowDeprecatedAbsFixed)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AllowDeprecatedAbs {
                pub _base: root::mozilla::detail::AllowDeprecatedAbsFixed,
            }
            #[test]
            fn __bindgen_test_layout_AllowDeprecatedAbs_open0_int_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::AllowDeprecatedAbs>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::AllowDeprecatedAbs)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::AllowDeprecatedAbs>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::AllowDeprecatedAbs)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_AllowDeprecatedAbs_open0_long_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::AllowDeprecatedAbs>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::AllowDeprecatedAbs)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::AllowDeprecatedAbs>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::AllowDeprecatedAbs)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AbsReturnTypeFixed {
                pub _address: u8,
            }
            #[test]
            fn __bindgen_test_layout_AbsReturnTypeFixed_open0_signed_char_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::AbsReturnTypeFixed>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::AbsReturnTypeFixed)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::AbsReturnTypeFixed>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::AbsReturnTypeFixed)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_AbsReturnTypeFixed_open0_short_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::AbsReturnTypeFixed>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::AbsReturnTypeFixed)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::AbsReturnTypeFixed>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::AbsReturnTypeFixed)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_AbsReturnTypeFixed_open0_int_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::AbsReturnTypeFixed>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::AbsReturnTypeFixed)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::AbsReturnTypeFixed>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::AbsReturnTypeFixed)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_AbsReturnTypeFixed_open0_long_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::AbsReturnTypeFixed>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::AbsReturnTypeFixed)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::AbsReturnTypeFixed>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::AbsReturnTypeFixed)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AbsReturnType {
                pub _address: u8,
            }
            #[test]
            fn __bindgen_test_layout_AbsReturnType_open0_char_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::AbsReturnType>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::AbsReturnType)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::AbsReturnType>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::AbsReturnType)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_AbsReturnType_open0_signed_char_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::AbsReturnType>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::AbsReturnType)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::AbsReturnType>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::AbsReturnType)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_AbsReturnType_open0_short_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::AbsReturnType>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::AbsReturnType)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::AbsReturnType>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::AbsReturnType)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_AbsReturnType_open0_int_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::AbsReturnType>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::AbsReturnType)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::AbsReturnType>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::AbsReturnType)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_AbsReturnType_open0_long_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::AbsReturnType>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::AbsReturnType)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::AbsReturnType>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::AbsReturnType)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_AbsReturnType_open0_long_long_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::AbsReturnType>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::AbsReturnType)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::AbsReturnType>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::AbsReturnType)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_AbsReturnType_open0_float_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::AbsReturnType>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::AbsReturnType)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::AbsReturnType>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::AbsReturnType)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_AbsReturnType_open0_double_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::AbsReturnType>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::AbsReturnType)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::AbsReturnType>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::AbsReturnType)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_AbsReturnType_open0_long_double_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::AbsReturnType>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::AbsReturnType)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::AbsReturnType>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::AbsReturnType)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct FloatingPointTrait {
                pub _address: u8,
            }
            #[test]
            fn __bindgen_test_layout_FloatingPointTrait_open0_float_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::FloatingPointTrait>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::FloatingPointTrait)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::FloatingPointTrait>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::FloatingPointTrait)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_FloatingPointTrait_open0_double_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::FloatingPointTrait>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::FloatingPointTrait)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::FloatingPointTrait>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::FloatingPointTrait)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct FuzzyEqualsEpsilon {
                pub _address: u8,
            }
            #[test]
            fn __bindgen_test_layout_FuzzyEqualsEpsilon_open0_float_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::FuzzyEqualsEpsilon>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::FuzzyEqualsEpsilon)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::FuzzyEqualsEpsilon>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::FuzzyEqualsEpsilon)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_FuzzyEqualsEpsilon_open0_double_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::FuzzyEqualsEpsilon>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::FuzzyEqualsEpsilon)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::FuzzyEqualsEpsilon>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::FuzzyEqualsEpsilon)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AlignasHelper<T> {
                pub mT: T,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct MaybePoisoner {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IteratorRange<IteratorT> {
                pub mIterBegin: IteratorT,
                pub mIterEnd: IteratorT,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<IteratorT>>,
            }
            pub type IteratorRange_iterator<IteratorT> = IteratorT;
            pub type IteratorRange_const_iterator<IteratorT> = IteratorT;
            pub type IteratorRange_reverse_iterator<IteratorT> =
                root::mozilla::ReverseIterator<IteratorT>;
            pub type IteratorRange_const_reverse_iterator<IteratorT> =
                root::mozilla::ReverseIterator<IteratorT>;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AlignedChecker {
                pub _address: u8,
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum StorageType {
                AsBase = 0,
                AsMember = 1,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HasPointerTypeHelper {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_HasPointerTypeHelper() {
                assert_eq!(
                    ::std::mem::size_of::<HasPointerTypeHelper>(),
                    1usize,
                    concat!("Size of: ", stringify!(HasPointerTypeHelper))
                );
                assert_eq!(
                    ::std::mem::align_of::<HasPointerTypeHelper>(),
                    1usize,
                    concat!("Alignment of ", stringify!(HasPointerTypeHelper))
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HasPointerType {
                pub _address: u8,
            }
            pub type PointerTypeImpl_Type = [u8; 0usize];
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct PointerType {
                pub _address: u8,
            }
            pub type PointerType_Type = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct UniqueSelector {
                pub _address: u8,
            }
            pub type UniqueSelector_SingleObject = u8;
            pub type supports_os<T> = T;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Group {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CheckConvertibility {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct MakeUnsignedChar {
                pub _address: u8,
            }
            #[test]
            fn __bindgen_test_layout_MakeUnsignedChar_open0_char16_t_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::MakeUnsignedChar>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::MakeUnsignedChar)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::MakeUnsignedChar>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::MakeUnsignedChar)
                    )
                );
            }
            #[test]
            fn __bindgen_test_layout_MakeUnsignedChar_open0_char32_t_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::MakeUnsignedChar>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::MakeUnsignedChar)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::MakeUnsignedChar>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::MakeUnsignedChar)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct FunctionTypeTraitsHelper {
                pub _address: u8,
            }
            pub type FunctionTypeTraitsHelper_ReturnType<R> = R;
            pub type FunctionTypeTraitsHelper_ParameterType = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct WrapToSignedHelper {
                pub _address: u8,
            }
            pub type WrapToSignedHelper_SignedType = root::mozilla::MakeSigned;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct WrappingAddHelper {
                pub _address: u8,
            }
            pub type WrappingAddHelper_UnsignedT = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct WrappingSubtractHelper {
                pub _address: u8,
            }
            pub type WrappingSubtractHelper_UnsignedT = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct WrappingMultiplyHelper {
                pub _address: u8,
            }
            pub type WrappingMultiplyHelper_UnsignedT = u8;
            #[doc = " SelectVariantTypeHelper is used in the implementation of SelectVariantType."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct SelectVariantTypeHelper {
                pub _address: u8,
            }
            #[doc = " SelectVariantType takes a type T and a list of variant types Variants and"]
            #[doc = " yields a type Type, selected from Variants, that can store a value of type T"]
            #[doc = " or a reference to type T. If no such type was found, Type is not defined."]
            #[doc = " SelectVariantType also has a `count` member that contains the total number of"]
            #[doc = " selectable types (which will be used to check that a requested type is not"]
            #[doc = " ambiguously present twice.)"]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct SelectVariantType {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct VariantTag {
                pub _address: u8,
            }
            pub type VariantTag_Type = u8;
            #[doc = " AsVariantTemporary stores a value of type T to allow construction of a"]
            #[doc = " Variant value via type inference. Because T is copied and there's no"]
            #[doc = " guarantee that the copy can be elided, AsVariantTemporary is best used with"]
            #[doc = " primitive or very small types."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AsVariantTemporary {
                pub mValue: root::mozilla::RemoveConst,
            }
            #[repr(i32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum PackingStrategy {
                Variant = 0,
                NullIsOk = 1,
                LowBitTagIsError = 2,
                PackedVariant = 3,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IsPackableVariant {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IsPackableVariant_VEbool<V, E> {
                pub v: V,
                pub e: E,
                pub ok: bool,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<V>>,
                pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<E>>,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IsPackableVariant_EVbool<V, E> {
                pub e: E,
                pub v: V,
                pub ok: bool,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<V>>,
                pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<E>>,
            }
            pub type IsPackableVariant_Impl = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct UnusedZero {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HasFreeLSB {
                pub _address: u8,
            }
            #[test]
            fn __bindgen_test_layout_HasFreeLSB_open0_ptr_void_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::mozilla::detail::HasFreeLSB>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::mozilla::detail::HasFreeLSB)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::mozilla::detail::HasFreeLSB>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::mozilla::detail::HasFreeLSB)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct SelectResultImpl {
                pub _address: u8,
            }
            pub type SelectResultImpl_Type = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IsResult {
                pub _base: root::mozilla::FalseType,
            }
            pub type IntrinsicBase_ValueType<T> = root::std::atomic<T>;
            pub type IntrinsicBase_OrderedOp = u8;
            pub type IntrinsicMemoryOps_Base = u8;
            pub type IntrinsicAddSub_Base = u8;
            pub type IntrinsicIncDec_Base = u8;
            pub type AtomicIntrinsics_Base = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ToStorageTypeArgument {
                pub _address: u8,
            }
            pub type AtomicBase_Intrinsics = u8;
            pub type AtomicBase_ValueType = root::mozilla::detail::AtomicBase_Intrinsics;
            pub type AtomicBaseIncDec_Base = u8;
            #[doc = " LinkedList supports refcounted elements using this adapter class. Clients"]
            #[doc = " using LinkedList<RefPtr<T>> will get a data structure that holds a strong"]
            #[doc = " reference to T as long as T is in the list."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct LinkedListElementTraits {
                pub _address: u8,
            }
            pub type LinkedListElementTraits_RawType<T> = *mut T;
            pub type LinkedListElementTraits_ConstRawType<T> = *const T;
            pub type LinkedListElementTraits_ClientType<T> = *mut T;
            pub type LinkedListElementTraits_ConstClientType<T> = *const T;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HashTableEntry {
                pub _address: u8,
            }
            pub type HashTableEntry_NonConstT = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EntrySlot {
                pub mEntry: *mut root::mozilla::detail::EntrySlot_Entry,
                pub mKeyHash: *mut root::mozilla::HashNumber,
            }
            pub type EntrySlot_NonConstT = root::mozilla::RemoveConst;
            pub type EntrySlot_Entry = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HashTable {
                pub _address: u8,
            }
            pub type HashTable_NonConstT = u8;
            pub type HashTable_Key = u8;
            pub type HashTable_Lookup = u8;
            pub type HashTable_Entry = u8;
            pub type HashTable_Slot = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HashTable_Ptr {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HashTable_AddPtr {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HashTable_Iterator {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HashTable_ModIterator {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HashTable_Range {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HashTable_Enum {
                pub _address: u8,
            }
            impl root::mozilla::detail::HashTable_FailureBehavior {
                pub const ReportFailure: root::mozilla::detail::HashTable_FailureBehavior =
                    HashTable_FailureBehavior::DontReportFailure;
            }
            #[repr(i32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum HashTable_FailureBehavior {
                DontReportFailure = 0,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HashTable_FakeSlot {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HashTable_DoubleHash {
                pub _address: u8,
            }
            impl root::mozilla::detail::HashTable_LookupReason {
                pub const ForAdd: root::mozilla::detail::HashTable_LookupReason =
                    HashTable_LookupReason::ForNonAdd;
            }
            #[repr(i32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum HashTable_LookupReason {
                ForNonAdd = 0,
            }
            impl root::mozilla::detail::HashTable_RebuildStatus {
                pub const Rehashed: root::mozilla::detail::HashTable_RebuildStatus =
                    HashTable_RebuildStatus::NotOverloaded;
            }
            impl root::mozilla::detail::HashTable_RebuildStatus {
                pub const RehashFailed: root::mozilla::detail::HashTable_RebuildStatus =
                    HashTable_RebuildStatus::NotOverloaded;
            }
            #[repr(i32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum HashTable_RebuildStatus {
                NotOverloaded = 0,
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum Endianness {
                Little = 0,
                Big = 1,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EndianUtils {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_EndianUtils() {
                assert_eq!(
                    ::std::mem::size_of::<EndianUtils>(),
                    1usize,
                    concat!("Size of: ", stringify!(EndianUtils))
                );
                assert_eq!(
                    ::std::mem::align_of::<EndianUtils>(),
                    1usize,
                    concat!("Alignment of ", stringify!(EndianUtils))
                );
            }
            pub type EndianReadWrite_super = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct VectorTesting {
                _unused: [u8; 0],
            }
        }
        #[doc = " IsVoid determines whether a type is void."]
        #[doc = ""]
        #[doc = " mozilla::IsVoid<int>::value is false;"]
        #[doc = " mozilla::IsVoid<void>::value is true;"]
        #[doc = " mozilla::IsVoid<void*>::value is false;"]
        #[doc = " mozilla::IsVoid<volatile void>::value is true."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsVoid {
            pub _base: root::mozilla::detail::IsVoidHelper,
        }
        #[doc = " IsIntegral determines whether a type is an integral type."]
        #[doc = ""]
        #[doc = " mozilla::IsIntegral<int>::value is true;"]
        #[doc = " mozilla::IsIntegral<unsigned short>::value is true;"]
        #[doc = " mozilla::IsIntegral<const long>::value is true;"]
        #[doc = " mozilla::IsIntegral<int*>::value is false;"]
        #[doc = " mozilla::IsIntegral<double>::value is false;"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsIntegral {
            pub _base: root::mozilla::detail::IsIntegralHelper,
        }
        #[doc = " IsFloatingPoint determines whether a type is a floating point type (float,"]
        #[doc = " double, long double)."]
        #[doc = ""]
        #[doc = " mozilla::IsFloatingPoint<int>::value is false;"]
        #[doc = " mozilla::IsFloatingPoint<const float>::value is true;"]
        #[doc = " mozilla::IsFloatingPoint<long double>::value is true;"]
        #[doc = " mozilla::IsFloatingPoint<double*>::value is false."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsFloatingPoint {
            pub _address: u8,
        }
        #[doc = " IsArray determines whether a type is an array type, of known or unknown"]
        #[doc = " length."]
        #[doc = ""]
        #[doc = " mozilla::IsArray<int>::value is false;"]
        #[doc = " mozilla::IsArray<int[]>::value is true;"]
        #[doc = " mozilla::IsArray<int[5]>::value is true."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsArray {
            pub _base: root::mozilla::detail::IsArrayHelper,
        }
        #[doc = " IsFunction determines whether a type is a function type. Function pointers"]
        #[doc = " don't qualify here--only the type of an actual function symbol. We do not"]
        #[doc = " correctly handle varags function types because of a bug in MSVC."]
        #[doc = ""]
        #[doc = " Given the function:"]
        #[doc = "   void f(int) {}"]
        #[doc = ""]
        #[doc = " mozilla::IsFunction<void(int)> is true;"]
        #[doc = " mozilla::IsFunction<void(*)(int)> is false;"]
        #[doc = " mozilla::IsFunction<decltype(f)> is true."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsFunction {
            pub _base: root::mozilla::detail::IsFunPtr,
        }
        #[doc = " IsPointer determines whether a type is a possibly-CV-qualified pointer type"]
        #[doc = " (but not a pointer-to-member type)."]
        #[doc = ""]
        #[doc = " mozilla::IsPointer<struct S*>::value is true;"]
        #[doc = " mozilla::IsPointer<int*>::value is true;"]
        #[doc = " mozilla::IsPointer<int**>::value is true;"]
        #[doc = " mozilla::IsPointer<const int*>::value is true;"]
        #[doc = " mozilla::IsPointer<int* const>::value is true;"]
        #[doc = " mozilla::IsPointer<int* volatile>::value is true;"]
        #[doc = " mozilla::IsPointer<void (*)(void)>::value is true;"]
        #[doc = " mozilla::IsPointer<int>::value is false;"]
        #[doc = " mozilla::IsPointer<struct S>::value is false."]
        #[doc = " mozilla::IsPointer<int(struct S::*)>::value is false"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsPointer {
            pub _base: root::mozilla::detail::IsPointerHelper,
        }
        #[doc = " IsLvalueReference determines whether a type is an lvalue reference."]
        #[doc = ""]
        #[doc = " mozilla::IsLvalueReference<struct S*>::value is false;"]
        #[doc = " mozilla::IsLvalueReference<int**>::value is false;"]
        #[doc = " mozilla::IsLvalueReference<void (*)(void)>::value is false;"]
        #[doc = " mozilla::IsLvalueReference<int>::value is false;"]
        #[doc = " mozilla::IsLvalueReference<struct S>::value is false;"]
        #[doc = " mozilla::IsLvalueReference<struct S*&>::value is true;"]
        #[doc = " mozilla::IsLvalueReference<struct S&&>::value is false."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsLvalueReference {
            pub _base: root::mozilla::FalseType,
        }
        #[doc = " IsRvalueReference determines whether a type is an rvalue reference."]
        #[doc = ""]
        #[doc = " mozilla::IsRvalueReference<struct S*>::value is false;"]
        #[doc = " mozilla::IsRvalueReference<int**>::value is false;"]
        #[doc = " mozilla::IsRvalueReference<void (*)(void)>::value is false;"]
        #[doc = " mozilla::IsRvalueReference<int>::value is false;"]
        #[doc = " mozilla::IsRvalueReference<struct S>::value is false;"]
        #[doc = " mozilla::IsRvalueReference<struct S*&>::value is false;"]
        #[doc = " mozilla::IsRvalueReference<struct S&&>::value is true."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsRvalueReference {
            pub _base: root::mozilla::FalseType,
        }
        #[doc = " IsEnum determines whether a type is an enum type."]
        #[doc = ""]
        #[doc = " mozilla::IsEnum<enum S>::value is true;"]
        #[doc = " mozilla::IsEnum<enum S*>::value is false;"]
        #[doc = " mozilla::IsEnum<int>::value is false;"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsEnum {
            pub _address: u8,
        }
        #[doc = " IsClass determines whether a type is a class type (but not a union)."]
        #[doc = ""]
        #[doc = " struct S {};"]
        #[doc = " union U {};"]
        #[doc = " mozilla::IsClass<int>::value is false;"]
        #[doc = " mozilla::IsClass<const S>::value is true;"]
        #[doc = " mozilla::IsClass<U>::value is false;"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsClass {
            pub _address: u8,
        }
        #[doc = " IsReference determines whether a type is an lvalue or rvalue reference."]
        #[doc = ""]
        #[doc = " mozilla::IsReference<struct S*>::value is false;"]
        #[doc = " mozilla::IsReference<int**>::value is false;"]
        #[doc = " mozilla::IsReference<int&>::value is true;"]
        #[doc = " mozilla::IsReference<void (*)(void)>::value is false;"]
        #[doc = " mozilla::IsReference<const int&>::value is true;"]
        #[doc = " mozilla::IsReference<int>::value is false;"]
        #[doc = " mozilla::IsReference<struct S>::value is false;"]
        #[doc = " mozilla::IsReference<struct S&>::value is true;"]
        #[doc = " mozilla::IsReference<struct S*&>::value is true;"]
        #[doc = " mozilla::IsReference<struct S&&>::value is true."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsReference {
            pub _address: u8,
        }
        #[doc = " IsArithmetic determines whether a type is arithmetic.  A type is arithmetic"]
        #[doc = " iff it is an integral type or a floating point type."]
        #[doc = ""]
        #[doc = " mozilla::IsArithmetic<int>::value is true;"]
        #[doc = " mozilla::IsArithmetic<double>::value is true;"]
        #[doc = " mozilla::IsArithmetic<long double*>::value is false."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsArithmetic {
            pub _address: u8,
        }
        #[doc = " IsMemberPointer determines whether a type is pointer to non-static member"]
        #[doc = " object or a pointer to non-static member function."]
        #[doc = ""]
        #[doc = " mozilla::IsMemberPointer<int(cls::*)>::value is true"]
        #[doc = " mozilla::IsMemberPointer<int*>::value is false"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsMemberPointer {
            pub _base: root::mozilla::detail::IsMemberPointerHelper,
        }
        #[doc = " IsScalar determines whether a type is a scalar type."]
        #[doc = ""]
        #[doc = " mozilla::IsScalar<int>::value is true"]
        #[doc = " mozilla::IsScalar<int*>::value is true"]
        #[doc = " mozilla::IsScalar<cls>::value is false"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsScalar {
            pub _address: u8,
        }
        #[doc = " IsConst determines whether a type is const or not."]
        #[doc = ""]
        #[doc = " mozilla::IsConst<int>::value is false;"]
        #[doc = " mozilla::IsConst<void* const>::value is true;"]
        #[doc = " mozilla::IsConst<const char*>::value is false."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsConst {
            pub _base: root::mozilla::FalseType,
        }
        #[doc = " IsVolatile determines whether a type is volatile or not."]
        #[doc = ""]
        #[doc = " mozilla::IsVolatile<int>::value is false;"]
        #[doc = " mozilla::IsVolatile<void* volatile>::value is true;"]
        #[doc = " mozilla::IsVolatile<volatile char*>::value is false."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsVolatile {
            pub _base: root::mozilla::FalseType,
        }
        #[doc = " Traits class for identifying POD types.  Until C++11 there's no automatic"]
        #[doc = " way to detect PODs, so for the moment this is done manually.  Users may"]
        #[doc = " define specializations of this class that inherit from mozilla::TrueType and"]
        #[doc = " mozilla::FalseType (or equivalently mozilla::IntegralConstant<bool, true or"]
        #[doc = " false>, or conveniently from mozilla::IsPod for composite types) as needed to"]
        #[doc = " ensure correct IsPod behavior."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsPod {
            pub _base: root::mozilla::FalseType,
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_char_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_signed_char_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_unsigned_char_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_short_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_unsigned_short_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_int_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_unsigned_int_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_long_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_unsigned_long_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_long_long_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_unsigned_long_long_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_bool__close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_float_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_double_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_wchar_t_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsPod_open0_char16_t_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsPod>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsPod)
                )
            );
        }
        #[doc = " IsEmpty determines whether a type is a class (but not a union) that is empty."]
        #[doc = ""]
        #[doc = " A class is empty iff it and all its base classes have no non-static data"]
        #[doc = " members (except bit-fields of length 0) and no virtual member functions, and"]
        #[doc = " no base class is empty or a virtual base class."]
        #[doc = ""]
        #[doc = " Intuitively, empty classes don't have any data that has to be stored in"]
        #[doc = " instances of those classes.  (The size of the class must still be non-zero,"]
        #[doc = " because distinct array elements of any type must have different addresses."]
        #[doc = " However, if the Empty Base Optimization is implemented by the compiler [most"]
        #[doc = " compilers implement it, and in certain cases C++11 requires it], the size of"]
        #[doc = " a class inheriting from an empty |Base| class need not be inflated by"]
        #[doc = " |sizeof(Base)|.)  And intuitively, non-empty classes have data members and/or"]
        #[doc = " vtable pointers that must be stored in each instance for proper behavior."]
        #[doc = ""]
        #[doc = "   static_assert(!mozilla::IsEmpty<int>::value, \"not a class => not empty\");"]
        #[doc = "   union U1 { int x; };"]
        #[doc = "   static_assert(!mozilla::IsEmpty<U1>::value, \"not a class => not empty\");"]
        #[doc = "   struct E1 {};"]
        #[doc = "   struct E2 { int : 0 };"]
        #[doc = "   struct E3 : E1 {};"]
        #[doc = "   struct E4 : E2 {};"]
        #[doc = "   static_assert(mozilla::IsEmpty<E1>::value &&"]
        #[doc = "                 mozilla::IsEmpty<E2>::value &&"]
        #[doc = "                 mozilla::IsEmpty<E3>::value &&"]
        #[doc = "                 mozilla::IsEmpty<E4>::value,"]
        #[doc = "                 \"all empty\");"]
        #[doc = "   union U2 { E1 e1; };"]
        #[doc = "   static_assert(!mozilla::IsEmpty<U2>::value, \"not a class => not empty\");"]
        #[doc = "   struct NE1 { int x; };"]
        #[doc = "   struct NE2 : virtual E1 {};"]
        #[doc = "   struct NE3 : E2 { virtual ~NE3() {} };"]
        #[doc = "   struct NE4 { virtual void f() {} };"]
        #[doc = "   static_assert(!mozilla::IsEmpty<NE1>::value &&"]
        #[doc = "                 !mozilla::IsEmpty<NE2>::value &&"]
        #[doc = "                 !mozilla::IsEmpty<NE3>::value &&"]
        #[doc = "                 !mozilla::IsEmpty<NE4>::value,"]
        #[doc = "                 \"all empty\");"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsEmpty {
            pub _address: u8,
        }
        #[doc = " IsSigned determines whether a type is a signed arithmetic type.  |char| is"]
        #[doc = " considered a signed type if it has the same representation as |signed char|."]
        #[doc = ""]
        #[doc = " mozilla::IsSigned<int>::value is true;"]
        #[doc = " mozilla::IsSigned<const unsigned int>::value is false;"]
        #[doc = " mozilla::IsSigned<unsigned char>::value is false;"]
        #[doc = " mozilla::IsSigned<float>::value is true."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsSigned {
            pub _address: u8,
        }
        #[doc = " IsUnsigned determines whether a type is an unsigned arithmetic type."]
        #[doc = ""]
        #[doc = " mozilla::IsUnsigned<int>::value is false;"]
        #[doc = " mozilla::IsUnsigned<const unsigned int>::value is true;"]
        #[doc = " mozilla::IsUnsigned<unsigned char>::value is true;"]
        #[doc = " mozilla::IsUnsigned<float>::value is false."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsUnsigned {
            pub _address: u8,
        }
        #[doc = " IsDefaultConstructible determines whether a type has a public default"]
        #[doc = " constructor."]
        #[doc = ""]
        #[doc = " struct S0 {};                    // Implicit default constructor."]
        #[doc = " struct S1 { S1(); };"]
        #[doc = " struct S2 { explicit S2(int); }; // No implicit default constructor when"]
        #[doc = "                                  // another one is present."]
        #[doc = " struct S3 { S3() = delete; };"]
        #[doc = " class C4 { C4(); };              // Default constructor is private."]
        #[doc = ""]
        #[doc = " mozilla::IsDefaultConstructible<int>::value is true;"]
        #[doc = " mozilla::IsDefaultConstructible<S0>::value is true;"]
        #[doc = " mozilla::IsDefaultConstructible<S1>::value is true;"]
        #[doc = " mozilla::IsDefaultConstructible<S2>::value is false;"]
        #[doc = " mozilla::IsDefaultConstructible<S3>::value is false;"]
        #[doc = " mozilla::IsDefaultConstructible<S4>::value is false."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsDefaultConstructible {
            pub _address: u8,
        }
        #[doc = " IsDestructible determines whether a type has a public destructor."]
        #[doc = ""]
        #[doc = " struct S0 {};                    // Implicit default destructor."]
        #[doc = " struct S1 { ~S1(); };"]
        #[doc = " class C2 { ~C2(); };             // private destructor."]
        #[doc = ""]
        #[doc = " mozilla::IsDestructible<S0>::value is true;"]
        #[doc = " mozilla::IsDestructible<S1>::value is true;"]
        #[doc = " mozilla::IsDestructible<C2>::value is false."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsDestructible {
            pub _address: u8,
        }
        #[doc = " IsSame tests whether two types are the same type."]
        #[doc = ""]
        #[doc = " mozilla::IsSame<int, int>::value is true;"]
        #[doc = " mozilla::IsSame<int*, int*>::value is true;"]
        #[doc = " mozilla::IsSame<int, unsigned int>::value is false;"]
        #[doc = " mozilla::IsSame<void, void>::value is true;"]
        #[doc = " mozilla::IsSame<const int, int>::value is false;"]
        #[doc = " mozilla::IsSame<struct S, struct S>::value is true."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsSame {
            pub _base: root::mozilla::FalseType,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsBaseOf {
            pub _address: u8,
        }
        #[doc = " IsConvertible determines whether a value of type From will implicitly convert"]
        #[doc = " to a value of type To.  For example:"]
        #[doc = ""]
        #[doc = "   struct A {};"]
        #[doc = "   struct B : public A {};"]
        #[doc = "   struct C {};"]
        #[doc = ""]
        #[doc = " mozilla::IsConvertible<A, A>::value is true;"]
        #[doc = " mozilla::IsConvertible<A*, A*>::value is true;"]
        #[doc = " mozilla::IsConvertible<B, A>::value is true;"]
        #[doc = " mozilla::IsConvertible<B*, A*>::value is true;"]
        #[doc = " mozilla::IsConvertible<C, A>::value is false;"]
        #[doc = " mozilla::IsConvertible<A, C>::value is false;"]
        #[doc = " mozilla::IsConvertible<A*, C*>::value is false;"]
        #[doc = " mozilla::IsConvertible<C*, A*>::value is false."]
        #[doc = ""]
        #[doc = " For obscure reasons, you can't use IsConvertible when the types being tested"]
        #[doc = " are related through private inheritance, and you'll get a compile error if"]
        #[doc = " you try.  Just don't do it!"]
        #[doc = ""]
        #[doc = " Note - we need special handling for void, which ConvertibleTester doesn't"]
        #[doc = " handle. The void handling here doesn't handle const/volatile void correctly,"]
        #[doc = " which could be easily fixed if the need arises."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsConvertible {
            pub _address: u8,
        }
        #[test]
        fn __bindgen_test_layout_IsConvertible_open0_void_void_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::IsConvertible>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::IsConvertible)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::IsConvertible>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::IsConvertible)
                )
            );
        }
        #[doc = " RemoveConst removes top-level const qualifications on a type."]
        #[doc = ""]
        #[doc = " mozilla::RemoveConst<int>::Type is int;"]
        #[doc = " mozilla::RemoveConst<const int>::Type is int;"]
        #[doc = " mozilla::RemoveConst<const int*>::Type is const int*;"]
        #[doc = " mozilla::RemoveConst<int* const>::Type is int*."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RemoveConst {
            pub _address: u8,
        }
        pub type RemoveConst_Type<T> = T;
        #[doc = " RemoveVolatile removes top-level volatile qualifications on a type."]
        #[doc = ""]
        #[doc = " mozilla::RemoveVolatile<int>::Type is int;"]
        #[doc = " mozilla::RemoveVolatile<volatile int>::Type is int;"]
        #[doc = " mozilla::RemoveVolatile<volatile int*>::Type is volatile int*;"]
        #[doc = " mozilla::RemoveVolatile<int* volatile>::Type is int*."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RemoveVolatile {
            pub _address: u8,
        }
        pub type RemoveVolatile_Type<T> = T;
        #[doc = " RemoveCV removes top-level const and volatile qualifications on a type."]
        #[doc = ""]
        #[doc = " mozilla::RemoveCV<int>::Type is int;"]
        #[doc = " mozilla::RemoveCV<const int>::Type is int;"]
        #[doc = " mozilla::RemoveCV<volatile int>::Type is int;"]
        #[doc = " mozilla::RemoveCV<int* const volatile>::Type is int*."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RemoveCV {
            pub _address: u8,
        }
        pub type RemoveCV_Type = root::mozilla::RemoveConst;
        #[doc = " Converts reference types to the underlying types."]
        #[doc = ""]
        #[doc = " mozilla::RemoveReference<T>::Type is T;"]
        #[doc = " mozilla::RemoveReference<T&>::Type is T;"]
        #[doc = " mozilla::RemoveReference<T&&>::Type is T;"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RemoveReference {
            pub _address: u8,
        }
        pub type RemoveReference_Type<T> = T;
        #[doc = " AddLvalueReference adds an lvalue & reference to T if one isn't already"]
        #[doc = " present. (Note: adding an lvalue reference to an rvalue && reference in"]
        #[doc = " essence replaces the && with a &&, per C+11 reference collapsing rules. For"]
        #[doc = " example, int&& would become int&.)"]
        #[doc = ""]
        #[doc = " The final computed type will only *not* be an lvalue reference if T is void."]
        #[doc = ""]
        #[doc = " mozilla::AddLvalueReference<int>::Type is int&;"]
        #[doc = " mozilla::AddLvalueRference<volatile int&>::Type is volatile int&;"]
        #[doc = " mozilla::AddLvalueReference<void*>::Type is void*&;"]
        #[doc = " mozilla::AddLvalueReference<void>::Type is void;"]
        #[doc = " mozilla::AddLvalueReference<struct S&&>::Type is struct S&."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AddLvalueReference {
            pub _address: u8,
        }
        #[doc = " AddRvalueReference adds an rvalue && reference to T if one isn't already"]
        #[doc = " present. (Note: adding an rvalue reference to an lvalue & reference in"]
        #[doc = " essence keeps the &, per C+11 reference collapsing rules. For example,"]
        #[doc = " int& would remain int&.)"]
        #[doc = ""]
        #[doc = " The final computed type will only *not* be a reference if T is void."]
        #[doc = ""]
        #[doc = " mozilla::AddRvalueReference<int>::Type is int&&;"]
        #[doc = " mozilla::AddRvalueRference<volatile int&>::Type is volatile int&;"]
        #[doc = " mozilla::AddRvalueRference<const int&&>::Type is const int&&;"]
        #[doc = " mozilla::AddRvalueReference<void*>::Type is void*&&;"]
        #[doc = " mozilla::AddRvalueReference<void>::Type is void;"]
        #[doc = " mozilla::AddRvalueReference<struct S&>::Type is struct S&."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AddRvalueReference {
            pub _address: u8,
        }
        #[doc = " MakeSigned produces the corresponding signed integer type for a given"]
        #[doc = " integral type T, with the const/volatile qualifiers of T.  T must be a"]
        #[doc = " possibly-const/volatile-qualified integral type that isn't bool."]
        #[doc = ""]
        #[doc = " If T is already a signed integer type (not including char!), then T is"]
        #[doc = " produced."]
        #[doc = ""]
        #[doc = " Otherwise, if T is an unsigned integer type, the signed variety of T, with"]
        #[doc = " T's const/volatile qualifiers, is produced."]
        #[doc = ""]
        #[doc = " Otherwise, the integral type of the same size as T, with the lowest rank,"]
        #[doc = " with T's const/volatile qualifiers, is produced.  (This basically only acts"]
        #[doc = " to produce signed char when T = char.)"]
        #[doc = ""]
        #[doc = " mozilla::MakeSigned<unsigned long>::Type is signed long;"]
        #[doc = " mozilla::MakeSigned<volatile int>::Type is volatile int;"]
        #[doc = " mozilla::MakeSigned<const unsigned short>::Type is const signed short;"]
        #[doc = " mozilla::MakeSigned<const char>::Type is const signed char;"]
        #[doc = " mozilla::MakeSigned<bool> is an error;"]
        #[doc = " mozilla::MakeSigned<void*> is an error."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MakeSigned {
            pub _address: u8,
        }
        #[doc = " MakeUnsigned produces the corresponding unsigned integer type for a given"]
        #[doc = " integral type T, with the const/volatile qualifiers of T.  T must be a"]
        #[doc = " possibly-const/volatile-qualified integral type that isn't bool."]
        #[doc = ""]
        #[doc = " If T is already an unsigned integer type (not including char!), then T is"]
        #[doc = " produced."]
        #[doc = ""]
        #[doc = " Otherwise, if T is an signed integer type, the unsigned variety of T, with"]
        #[doc = " T's const/volatile qualifiers, is produced."]
        #[doc = ""]
        #[doc = " Otherwise, the unsigned integral type of the same size as T, with the lowest"]
        #[doc = " rank, with T's const/volatile qualifiers, is produced.  (This basically only"]
        #[doc = " acts to produce unsigned char when T = char.)"]
        #[doc = ""]
        #[doc = " mozilla::MakeUnsigned<signed long>::Type is unsigned long;"]
        #[doc = " mozilla::MakeUnsigned<volatile unsigned int>::Type is volatile unsigned int;"]
        #[doc = " mozilla::MakeUnsigned<const signed short>::Type is const unsigned short;"]
        #[doc = " mozilla::MakeUnsigned<const char>::Type is const unsigned char;"]
        #[doc = " mozilla::MakeUnsigned<bool> is an error;"]
        #[doc = " mozilla::MakeUnsigned<void*> is an error."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MakeUnsigned {
            pub _address: u8,
        }
        #[doc = " RemoveExtent produces either the type of the elements of the array T, or T"]
        #[doc = " itself."]
        #[doc = ""]
        #[doc = " mozilla::RemoveExtent<int>::Type is int;"]
        #[doc = " mozilla::RemoveExtent<const int[]>::Type is const int;"]
        #[doc = " mozilla::RemoveExtent<volatile int[5]>::Type is volatile int;"]
        #[doc = " mozilla::RemoveExtent<long[][17]>::Type is long[17]."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RemoveExtent {
            pub _address: u8,
        }
        pub type RemoveExtent_Type<T> = T;
        #[doc = " Produces the pointed-to type if a pointer is provided, else returns the input"]
        #[doc = " type.  Note that this does not dereference pointer-to-member pointers."]
        #[doc = ""]
        #[doc = " struct S { bool m; void f(); };"]
        #[doc = " mozilla::RemovePointer<int>::Type is int;"]
        #[doc = " mozilla::RemovePointer<int*>::Type is int;"]
        #[doc = " mozilla::RemovePointer<int* const>::Type is int;"]
        #[doc = " mozilla::RemovePointer<int* volatile>::Type is int;"]
        #[doc = " mozilla::RemovePointer<const long*>::Type is const long;"]
        #[doc = " mozilla::RemovePointer<void* const>::Type is void;"]
        #[doc = " mozilla::RemovePointer<void (S::*)()>::Type is void (S::*)();"]
        #[doc = " mozilla::RemovePointer<void (*)()>::Type is void();"]
        #[doc = " mozilla::RemovePointer<bool S::*>::Type is bool S::*."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RemovePointer {
            pub _address: u8,
        }
        #[doc = " Converts T& to T*. Otherwise returns T* given T. Note that C++17 wants"]
        #[doc = " std::add_pointer to work differently for function types. We don't implement"]
        #[doc = " that behavior here."]
        #[doc = ""]
        #[doc = " mozilla::AddPointer<int> is int*;"]
        #[doc = " mozilla::AddPointer<int*> is int**;"]
        #[doc = " mozilla::AddPointer<int&> is int*;"]
        #[doc = " mozilla::AddPointer<int* const> is int** const."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AddPointer {
            pub _address: u8,
        }
        pub type AddPointer_Type = *mut root::mozilla::RemoveReference;
        pub type Conditional_Type<A> = A;
        #[doc = " Strips const/volatile off a type and decays it from an lvalue to an"]
        #[doc = " rvalue. So function types are converted to function pointers, arrays to"]
        #[doc = " pointers, and references are removed."]
        #[doc = ""]
        #[doc = " mozilla::Decay<int>::Type is int"]
        #[doc = " mozilla::Decay<int&>::Type is int"]
        #[doc = " mozilla::Decay<int&&>::Type is int"]
        #[doc = " mozilla::Decay<const int&>::Type is int"]
        #[doc = " mozilla::Decay<int[2]>::Type is int*"]
        #[doc = " mozilla::Decay<int(int)>::Type is int(*)(int)"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Decay {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct unused_t {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct FloatingPoint {
            pub _address: u8,
        }
        pub type FloatingPoint_Base = root::mozilla::detail::FloatingPointTrait;
        #[doc = " An unsigned integral type suitable for accessing the bitwise representation"]
        #[doc = " of T."]
        pub type FloatingPoint_Bits = root::mozilla::FloatingPoint_Base;
        pub type InfinityBits_Traits = root::mozilla::FloatingPoint;
        pub type SpecificNaNBits_Traits = root::mozilla::FloatingPoint;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AlignmentFinder {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AlignmentFinder_Aligner<T> {
            pub mChar: ::std::os::raw::c_char,
            pub mT: T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        #[repr(C)]
        pub struct AlignedStorage2 {
            pub u: root::mozilla::AlignedStorage2_U,
        }
        #[repr(C)]
        pub union AlignedStorage2_U {
            pub mBytes: *mut ::std::os::raw::c_char,
            pub mDummy: u64,
            _bindgen_union_align: u64,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum NotNullTag {
            KnownNotNull = 0,
        }
        #[doc = " A version of CorruptionCanary that is suitable as a member of objects that"]
        #[doc = " are statically allocated."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct CorruptionCanaryForStatics {
            pub mValue: usize,
        }
        pub const CorruptionCanaryForStatics_kCanarySet: usize = 252382987;
        #[test]
        fn bindgen_test_layout_CorruptionCanaryForStatics() {
            assert_eq!(
                ::std::mem::size_of::<CorruptionCanaryForStatics>(),
                8usize,
                concat!("Size of: ", stringify!(CorruptionCanaryForStatics))
            );
            assert_eq!(
                ::std::mem::align_of::<CorruptionCanaryForStatics>(),
                8usize,
                concat!("Alignment of ", stringify!(CorruptionCanaryForStatics))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<CorruptionCanaryForStatics>())).mValue as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CorruptionCanaryForStatics),
                    "::",
                    stringify!(mValue)
                )
            );
        }
        #[doc = " This class is designed to cause crashes when various kinds of memory"]
        #[doc = " corruption are observed. For instance, let's say we have a class C where we"]
        #[doc = " suspect out-of-bounds writes to some members.  We can insert a member of type"]
        #[doc = " Poison near the members we suspect are being corrupted by out-of-bounds"]
        #[doc = " writes.  Or perhaps we have a class K we suspect is subject to use-after-free"]
        #[doc = " violations, in which case it doesn't particularly matter where in the class"]
        #[doc = " we add the member of type Poison."]
        #[doc = ""]
        #[doc = " In either case, we then insert calls to Check() throughout the code.  Doing"]
        #[doc = " so enables us to narrow down the location where the corruption is occurring."]
        #[doc = " A pleasant side-effect of these additional Check() calls is that crash"]
        #[doc = " signatures may become more regular, as crashes will ideally occur"]
        #[doc = " consolidated at the point of a Check(), rather than scattered about at"]
        #[doc = " various uses of the corrupted memory."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct CorruptionCanary {
            pub _base: root::mozilla::CorruptionCanaryForStatics,
        }
        #[test]
        fn bindgen_test_layout_CorruptionCanary() {
            assert_eq!(
                ::std::mem::size_of::<CorruptionCanary>(),
                8usize,
                concat!("Size of: ", stringify!(CorruptionCanary))
            );
            assert_eq!(
                ::std::mem::align_of::<CorruptionCanary>(),
                8usize,
                concat!("Alignment of ", stringify!(CorruptionCanary))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Nothing {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Nothing() {
            assert_eq!(
                ::std::mem::size_of::<Nothing>(),
                1usize,
                concat!("Size of: ", stringify!(Nothing))
            );
            assert_eq!(
                ::std::mem::align_of::<Nothing>(),
                1usize,
                concat!("Alignment of ", stringify!(Nothing))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Maybe {
            pub _address: u8,
        }
        pub type Maybe_ValueType = u8;
        pub type MallocSizeOf =
            ::std::option::Option<unsafe extern "C" fn(p: *const ::std::os::raw::c_void) -> usize>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ReverseIterator<IteratorT> {
            pub mCurrent: IteratorT,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<IteratorT>>,
        }
        pub type Array_iterator<T> = *mut T;
        pub type Array_const_iterator<T> = *const T;
        pub type Array_reverse_iterator<T> = root::mozilla::ReverseIterator<T>;
        pub type Array_const_reverse_iterator<T> = root::mozilla::ReverseIterator<T>;
        pub type EnumeratedArray_ArrayType = u8;
        pub type EnumeratedArray_iterator = root::mozilla::EnumeratedArray_ArrayType;
        pub type EnumeratedArray_const_iterator = root::mozilla::EnumeratedArray_ArrayType;
        pub type EnumeratedArray_reverse_iterator = root::mozilla::EnumeratedArray_ArrayType;
        pub type EnumeratedArray_const_reverse_iterator = root::mozilla::EnumeratedArray_ArrayType;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RangedPtr<T> {
            pub mPtr: *mut T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PositionOfSignBit {
            pub _address: u8,
        }
        #[doc = " MinValue returns the minimum value of the given integer type as a"]
        #[doc = " compile-time constant, which std::numeric_limits<IntegerType>::min()"]
        #[doc = " cannot do in c++98."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MinValue {
            pub _address: u8,
        }
        pub type MinValue_UnsignedIntegerType = root::mozilla::MakeUnsigned;
        #[doc = " MaxValue returns the maximum value of the given integer type as a"]
        #[doc = " compile-time constant, which std::numeric_limits<IntegerType>::max()"]
        #[doc = " cannot do in c++98."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MaxValue {
            pub _address: u8,
        }
        #[doc = " Pair is the logical concatenation of an instance of A with an instance B."]
        #[doc = " Space is conserved when possible.  Neither A nor B may be a final class."]
        #[doc = ""]
        #[doc = " It's typically clearer to have individual A and B member fields.  Except if"]
        #[doc = " you want the space-conserving qualities of Pair, you're probably better off"]
        #[doc = " not using this!"]
        #[doc = ""]
        #[doc = " No guarantees are provided about the memory layout of A and B, the order of"]
        #[doc = " initialization or destruction of A and B, and so on.  (This is approximately"]
        #[doc = " required to optimize space usage.)  The first/second names are merely"]
        #[doc = " conceptual!"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Pair {
            pub _address: u8,
        }
        pub type Pair_Base = u8;
        #[doc = " UniquePtr is a smart pointer that wholly owns a resource.  Ownership may be"]
        #[doc = " transferred out of a UniquePtr through explicit action, but otherwise the"]
        #[doc = " resource is destroyed when the UniquePtr is destroyed."]
        #[doc = ""]
        #[doc = " UniquePtr is similar to C++98's std::auto_ptr, but it improves upon auto_ptr"]
        #[doc = " in one crucial way: it's impossible to copy a UniquePtr.  Copying an auto_ptr"]
        #[doc = " obviously *can't* copy ownership of its singly-owned resource.  So what"]
        #[doc = " happens if you try to copy one?  Bizarrely, ownership is implicitly"]
        #[doc = " *transferred*, preserving single ownership but breaking code that assumes a"]
        #[doc = " copy of an object is identical to the original.  (This is why auto_ptr is"]
        #[doc = " prohibited in STL containers.)"]
        #[doc = ""]
        #[doc = " UniquePtr solves this problem by being *movable* rather than copyable."]
        #[doc = " Instead of passing a |UniquePtr u| directly to the constructor or assignment"]
        #[doc = " operator, you pass |Move(u)|.  In doing so you indicate that you're *moving*"]
        #[doc = " ownership out of |u|, into the target of the construction/assignment.  After"]
        #[doc = " the transfer completes, |u| contains |nullptr| and may be safely destroyed."]
        #[doc = " This preserves single ownership but also allows UniquePtr to be moved by"]
        #[doc = " algorithms that have been made move-safe.  (Note: if |u| is instead a"]
        #[doc = " temporary expression, don't use |Move()|: just pass the expression, because"]
        #[doc = " it's already move-ready.  For more information see Move.h.)"]
        #[doc = ""]
        #[doc = " UniquePtr is also better than std::auto_ptr in that the deletion operation is"]
        #[doc = " customizable.  An optional second template parameter specifies a class that"]
        #[doc = " (through its operator()(T*)) implements the desired deletion policy.  If no"]
        #[doc = " policy is specified, mozilla::DefaultDelete<T> is used -- which will either"]
        #[doc = " |delete| or |delete[]| the resource, depending whether the resource is an"]
        #[doc = " array.  Custom deletion policies ideally should be empty classes (no member"]
        #[doc = " fields, no member fields in base classes, no virtual methods/inheritance),"]
        #[doc = " because then UniquePtr can be just as efficient as a raw pointer."]
        #[doc = ""]
        #[doc = " Use of UniquePtr proceeds like so:"]
        #[doc = ""]
        #[doc = "   UniquePtr<int> g1; // initializes to nullptr"]
        #[doc = "   g1.reset(new int); // switch resources using reset()"]
        #[doc = "   g1 = nullptr; // clears g1, deletes the int"]
        #[doc = ""]
        #[doc = "   UniquePtr<int> g2(new int); // owns that int"]
        #[doc = "   int* p = g2.release(); // g2 leaks its int -- still requires deletion"]
        #[doc = "   delete p; // now freed"]
        #[doc = ""]
        #[doc = "   struct S { int x; S(int x) : x(x) {} };"]
        #[doc = "   UniquePtr<S> g3, g4(new S(5));"]
        #[doc = "   g3 = std::move(g4); // g3 owns the S, g4 cleared"]
        #[doc = "   S* p = g3.get(); // g3 still owns |p|"]
        #[doc = "   assert(g3->x == 5); // operator-> works (if .get() != nullptr)"]
        #[doc = "   assert((*g3).x == 5); // also operator* (again, if not cleared)"]
        #[doc = "   Swap(g3, g4); // g4 now owns the S, g3 cleared"]
        #[doc = "   g3.swap(g4);  // g3 now owns the S, g4 cleared"]
        #[doc = "   UniquePtr<S> g5(std::move(g3)); // g5 owns the S, g3 cleared"]
        #[doc = "   g5.reset(); // deletes the S, g5 cleared"]
        #[doc = ""]
        #[doc = "   struct FreePolicy { void operator()(void* p) { free(p); } };"]
        #[doc = "   UniquePtr<int, FreePolicy> g6(static_cast<int*>(malloc(sizeof(int))));"]
        #[doc = "   int* ptr = g6.get();"]
        #[doc = "   g6 = nullptr; // calls free(ptr)"]
        #[doc = ""]
        #[doc = " Now, carefully note a few things you *can't* do:"]
        #[doc = ""]
        #[doc = "   UniquePtr<int> b1;"]
        #[doc = "   b1 = new int; // BAD: can only assign another UniquePtr"]
        #[doc = "   int* ptr = b1; // BAD: no auto-conversion to pointer, use get()"]
        #[doc = ""]
        #[doc = "   UniquePtr<int> b2(b1); // BAD: can't copy a UniquePtr"]
        #[doc = "   UniquePtr<int> b3 = b1; // BAD: can't copy-assign a UniquePtr"]
        #[doc = ""]
        #[doc = " (Note that changing a UniquePtr to store a direct |new| expression is"]
        #[doc = " permitted, but usually you should use MakeUnique, defined at the end of this"]
        #[doc = " header.)"]
        #[doc = ""]
        #[doc = " A few miscellaneous notes:"]
        #[doc = ""]
        #[doc = " UniquePtr, when not instantiated for an array type, can be move-constructed"]
        #[doc = " and move-assigned, not only from itself but from \"derived\" UniquePtr<U, E>"]
        #[doc = " instantiations where U converts to T and E converts to D.  If you want to use"]
        #[doc = " this, you're going to have to specify a deletion policy for both UniquePtr"]
        #[doc = " instantations, and T pretty much has to have a virtual destructor.  In other"]
        #[doc = " words, this doesn't work:"]
        #[doc = ""]
        #[doc = "   struct Base { virtual ~Base() {} };"]
        #[doc = "   struct Derived : Base {};"]
        #[doc = ""]
        #[doc = "   UniquePtr<Base> b1;"]
        #[doc = "   // BAD: DefaultDelete<Base> and DefaultDelete<Derived> don't interconvert"]
        #[doc = "   UniquePtr<Derived> d1(std::move(b));"]
        #[doc = ""]
        #[doc = "   UniquePtr<Base> b2;"]
        #[doc = "   UniquePtr<Derived, DefaultDelete<Base>> d2(std::move(b2)); // okay"]
        #[doc = ""]
        #[doc = " UniquePtr is specialized for array types.  Specializing with an array type"]
        #[doc = " creates a smart-pointer version of that array -- not a pointer to such an"]
        #[doc = " array."]
        #[doc = ""]
        #[doc = "   UniquePtr<int[]> arr(new int[5]);"]
        #[doc = "   arr[0] = 4;"]
        #[doc = ""]
        #[doc = " What else is different?  Deletion of course uses |delete[]|.  An operator[]"]
        #[doc = " is provided.  Functionality that doesn't make sense for arrays is removed."]
        #[doc = " The constructors and mutating methods only accept array pointers (not T*, U*"]
        #[doc = " that converts to T*, or UniquePtr<U[]> or UniquePtr<U>) or |nullptr|."]
        #[doc = ""]
        #[doc = " It's perfectly okay for a function to return a UniquePtr. This transfers"]
        #[doc = " the UniquePtr's sole ownership of the data, to the fresh UniquePtr created"]
        #[doc = " in the calling function, that will then solely own that data. Such functions"]
        #[doc = " can return a local variable UniquePtr, |nullptr|, |UniquePtr(ptr)| where"]
        #[doc = " |ptr| is a |T*|, or a UniquePtr |Move()|'d from elsewhere."]
        #[doc = ""]
        #[doc = " UniquePtr will commonly be a member of a class, with lifetime equivalent to"]
        #[doc = " that of that class.  If you want to expose the related resource, you could"]
        #[doc = " expose a raw pointer via |get()|, but ownership of a raw pointer is"]
        #[doc = " inherently unclear.  So it's better to expose a |const UniquePtr&| instead."]
        #[doc = " This prohibits mutation but still allows use of |get()| when needed (but"]
        #[doc = " operator-> is preferred).  Of course, you can only use this smart pointer as"]
        #[doc = " long as the enclosing class instance remains live -- no different than if you"]
        #[doc = " exposed the |get()| raw pointer."]
        #[doc = ""]
        #[doc = " To pass a UniquePtr-managed resource as a pointer, use a |const UniquePtr&|"]
        #[doc = " argument.  To specify an inout parameter (where the method may or may not"]
        #[doc = " take ownership of the resource, or reset it), or to specify an out parameter"]
        #[doc = " (where simply returning a |UniquePtr| isn't possible), use a |UniquePtr&|"]
        #[doc = " argument.  To unconditionally transfer ownership of a UniquePtr"]
        #[doc = " into a method, use a |UniquePtr| argument.  To conditionally transfer"]
        #[doc = " ownership of a resource into a method, should the method want it, use a"]
        #[doc = " |UniquePtr&&| argument."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct UniquePtr {
            pub _address: u8,
        }
        pub type UniquePtr_ElementType = u8;
        pub type UniquePtr_DeleterType = u8;
        pub type UniquePtr_Pointer = u8;
        #[doc = " A default deletion policy using plain old operator delete."]
        #[doc = ""]
        #[doc = " Note that this type can be specialized, but authors should beware of the risk"]
        #[doc = " that the specialization may at some point cease to match (either because it"]
        #[doc = " gets moved to a different compilation unit or the signature changes). If the"]
        #[doc = " non-specialized (|delete|-based) version compiles for that type but does the"]
        #[doc = " wrong thing, bad things could happen."]
        #[doc = ""]
        #[doc = " This is a non-issue for types which are always incomplete (i.e. opaque handle"]
        #[doc = " types), since |delete|-ing such a type will always trigger a compilation"]
        #[doc = " error."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DefaultDelete {
            pub _address: u8,
        }
        pub mod span_details {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub type remove_cv_t = root::mozilla::RemoveCV;
            pub type remove_const_t = root::mozilla::RemoveConst;
            pub type conditional_t = u8;
            pub type add_pointer_t = root::mozilla::AddPointer;
            pub type enable_if_t = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_span_oracle {
                pub _base: root::mozilla::FalseType,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_span {
                pub _base: root::mozilla::span_details::is_span_oracle,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_std_array_oracle {
                pub _base: root::mozilla::FalseType,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_std_array {
                pub _base: root::mozilla::span_details::is_std_array_oracle,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_allowed_element_type_conversion {
                pub _address: u8,
            }
            pub type span_iterator_element_type_ = [u8; 0usize];
            pub type span_iterator_iterator_category = root::std::random_access_iterator_tag;
            pub type span_iterator_value_type = root::mozilla::span_details::remove_const_t;
            pub type span_iterator_difference_type = [u8; 0usize];
            pub type span_iterator_reference = *mut [u8; 0usize];
            pub type span_iterator_pointer = root::mozilla::span_details::add_pointer_t;
            pub type extent_type_index_type = usize;
        }
        pub type Span_element_type<ElementType> = ElementType;
        pub type Span_index_type = usize;
        pub type Span_pointer<ElementType> = *mut root::mozilla::Span_element_type<ElementType>;
        pub type Span_reference<ElementType> = *mut root::mozilla::Span_element_type<ElementType>;
        pub type Span_iterator = u8;
        pub type Span_const_iterator = u8;
        pub type Span_reverse_iterator = root::std::reverse_iterator<root::mozilla::Span_iterator>;
        pub type Span_const_reverse_iterator =
            root::std::reverse_iterator<root::mozilla::Span_const_iterator>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Span_storage_type<ElementType, ExtentType> {
            pub _base: ExtentType,
            pub data_: root::mozilla::Span_pointer<ElementType>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<ElementType>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<ExtentType>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Range<T> {
            pub mStart: root::mozilla::RangedPtr<T>,
            pub mEnd: root::mozilla::RangedPtr<T>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct OwningNonNull {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct StaticLocalRefPtr {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct StaticRefPtr {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RefPtrTraits {
            pub _address: u8,
        }
        pub mod tl {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static Min_value: usize;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static Max_value: usize;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static FloorLog2_value: usize;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static CeilingLog2_value: usize;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static RoundUpPow2_value: usize;
            }
            #[doc = " Compute the number of bits in the given unsigned type."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct BitSize {
                pub _address: u8,
            }
            extern "C" {
                #[link_name = "\u{1}checkPrecondition"]
                pub static NBitMask_checkPrecondition: usize;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static NBitMask_value: usize;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static MulOverflowMask_value: usize;
            }
        }
        #[doc = " Tuple is a class that stores zero or more objects, whose types are specified"]
        #[doc = " as template parameters. It can be thought of as a generalization of Pair,"]
        #[doc = " (which can be thought of as a 2-tuple)."]
        #[doc = ""]
        #[doc = " Tuple allows index-based access to its elements (with the index having to be"]
        #[doc = " known at compile time) via the non-member function 'Get<N>(tuple)'."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Tuple {
            pub _address: u8,
        }
        pub type Tuple_Impl = u8;
        #[test]
        fn __bindgen_test_layout_Tuple_open0_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::Tuple>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::Tuple)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::Tuple>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::Tuple)
                )
            );
        }
        #[doc = " A code unit within a UTF-8 encoded string.  (A code unit is the smallest"]
        #[doc = " unit within the Unicode encoding of a string.  For UTF-8 this is an 8-bit"]
        #[doc = " number; for UTF-16 it would be a 16-bit number.)"]
        #[doc = ""]
        #[doc = " This is *not* the same as a single code point: in UTF-8, non-ASCII code"]
        #[doc = " points are constituted by multiple code units."]
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union Utf8Unit {
            pub mValue: ::std::os::raw::c_char,
            _bindgen_union_align: u8,
        }
        #[test]
        fn bindgen_test_layout_Utf8Unit() {
            assert_eq!(
                ::std::mem::size_of::<Utf8Unit>(),
                1usize,
                concat!("Size of: ", stringify!(Utf8Unit))
            );
            assert_eq!(
                ::std::mem::align_of::<Utf8Unit>(),
                1usize,
                concat!("Alignment of ", stringify!(Utf8Unit))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Utf8Unit>())).mValue as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Utf8Unit),
                    "::",
                    stringify!(mValue)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct FunctionTypeTraits {
            pub _address: u8,
        }
        pub type HashNumber = u32;
        #[doc = " A pseudorandom function mapping 32-bit integers to 32-bit integers."]
        #[doc = ""]
        #[doc = " This is for when you're feeding private data (like pointer values or credit"]
        #[doc = " card numbers) to a non-crypto hash function (like HashBytes) and then using"]
        #[doc = " the hash code for something that untrusted parties could observe (like a JS"]
        #[doc = " Map). Plug in a HashCodeScrambler before that last step to avoid leaking the"]
        #[doc = " private data."]
        #[doc = ""]
        #[doc = " By itself, this does not prevent hash-flooding DoS attacks, because an"]
        #[doc = " attacker can still generate many values with exactly equal hash codes by"]
        #[doc = " attacking the non-crypto hash function alone. Equal hash codes will, of"]
        #[doc = " course, still be equal however much you scramble them."]
        #[doc = ""]
        #[doc = " The algorithm is SipHash-1-3. See <https://131002.net/siphash/>."]
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Debug, Copy, Clone)]
        pub struct HashCodeScrambler {
            pub _bindgen_opaque_blob: [u64; 2usize],
        }
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Debug, Copy, Clone)]
        pub struct HashCodeScrambler_SipHasher {
            pub _bindgen_opaque_blob: [u64; 4usize],
        }
        #[test]
        fn bindgen_test_layout_HashCodeScrambler_SipHasher() {
            assert_eq!(
                ::std::mem::size_of::<HashCodeScrambler_SipHasher>(),
                32usize,
                concat!("Size of: ", stringify!(HashCodeScrambler_SipHasher))
            );
            assert_eq!(
                ::std::mem::align_of::<HashCodeScrambler_SipHasher>(),
                8usize,
                concat!("Alignment of ", stringify!(HashCodeScrambler_SipHasher))
            );
        }
        #[test]
        fn bindgen_test_layout_HashCodeScrambler() {
            assert_eq!(
                ::std::mem::size_of::<HashCodeScrambler>(),
                16usize,
                concat!("Size of: ", stringify!(HashCodeScrambler))
            );
            assert_eq!(
                ::std::mem::align_of::<HashCodeScrambler>(),
                8usize,
                concat!("Alignment of ", stringify!(HashCodeScrambler))
            );
        }
        pub mod ipc {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IPDLParamTraits {
                pub _address: u8,
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct VariantType {
            pub _address: u8,
        }
        pub type VariantType_Type<T> = T;
        extern "C" {
            #[link_name = "\u{1}index"]
            pub static VariantIndex_index: usize;
        }
        #[doc = " # mozilla::Variant"]
        #[doc = ""]
        #[doc = " A variant / tagged union / heterogenous disjoint union / sum-type template"]
        #[doc = " class. Similar in concept to (but not derived from) `boost::variant`."]
        #[doc = ""]
        #[doc = " Sometimes, you may wish to use a C union with non-POD types. However, this is"]
        #[doc = " forbidden in C++ because it is not clear which type in the union should have"]
        #[doc = " its constructor and destructor run on creation and deletion"]
        #[doc = " respectively. This is the problem that `mozilla::Variant` solves."]
        #[doc = ""]
        #[doc = " ## Usage"]
        #[doc = ""]
        #[doc = " A `mozilla::Variant` instance is constructed (via move or copy) from one of"]
        #[doc = " its variant types (ignoring const and references). It does *not* support"]
        #[doc = " construction from subclasses of variant types or types that coerce to one of"]
        #[doc = " the variant types."]
        #[doc = ""]
        #[doc = "     Variant<char, uint32_t> v1('a');"]
        #[doc = "     Variant<UniquePtr<A>, B, C> v2(MakeUnique<A>());"]
        #[doc = "     Variant<bool, char> v3(VariantType<char>, 0); // disambiguation needed"]
        #[doc = "     Variant<int, int> v4(VariantIndex<1>, 0); // 2nd int"]
        #[doc = ""]
        #[doc = " Because specifying the full type of a Variant value is often verbose,"]
        #[doc = " there are two easier ways to construct values:"]
        #[doc = ""]
        #[doc = " A. AsVariant() can be used to construct a Variant value using type inference"]
        #[doc = " in contexts such as expressions or when returning values from functions."]
        #[doc = " Because AsVariant() must copy or move the value into a temporary and this"]
        #[doc = " cannot necessarily be elided by the compiler, it's mostly appropriate only"]
        #[doc = " for use with primitive or very small types."]
        #[doc = ""]
        #[doc = "     Variant<char, uint32_t> Foo() { return AsVariant('x'); }"]
        #[doc = "     // ..."]
        #[doc = "     Variant<char, uint32_t> v1 = Foo();  // v1 holds char('x')."]
        #[doc = ""]
        #[doc = " B. Brace-construction with VariantType or VariantIndex; this also allows"]
        #[doc = " in-place construction with any number of arguments."]
        #[doc = ""]
        #[doc = "     struct AB { AB(int, int){...} };"]
        #[doc = "     static Variant<AB, bool> foo()"]
        #[doc = "     {"]
        #[doc = "       return {VariantIndex<0>{}, 1, 2};"]
        #[doc = "     }"]
        #[doc = "     // ..."]
        #[doc = "     Variant<AB, bool> v0 = Foo();  // v0 holds AB(1,2)."]
        #[doc = ""]
        #[doc = " All access to the contained value goes through type-safe accessors."]
        #[doc = " Either the stored type, or the type index may be provided."]
        #[doc = ""]
        #[doc = "     void"]
        #[doc = "     Foo(Variant<A, B, C> v)"]
        #[doc = "     {"]
        #[doc = "       if (v.is<A>()) {"]
        #[doc = "         A& ref = v.as<A>();"]
        #[doc = "         ..."]
        #[doc = "       } else (v.is<1>()) { // Instead of v.is<B>."]
        #[doc = "         ..."]
        #[doc = "       } else {"]
        #[doc = "         ..."]
        #[doc = "       }"]
        #[doc = "     }"]
        #[doc = ""]
        #[doc = " In some situation, a Variant may be constructed from templated types, in"]
        #[doc = " which case it is possible that the same type could be given multiple times by"]
        #[doc = " an external developer. Or seemingly-different types could be aliases."]
        #[doc = " In this case, repeated types can only be accessed through their index, to"]
        #[doc = " prevent ambiguous access by type."]
        #[doc = ""]
        #[doc = "    // Bad!"]
        #[doc = "    template <typename T>"]
        #[doc = "    struct ResultOrError"]
        #[doc = "    {"]
        #[doc = "      Variant<T, int> m;"]
        #[doc = "      ResultOrError() : m(int(0)) {} // Error '0' by default"]
        #[doc = "      ResultOrError(const T& r) : m(r) {}"]
        #[doc = "      bool IsResult() const { return m.is<T>(); }"]
        #[doc = "      bool IsError() const { return m.is<int>(); }"]
        #[doc = "    };"]
        #[doc = "    // Now instantiante with the result being an int too:"]
        #[doc = "    ResultOrError<int> myResult(123); // Fail!"]
        #[doc = "    // In Variant<int, int>, which 'int' are we refering to, from inside"]
        #[doc = "    // ResultOrError functions?"]
        #[doc = ""]
        #[doc = "    // Good!"]
        #[doc = "    template <typename T>"]
        #[doc = "    struct ResultOrError"]
        #[doc = "    {"]
        #[doc = "      Variant<T, int> m;"]
        #[doc = "      ResultOrError() : m(VariantIndex<1>{}, 0) {} // Error '0' by default"]
        #[doc = "      ResultOrError(const T& r) : m(VariantIndex<0>{}, r) {}"]
        #[doc = "      bool IsResult() const { return m.is<0>(); } // 0 -> T"]
        #[doc = "      bool IsError() const { return m.is<1>(); } // 1 -> int"]
        #[doc = "    };"]
        #[doc = "    // Now instantiante with the result being an int too:"]
        #[doc = "    ResultOrError<int> myResult(123); // It now works!"]
        #[doc = ""]
        #[doc = " Attempting to use the contained value as type `T1` when the `Variant`"]
        #[doc = " instance contains a value of type `T2` causes an assertion failure."]
        #[doc = ""]
        #[doc = "     A a;"]
        #[doc = "     Variant<A, B, C> v(a);"]
        #[doc = "     v.as<B>(); // <--- Assertion failure!"]
        #[doc = ""]
        #[doc = " Trying to use a `Variant<Ts...>` instance as some type `U` that is not a"]
        #[doc = " member of the set of `Ts...` is a compiler error."]
        #[doc = ""]
        #[doc = "     A a;"]
        #[doc = "     Variant<A, B, C> v(a);"]
        #[doc = "     v.as<SomeRandomType>(); // <--- Compiler error!"]
        #[doc = ""]
        #[doc = " Additionally, you can turn a `Variant` that `is<T>` into a `T` by moving it"]
        #[doc = " out of the containing `Variant` instance with the `extract<T>` method:"]
        #[doc = ""]
        #[doc = "     Variant<UniquePtr<A>, B, C> v(MakeUnique<A>());"]
        #[doc = "     auto ptr = v.extract<UniquePtr<A>>();"]
        #[doc = ""]
        #[doc = " Finally, you can exhaustively match on the contained variant and branch into"]
        #[doc = " different code paths depending on which type is contained. This is preferred"]
        #[doc = " to manually checking every variant type T with is<T>() because it provides"]
        #[doc = " compile-time checking that you handled every type, rather than runtime"]
        #[doc = " assertion failures."]
        #[doc = ""]
        #[doc = "     // Bad!"]
        #[doc = "     char* foo(Variant<A, B, C, D>& v) {"]
        #[doc = "       if (v.is<A>()) {"]
        #[doc = "         return ...;"]
        #[doc = "       } else if (v.is<B>()) {"]
        #[doc = "         return ...;"]
        #[doc = "       } else {"]
        #[doc = "         return doSomething(v.as<C>()); // Forgot about case D!"]
        #[doc = "       }"]
        #[doc = "     }"]
        #[doc = ""]
        #[doc = "     // Instead, a single function object (that can deal with all possible"]
        #[doc = "     // options) may be provided:"]
        #[doc = "     struct FooMatcher"]
        #[doc = "     {"]
        #[doc = "       // The return type of all matchers must be identical."]
        #[doc = "       char* operator()(A& a) { ... }"]
        #[doc = "       char* operator()(B& b) { ... }"]
        #[doc = "       char* operator()(C& c) { ... }"]
        #[doc = "       char* operator()(D& d) { ... } // Compile-time error to forget D!"]
        #[doc = "     }"]
        #[doc = "     char* foo(Variant<A, B, C, D>& v) {"]
        #[doc = "       return v.match(FooMatcher());"]
        #[doc = "     }"]
        #[doc = ""]
        #[doc = "     // In some situations, a single generic lambda may also be appropriate:"]
        #[doc = "     char* foo(Variant<A, B, C, D>& v) {"]
        #[doc = "       return v.match([](auto&){...});"]
        #[doc = "     }"]
        #[doc = ""]
        #[doc = "     // Alternatively, multiple function objects may be provided, each one"]
        #[doc = "     // corresponding to an option, in the same order:"]
        #[doc = "     char* foo(Variant<A, B, C, D>& v) {"]
        #[doc = "       return v.match([](A&) { ... },"]
        #[doc = "                      [](B&) { ... },"]
        #[doc = "                      [](C&) { ... },"]
        #[doc = "                      [](D&) { ... });"]
        #[doc = "     }"]
        #[doc = ""]
        #[doc = " ## Examples"]
        #[doc = ""]
        #[doc = " A tree is either an empty leaf, or a node with a value and two children:"]
        #[doc = ""]
        #[doc = "     struct Leaf { };"]
        #[doc = ""]
        #[doc = "     template<typename T>"]
        #[doc = "     struct Node"]
        #[doc = "     {"]
        #[doc = "       T value;"]
        #[doc = "       Tree<T>* left;"]
        #[doc = "       Tree<T>* right;"]
        #[doc = "     };"]
        #[doc = ""]
        #[doc = "     template<typename T>"]
        #[doc = "     using Tree = Variant<Leaf, Node<T>>;"]
        #[doc = ""]
        #[doc = " A copy-on-write string is either a non-owning reference to some existing"]
        #[doc = " string, or an owning reference to our copy:"]
        #[doc = ""]
        #[doc = "     class CopyOnWriteString"]
        #[doc = "     {"]
        #[doc = "       Variant<const char*, UniquePtr<char[]>> string;"]
        #[doc = ""]
        #[doc = "       ..."]
        #[doc = "     };"]
        #[doc = ""]
        #[doc = " Because Variant must be aligned suitable to hold any value stored within it,"]
        #[doc = " and because |alignas| requirements don't affect platform ABI with respect to"]
        #[doc = " how parameters are laid out in memory, Variant can't be used as the type of a"]
        #[doc = " function parameter.  Pass Variant to functions by pointer or reference"]
        #[doc = " instead."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Variant {
            pub _address: u8,
        }
        pub type Variant_Tag = root::mozilla::detail::VariantTag;
        pub type Variant_Impl = u8;
        #[doc = " Empty struct, indicating success for operations that have no return value."]
        #[doc = " For example, if you declare another empty struct `struct OutOfMemory {};`,"]
        #[doc = " then `Result<Ok, OutOfMemory>` represents either success or OOM."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Ok {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_Ok() {
            assert_eq!(
                ::std::mem::size_of::<Ok>(),
                1usize,
                concat!("Size of: ", stringify!(Ok))
            );
            assert_eq!(
                ::std::mem::align_of::<Ok>(),
                1usize,
                concat!("Alignment of ", stringify!(Ok))
            );
        }
        #[doc = " Result<V, E> represents the outcome of an operation that can either succeed"]
        #[doc = " or fail. It contains either a success value of type V or an error value of"]
        #[doc = " type E."]
        #[doc = ""]
        #[doc = " All Result methods are const, so results are basically immutable."]
        #[doc = " This is just like Variant<V, E> but with a slightly different API, and the"]
        #[doc = " following cases are optimized so Result can be stored more efficiently:"]
        #[doc = ""]
        #[doc = " - If the success type is Ok (or another empty class) and the error type is a"]
        #[doc = "   reference, Result<V, E&> is guaranteed to be pointer-sized and all zero"]
        #[doc = "   bits on success. Do not change this representation! There is JIT code that"]
        #[doc = "   depends on it."]
        #[doc = ""]
        #[doc = " - If the success type is a pointer type and the error type is a reference"]
        #[doc = "   type, and the least significant bit is unused for both types when stored"]
        #[doc = "   as a pointer (due to alignment rules), Result<V*, E&> is guaranteed to be"]
        #[doc = "   pointer-sized. In this case, we use the lowest bit as tag bit: 0 to"]
        #[doc = "   indicate the Result's bits are a V, 1 to indicate the Result's bits (with"]
        #[doc = "   the 1 masked out) encode an E*."]
        #[doc = ""]
        #[doc = " The purpose of Result is to reduce the screwups caused by using `false` or"]
        #[doc = " `nullptr` to indicate errors."]
        #[doc = " What screwups? See <https://bugzilla.mozilla.org/show_bug.cgi?id=912928> for"]
        #[doc = " a partial list."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Result {
            pub mImpl: root::mozilla::Result_Impl,
        }
        pub type Result_Impl = root::mozilla::detail::SelectResultImpl;
        #[doc = " A type that auto-converts to an error Result. This is like a Result without"]
        #[doc = " a success type. It's the best return type for functions that always return"]
        #[doc = " an error--functions designed to build and populate error objects. It's also"]
        #[doc = " useful in error-handling macros; see MOZ_TRY for an example."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GenericErrorResult<E> {
            pub mErrorValue: E,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<E>>,
        }
        pub mod recordreplay {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug)]
            pub struct AutoOrderedAtomicAccess {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_AutoOrderedAtomicAccess() {
                assert_eq!(
                    ::std::mem::size_of::<AutoOrderedAtomicAccess>(),
                    1usize,
                    concat!("Size of: ", stringify!(AutoOrderedAtomicAccess))
                );
                assert_eq!(
                    ::std::mem::align_of::<AutoOrderedAtomicAccess>(),
                    1usize,
                    concat!("Alignment of ", stringify!(AutoOrderedAtomicAccess))
                );
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct AutoPassThroughThreadEvents {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_AutoPassThroughThreadEvents() {
                assert_eq!(
                    ::std::mem::size_of::<AutoPassThroughThreadEvents>(),
                    1usize,
                    concat!("Size of: ", stringify!(AutoPassThroughThreadEvents))
                );
                assert_eq!(
                    ::std::mem::align_of::<AutoPassThroughThreadEvents>(),
                    1usize,
                    concat!("Alignment of ", stringify!(AutoPassThroughThreadEvents))
                );
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct AutoEnsurePassThroughThreadEvents {
                pub mPassedThrough: bool,
            }
            #[test]
            fn bindgen_test_layout_AutoEnsurePassThroughThreadEvents() {
                assert_eq!(
                    ::std::mem::size_of::<AutoEnsurePassThroughThreadEvents>(),
                    1usize,
                    concat!("Size of: ", stringify!(AutoEnsurePassThroughThreadEvents))
                );
                assert_eq!(
                    ::std::mem::align_of::<AutoEnsurePassThroughThreadEvents>(),
                    1usize,
                    concat!(
                        "Alignment of ",
                        stringify!(AutoEnsurePassThroughThreadEvents)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<AutoEnsurePassThroughThreadEvents>())).mPassedThrough
                            as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(AutoEnsurePassThroughThreadEvents),
                        "::",
                        stringify!(mPassedThrough)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct AutoDisallowThreadEvents {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_AutoDisallowThreadEvents() {
                assert_eq!(
                    ::std::mem::size_of::<AutoDisallowThreadEvents>(),
                    1usize,
                    concat!("Size of: ", stringify!(AutoDisallowThreadEvents))
                );
                assert_eq!(
                    ::std::mem::align_of::<AutoDisallowThreadEvents>(),
                    1usize,
                    concat!("Alignment of ", stringify!(AutoDisallowThreadEvents))
                );
            }
            #[repr(i32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum Behavior {
                DontPreserve = 0,
                Preserve = 1,
            }
            #[repr(i32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum ProcessKind {
                Recording = 0,
                Replaying = 1,
                MiddlemanRecording = 2,
                MiddlemanReplaying = 3,
            }
            #[doc = ""]
            pub type ProgressCounter = u64;
        }
        #[repr(u32)]
        #[doc = " An enum of memory ordering possibilities for atomics."]
        #[doc = ""]
        #[doc = " Memory ordering is the observable state of distinct values in memory."]
        #[doc = " (It's a separate concept from atomicity, which concerns whether an"]
        #[doc = " operation can ever be observed in an intermediate state.  Don't"]
        #[doc = " conflate the two!)  Given a sequence of operations in source code on"]
        #[doc = " memory, it is *not* always the case that, at all times and on all"]
        #[doc = " cores, those operations will appear to have occurred in that exact"]
        #[doc = " sequence.  First, the compiler might reorder that sequence, if it"]
        #[doc = " thinks another ordering will be more efficient.  Second, the CPU may"]
        #[doc = " not expose so consistent a view of memory.  CPUs will often perform"]
        #[doc = " their own instruction reordering, above and beyond that performed by"]
        #[doc = " the compiler.  And each core has its own memory caches, and accesses"]
        #[doc = " (reads and writes both) to \"memory\" may only resolve to out-of-date"]
        #[doc = " cache entries -- not to the \"most recently\" performed operation in"]
        #[doc = " some global sense.  Any access to a value that may be used by"]
        #[doc = " multiple threads, potentially across multiple cores, must therefore"]
        #[doc = " have a memory ordering imposed on it, for all code on all"]
        #[doc = " threads/cores to have a sufficiently coherent worldview."]
        #[doc = ""]
        #[doc = " http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync and"]
        #[doc = " http://en.cppreference.com/w/cpp/atomic/memory_order go into more"]
        #[doc = " detail on all this, including examples of how each mode works."]
        #[doc = ""]
        #[doc = " Note that for simplicity and practicality, not all of the modes in"]
        #[doc = " C++11 are supported.  The missing C++11 modes are either subsumed by"]
        #[doc = " the modes we provide below, or not relevant for the CPUs we support"]
        #[doc = " in Gecko.  These three modes are confusing enough as it is!"]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum MemoryOrdering {
            Relaxed = 0,
            ReleaseAcquire = 1,
            SequentiallyConsistent = 2,
        }
        #[doc = " DebugOnly contains a value of type T, but only in debug builds.  In release"]
        #[doc = " builds, it does not contain a value.  This helper is intended to be used with"]
        #[doc = " MOZ_ASSERT()-style macros, allowing one to write:"]
        #[doc = ""]
        #[doc = "   DebugOnly<bool> check = func();"]
        #[doc = "   MOZ_ASSERT(check);"]
        #[doc = ""]
        #[doc = " more concisely than declaring |check| conditional on #ifdef DEBUG."]
        #[doc = ""]
        #[doc = " DebugOnly instances can only be coerced to T in debug builds.  In release"]
        #[doc = " builds they don't have a value, so type coercion is not well defined."]
        #[doc = ""]
        #[doc = " NOTE: DebugOnly instances still take up one byte of space, plus padding, even"]
        #[doc = " in optimized, non-DEBUG builds (see bug 1253094 comment 37 for more info)."]
        #[doc = " For this reason the class is MOZ_STACK_CLASS to prevent consumers using"]
        #[doc = " DebugOnly for struct/class members and unwittingly inflating the size of"]
        #[doc = " their objects in release builds."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct DebugOnly {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct LinkedListElement {
            pub mNext: *mut root::mozilla::LinkedListElement,
            pub mPrev: *mut root::mozilla::LinkedListElement,
            pub mIsSentinel: bool,
        }
        pub type LinkedListElement_Traits = root::mozilla::detail::LinkedListElementTraits;
        pub type LinkedListElement_RawType = root::mozilla::LinkedListElement_Traits;
        pub type LinkedListElement_ConstRawType = root::mozilla::LinkedListElement_Traits;
        pub type LinkedListElement_ClientType = root::mozilla::LinkedListElement_Traits;
        pub type LinkedListElement_ConstClientType = root::mozilla::LinkedListElement_Traits;
        impl root::mozilla::LinkedListElement_NodeKind {
            pub const Sentinel: root::mozilla::LinkedListElement_NodeKind =
                LinkedListElement_NodeKind::Normal;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum LinkedListElement_NodeKind {
            Normal = 0,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct LinkedList {
            pub sentinel: root::mozilla::LinkedListElement,
        }
        pub type LinkedList_Traits = root::mozilla::detail::LinkedListElementTraits;
        pub type LinkedList_RawType = root::mozilla::LinkedList_Traits;
        pub type LinkedList_ConstRawType = root::mozilla::LinkedList_Traits;
        pub type LinkedList_ClientType = root::mozilla::LinkedList_Traits;
        pub type LinkedList_ConstClientType = root::mozilla::LinkedList_Traits;
        pub type LinkedList_ElementType = *mut root::mozilla::LinkedListElement;
        pub type LinkedList_ConstElementType = *const root::mozilla::LinkedListElement;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct LinkedList_Iterator<Type> {
            pub mCurrent: Type,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Type>>,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoCleanLinkedList {
            pub _base: root::mozilla::LinkedList,
        }
        pub type AutoCleanLinkedList_Traits = root::mozilla::detail::LinkedListElementTraits;
        pub type AutoCleanLinkedList_ClientType = root::mozilla::detail::LinkedListElementTraits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MallocAllocPolicy {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_MallocAllocPolicy() {
            assert_eq!(
                ::std::mem::size_of::<MallocAllocPolicy>(),
                1usize,
                concat!("Size of: ", stringify!(MallocAllocPolicy))
            );
            assert_eq!(
                ::std::mem::align_of::<MallocAllocPolicy>(),
                1usize,
                concat!("Alignment of ", stringify!(MallocAllocPolicy))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct NeverAllocPolicy {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_NeverAllocPolicy() {
            assert_eq!(
                ::std::mem::size_of::<NeverAllocPolicy>(),
                1usize,
                concat!("Size of: ", stringify!(NeverAllocPolicy))
            );
            assert_eq!(
                ::std::mem::align_of::<NeverAllocPolicy>(),
                1usize,
                concat!("Alignment of ", stringify!(NeverAllocPolicy))
            );
        }
        #[doc = " Opaque<T> is a replacement for integral T in cases where only comparisons"]
        #[doc = " must be supported, and it's desirable to prevent accidental dependency on"]
        #[doc = " exact values."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Opaque<T> {
            pub mValue: T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ReentrancyGuard {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_ReentrancyGuard() {
            assert_eq!(
                ::std::mem::size_of::<ReentrancyGuard>(),
                1usize,
                concat!("Size of: ", stringify!(ReentrancyGuard))
            );
            assert_eq!(
                ::std::mem::align_of::<ReentrancyGuard>(),
                1usize,
                concat!("Alignment of ", stringify!(ReentrancyGuard))
            );
        }
        pub type Generation = root::mozilla::Opaque<u64>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HashMap {
            pub _address: u8,
        }
        pub type HashMap_TableEntry = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HashMap_MapHashPolicy {
            pub _address: u8,
        }
        pub type HashMap_MapHashPolicy_Base = u8;
        pub type HashMap_MapHashPolicy_KeyType = u8;
        pub type HashMap_Impl = u8;
        pub type HashMap_Lookup = u8;
        pub type HashMap_Entry = u8;
        pub type HashMap_Ptr = u8;
        pub type HashMap_AddPtr = u8;
        pub type HashMap_Iterator = u8;
        pub type HashMap_ModIterator = u8;
        pub type HashMap_Range = u8;
        pub type HashMap_Enum = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HashSet {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HashSet_SetHashPolicy {
            pub _address: u8,
        }
        pub type HashSet_SetHashPolicy_Base = u8;
        pub type HashSet_SetHashPolicy_KeyType = u8;
        pub type HashSet_Impl = u8;
        pub type HashSet_Lookup = u8;
        pub type HashSet_Entry = u8;
        pub type HashSet_Ptr = u8;
        pub type HashSet_AddPtr = u8;
        pub type HashSet_Iterator = u8;
        pub type HashSet_ModIterator = u8;
        pub type HashSet_Range = u8;
        pub type HashSet_Enum = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PointerHasher {
            pub _address: u8,
        }
        pub type PointerHasher_Lookup<Key> = Key;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DefaultHasher {
            pub _address: u8,
        }
        pub type DefaultHasher_Lookup<Key> = Key;
        #[test]
        fn __bindgen_test_layout_DefaultHasher_open0_double_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::DefaultHasher>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::DefaultHasher)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::DefaultHasher>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::DefaultHasher)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_DefaultHasher_open0_float_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::mozilla::DefaultHasher>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::mozilla::DefaultHasher)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::mozilla::DefaultHasher>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::mozilla::DefaultHasher)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CStringHasher {
            pub _address: u8,
        }
        pub type CStringHasher_Key = *const ::std::os::raw::c_char;
        pub type CStringHasher_Lookup = *const ::std::os::raw::c_char;
        #[test]
        fn bindgen_test_layout_CStringHasher() {
            assert_eq!(
                ::std::mem::size_of::<CStringHasher>(),
                1usize,
                concat!("Size of: ", stringify!(CStringHasher))
            );
            assert_eq!(
                ::std::mem::align_of::<CStringHasher>(),
                1usize,
                concat!("Alignment of ", stringify!(CStringHasher))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct FallibleHashMethods {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HashMapEntry {
            pub _address: u8,
        }
        pub type HashMapEntry_KeyType = u8;
        pub type HashMapEntry_ValueType = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct LittleEndian {
            pub _base: u8,
        }
        #[test]
        fn bindgen_test_layout_LittleEndian() {
            assert_eq!(
                ::std::mem::size_of::<LittleEndian>(),
                1usize,
                concat!("Size of: ", stringify!(LittleEndian))
            );
            assert_eq!(
                ::std::mem::align_of::<LittleEndian>(),
                1usize,
                concat!("Alignment of ", stringify!(LittleEndian))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BigEndian {
            pub _base: u8,
        }
        #[test]
        fn bindgen_test_layout_BigEndian() {
            assert_eq!(
                ::std::mem::size_of::<BigEndian>(),
                1usize,
                concat!("Size of: ", stringify!(BigEndian))
            );
            assert_eq!(
                ::std::mem::align_of::<BigEndian>(),
                1usize,
                concat!("Alignment of ", stringify!(BigEndian))
            );
        }
        pub type NetworkEndian = root::mozilla::BigEndian;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct NativeEndian {
            pub _base: u8,
        }
        pub type NativeEndian_super = u8;
        #[test]
        fn bindgen_test_layout_NativeEndian() {
            assert_eq!(
                ::std::mem::size_of::<NativeEndian>(),
                1usize,
                concat!("Size of: ", stringify!(NativeEndian))
            );
            assert_eq!(
                ::std::mem::align_of::<NativeEndian>(),
                1usize,
                concat!("Alignment of ", stringify!(NativeEndian))
            );
        }
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Debug, Copy, Clone)]
        pub struct TimeStamp63Bit {
            pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 8usize], u64>,
        }
        #[test]
        fn bindgen_test_layout_TimeStamp63Bit() {
            assert_eq!(
                ::std::mem::size_of::<TimeStamp63Bit>(),
                8usize,
                concat!("Size of: ", stringify!(TimeStamp63Bit))
            );
            assert_eq!(
                ::std::mem::align_of::<TimeStamp63Bit>(),
                8usize,
                concat!("Alignment of ", stringify!(TimeStamp63Bit))
            );
        }
        impl TimeStamp63Bit {
            #[inline]
            pub fn mUsedCanonicalNow(&self) -> u64 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
            }
            #[inline]
            pub fn set_mUsedCanonicalNow(&mut self, val: u64) {
                unsafe {
                    let val: u64 = ::std::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn mTimeStamp(&self) -> u64 {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 63u8) as u64) }
            }
            #[inline]
            pub fn set_mTimeStamp(&mut self, val: u64) {
                unsafe {
                    let val: u64 = ::std::mem::transmute(val);
                    self._bitfield_1.set(1usize, 63u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(
                mUsedCanonicalNow: u64,
                mTimeStamp: u64,
            ) -> root::__BindgenBitfieldUnit<[u8; 8usize], u64> {
                let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 8usize], u64> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8, {
                    let mUsedCanonicalNow: u64 =
                        unsafe { ::std::mem::transmute(mUsedCanonicalNow) };
                    mUsedCanonicalNow as u64
                });
                __bindgen_bitfield_unit.set(1usize, 63u8, {
                    let mTimeStamp: u64 = unsafe { ::std::mem::transmute(mTimeStamp) };
                    mTimeStamp as u64
                });
                __bindgen_bitfield_unit
            }
        }
        pub type TimeStampValue = root::mozilla::TimeStamp63Bit;
        #[doc = " Platform-specific implementation details of BaseTimeDuration."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BaseTimeDurationPlatformUtils {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_BaseTimeDurationPlatformUtils() {
            assert_eq!(
                ::std::mem::size_of::<BaseTimeDurationPlatformUtils>(),
                1usize,
                concat!("Size of: ", stringify!(BaseTimeDurationPlatformUtils))
            );
            assert_eq!(
                ::std::mem::align_of::<BaseTimeDurationPlatformUtils>(),
                1usize,
                concat!("Alignment of ", stringify!(BaseTimeDurationPlatformUtils))
            );
        }
        #[doc = " Instances of this class represent the length of an interval of time."]
        #[doc = " Negative durations are allowed, meaning the end is before the start."]
        #[doc = ""]
        #[doc = " Internally the duration is stored as a int64_t in units of"]
        #[doc = " PR_TicksPerSecond() when building with NSPR interval timers, or a"]
        #[doc = " system-dependent unit when building with system clocks.  The"]
        #[doc = " system-dependent unit must be constant, otherwise the semantics of"]
        #[doc = " this class would be broken."]
        #[doc = ""]
        #[doc = " The ValueCalculator template parameter determines how arithmetic"]
        #[doc = " operations are performed on the integer count of ticks (mValue)."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BaseTimeDuration {
            pub mValue: i64,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BaseTimeDuration__SomethingVeryRandomHere {
            _unused: [u8; 0],
        }
        #[doc = " Perform arithmetic operations on the value of a BaseTimeDuration without"]
        #[doc = " doing strict checks on the range of values."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TimeDurationValueCalculator {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_TimeDurationValueCalculator() {
            assert_eq!(
                ::std::mem::size_of::<TimeDurationValueCalculator>(),
                1usize,
                concat!("Size of: ", stringify!(TimeDurationValueCalculator))
            );
            assert_eq!(
                ::std::mem::align_of::<TimeDurationValueCalculator>(),
                1usize,
                concat!("Alignment of ", stringify!(TimeDurationValueCalculator))
            );
        }
        #[doc = " Specialization of BaseTimeDuration that uses TimeDurationValueCalculator for"]
        #[doc = " arithmetic on the mValue member."]
        #[doc = ""]
        #[doc = " Use this class for time durations that are *not* expected to hold values of"]
        #[doc = " Forever (or the negative equivalent) or when such time duration are *not*"]
        #[doc = " expected to be used in arithmetic operations."]
        pub type TimeDuration = root::mozilla::BaseTimeDuration;
        #[doc = " Instances of this class represent moments in time, or a special"]
        #[doc = " \"null\" moment. We do not use the non-monotonic system clock or"]
        #[doc = " local time, since they can be reset, causing apparent backward"]
        #[doc = " travel in time, which can confuse algorithms. Instead we measure"]
        #[doc = " elapsed time according to the system.  This time can never go"]
        #[doc = " backwards (i.e. it never wraps around, at least not in less than"]
        #[doc = " five million years of system elapsed time). It might not advance"]
        #[doc = " while the system is sleeping. If TimeStamp::SetNow() is not called"]
        #[doc = " at all for hours or days, we might not notice the passage of some"]
        #[doc = " of that time."]
        #[doc = ""]
        #[doc = " We deliberately do not expose a way to convert TimeStamps to some"]
        #[doc = " particular unit. All you can do is compute a difference between two"]
        #[doc = " TimeStamps to get a TimeDuration. You can also add a TimeDuration"]
        #[doc = " to a TimeStamp to get a new TimeStamp. You can't do something"]
        #[doc = " meaningless like add two TimeStamps."]
        #[doc = ""]
        #[doc = " Internally this is implemented as either a wrapper around"]
        #[doc = "   - high-resolution, monotonic, system clocks if they exist on this"]
        #[doc = "     platform"]
        #[doc = "   - PRIntervalTime otherwise.  We detect wraparounds of"]
        #[doc = "     PRIntervalTime and work around them."]
        #[doc = ""]
        #[doc = " This class is similar to C++11's time_point, however it is"]
        #[doc = " explicitly nullable and provides an IsNull() method. time_point"]
        #[doc = " is initialized to the clock's epoch and provides a"]
        #[doc = " time_since_epoch() method that functions similiarly. i.e."]
        #[doc = " t.IsNull() is equivalent to t.time_since_epoch() =="]
        #[doc = " decltype(t)::duration::zero();"]
        #[doc = ""]
        #[doc = " Note that, since TimeStamp objects are small, prefer to pass them by value"]
        #[doc = " unless there is a specific reason not to do so."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TimeStamp {
            #[doc = " When built with PRIntervalTime, a value of 0 means this instance"]
            #[doc = " is \"null\". Otherwise, the low 32 bits represent a PRIntervalTime,"]
            #[doc = " and the high 32 bits represent a counter of the number of"]
            #[doc = " rollovers of PRIntervalTime that we've seen. This counter starts"]
            #[doc = " at 1 to avoid a real time colliding with the \"null\" value."]
            #[doc = ""]
            #[doc = " PR_INTERVAL_MAX is set at 100,000 ticks per second. So the minimum"]
            #[doc = " time to wrap around is about 2^64/100000 seconds, i.e. about"]
            #[doc = " 5,849,424 years."]
            #[doc = ""]
            #[doc = " When using a system clock, a value is system dependent."]
            pub mValue: root::mozilla::TimeStampValue,
        }
        #[test]
        fn bindgen_test_layout_TimeStamp() {
            assert_eq!(
                ::std::mem::size_of::<TimeStamp>(),
                8usize,
                concat!("Size of: ", stringify!(TimeStamp))
            );
            assert_eq!(
                ::std::mem::align_of::<TimeStamp>(),
                8usize,
                concat!("Alignment of ", stringify!(TimeStamp))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TimeStamp>())).mValue as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TimeStamp),
                    "::",
                    stringify!(mValue)
                )
            );
        }
        pub type Vector_Impl = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Vector_CapacityAndReserved {
            pub mCapacity: usize,
        }
        pub type Vector_ElementType<T> = T;
        pub const Vector_InlineLength: root::mozilla::Vector__bindgen_ty_1 =
            Vector__bindgen_ty_1::InlineLength;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum Vector__bindgen_ty_1 {
            InlineLength = 0,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Vector_Range<T> {
            pub mCur: *mut T,
            pub mEnd: *mut T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Vector_ConstRange<T> {
            pub mCur: *const T,
            pub mEnd: *const T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ScopeExit<ExitFunction> {
            pub mExitFunction: ExitFunction,
            pub mExecuteOnDestruction: bool,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<ExitFunction>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BufferList {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BufferList_Segment {
            pub mData: *mut ::std::os::raw::c_char,
            pub mSize: usize,
            pub mCapacity: usize,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BufferList_IterImpl {
            pub mSegment: usize,
            pub mData: *mut ::std::os::raw::c_char,
            pub mDataEnd: *mut ::std::os::raw::c_char,
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsISupports {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct RefPtr<T> {
        pub mRawPtr: *mut T,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    pub type RefPtr_element_type<T> = T;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RefPtr_Proxy {
        pub _address: u8,
    }
    pub type RefPtr_Proxy_member_function = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct RefPtr_ConstRemovingRefPtrTraits {
        pub _address: u8,
    }
    pub mod js {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BaseShape {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct LazyScript {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ObjectGroup {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RegExpShared {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Shape {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Scope {
            _unused: [u8; 0],
        }
        pub mod jit {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct JitCode {
                _unused: [u8; 0],
            }
            #[repr(u16)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum InlinableNative {
                __bindgen_cannot_repr_c_on_empty_enum = 0,
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js29CurrentThreadCanAccessRuntimeEPK9JSRuntime"]
            pub fn CurrentThreadCanAccessRuntime(rt: *const root::JSRuntime) -> bool;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ThreadType {
            THREAD_TYPE_NONE = 0,
            THREAD_TYPE_MAIN = 1,
            THREAD_TYPE_WASM = 2,
            THREAD_TYPE_ION = 3,
            THREAD_TYPE_PARSE = 4,
            THREAD_TYPE_COMPRESS = 5,
            THREAD_TYPE_GCPARALLEL = 6,
            THREAD_TYPE_PROMISE_TASK = 7,
            THREAD_TYPE_ION_FREE = 8,
            THREAD_TYPE_WASM_TIER2 = 9,
            THREAD_TYPE_WORKER = 10,
            THREAD_TYPE_MAX = 11,
        }
        #[repr(C)]
        pub struct RunnableTask__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RunnableTask {
            pub vtable_: *const RunnableTask__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_RunnableTask() {
            assert_eq!(
                ::std::mem::size_of::<RunnableTask>(),
                8usize,
                concat!("Size of: ", stringify!(RunnableTask))
            );
            assert_eq!(
                ::std::mem::align_of::<RunnableTask>(),
                8usize,
                concat!("Alignment of ", stringify!(RunnableTask))
            );
        }
        pub mod oom {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AutoEnterOOMUnsafeRegion {
            pub _address: u8,
        }
        pub type AutoEnterOOMUnsafeRegion_AnnotateOOMAllocationSizeCallback =
            ::std::option::Option<unsafe extern "C" fn(arg1: usize)>;
        extern "C" {
            #[link_name = "\u{1}_ZN2js24AutoEnterOOMUnsafeRegion23annotateOOMSizeCallbackE"]
            pub static mut AutoEnterOOMUnsafeRegion_annotateOOMSizeCallback:
                root::js::AutoEnterOOMUnsafeRegion_AnnotateOOMAllocationSizeCallback;
        }
        #[test]
        fn bindgen_test_layout_AutoEnterOOMUnsafeRegion() {
            assert_eq!(
                ::std::mem::size_of::<AutoEnterOOMUnsafeRegion>(),
                1usize,
                concat!("Size of: ", stringify!(AutoEnterOOMUnsafeRegion))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoEnterOOMUnsafeRegion>(),
                1usize,
                concat!("Alignment of ", stringify!(AutoEnterOOMUnsafeRegion))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js19InitMallocAllocatorEv"]
            pub fn InitMallocAllocator();
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js23ShutDownMallocAllocatorEv"]
            pub fn ShutDownMallocAllocator();
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js34AssertJSStringBufferInCorrectArenaEPKv"]
            pub fn AssertJSStringBufferInCorrectArena(ptr: *const ::std::os::raw::c_void);
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum AllocFunction {
            Malloc = 0,
            Calloc = 1,
            Realloc = 2,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AllocPolicyBase {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_AllocPolicyBase() {
            assert_eq!(
                ::std::mem::size_of::<AllocPolicyBase>(),
                1usize,
                concat!("Size of: ", stringify!(AllocPolicyBase))
            );
            assert_eq!(
                ::std::mem::align_of::<AllocPolicyBase>(),
                1usize,
                concat!("Alignment of ", stringify!(AllocPolicyBase))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SystemAllocPolicy {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_SystemAllocPolicy() {
            assert_eq!(
                ::std::mem::size_of::<SystemAllocPolicy>(),
                1usize,
                concat!("Size of: ", stringify!(SystemAllocPolicy))
            );
            assert_eq!(
                ::std::mem::align_of::<SystemAllocPolicy>(),
                1usize,
                concat!("Alignment of ", stringify!(SystemAllocPolicy))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js17ReportOutOfMemoryEP9JSContext"]
            pub fn ReportOutOfMemory(cx: *mut root::JSContext);
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TempAllocPolicy {
            pub cx_: *mut root::JSContext,
        }
        #[test]
        fn bindgen_test_layout_TempAllocPolicy() {
            assert_eq!(
                ::std::mem::size_of::<TempAllocPolicy>(),
                8usize,
                concat!("Size of: ", stringify!(TempAllocPolicy))
            );
            assert_eq!(
                ::std::mem::align_of::<TempAllocPolicy>(),
                8usize,
                concat!("Alignment of ", stringify!(TempAllocPolicy))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TempAllocPolicy>())).cx_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TempAllocPolicy),
                    "::",
                    stringify!(cx_)
                )
            );
        }
        pub type HashNumber = root::mozilla::HashNumber;
        pub type DefaultHasher = root::mozilla::DefaultHasher;
        pub type PointerHasher = root::mozilla::PointerHasher;
        pub type HashSet = u8;
        pub type HashMap = u8;
        extern "C" {
            #[link_name = "\u{1}_ZN2js26CurrentThreadCanAccessZoneEPN2JS4ZoneE"]
            pub fn CurrentThreadCanAccessZone(zone: *mut root::JS::Zone) -> bool;
        }
        pub mod gc {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Cell {
                _unused: [u8; 0],
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum ColorBit {
                BlackBit = 0,
                GrayOrBlackBit = 1,
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum ChunkLocation {
                Invalid = 0,
                Nursery = 1,
                TenuredHeap = 2,
            }
            pub mod detail {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                extern "C" {
                    #[link_name = "\u{1}_ZN2js2gc6detail23CellIsMarkedGrayIfKnownEPKNS0_4CellE"]
                    pub fn CellIsMarkedGrayIfKnown(cell: *const root::js::gc::Cell) -> bool;
                }
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc29PerformIncrementalReadBarrierEN2JS9GCCellPtrE"]
                pub fn PerformIncrementalReadBarrier(thing: root::JS::GCCellPtr);
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc10TraceRealmEP8JSTracerPN2JS5RealmEPKc"]
                pub fn TraceRealm(
                    trc: *mut root::JSTracer,
                    realm: *mut root::JS::Realm,
                    name: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc15RealmNeedsSweepEPN2JS5RealmE"]
                pub fn RealmNeedsSweep(realm: *mut root::JS::Realm) -> bool;
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct PersistentRootedMarker {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct GCRuntime {
                _unused: [u8; 0],
            }
            extern "C" {
                #[doc = " Create an object providing access to the garbage collector's internal notion"]
                #[doc = " of the current state of memory (both GC heap memory and GCthing-controlled"]
                #[doc = " malloc memory."]
                #[link_name = "\u{1}_ZN2js2gc19NewMemoryInfoObjectEP9JSContext"]
                pub fn NewMemoryInfoObject(cx: *mut root::JSContext) -> *mut root::JSObject;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc25FinalizeDeadNurseryObjectEP9JSContextP8JSObject"]
                pub fn FinalizeDeadNurseryObject(
                    cx: *mut root::JSContext,
                    obj: *mut root::JSObject,
                );
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BarrieredBase {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ProfilingStackFrame {
            pub label_: u64,
            pub dynamicString_: u64,
            pub spOrScript: u64,
            pub pcOffsetIfJS_: u32,
            pub realmID_: u64,
            pub flagsAndCategoryPair_: u32,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ProfilingStackFrame_Flags {
            IS_LABEL_FRAME = 1,
            IS_SP_MARKER_FRAME = 2,
            IS_JS_FRAME = 4,
            JS_OSR = 8,
            STRING_TEMPLATE_METHOD = 16,
            STRING_TEMPLATE_GETTER = 32,
            STRING_TEMPLATE_SETTER = 64,
            RELEVANT_FOR_JS = 128,
            LABEL_DETERMINED_BY_CATEGORY_PAIR = 256,
            NONSENSITIVE = 512,
            FLAGS_BITCOUNT = 10,
            FLAGS_MASK = 1023,
        }
        pub const ProfilingStackFrame_NullPCOffset: i32 = -1;
        #[test]
        fn bindgen_test_layout_ProfilingStackFrame() {
            assert_eq!(
                ::std::mem::size_of::<ProfilingStackFrame>(),
                48usize,
                concat!("Size of: ", stringify!(ProfilingStackFrame))
            );
            assert_eq!(
                ::std::mem::align_of::<ProfilingStackFrame>(),
                8usize,
                concat!("Alignment of ", stringify!(ProfilingStackFrame))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ProfilingStackFrame>())).label_ as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ProfilingStackFrame),
                    "::",
                    stringify!(label_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ProfilingStackFrame>())).dynamicString_ as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ProfilingStackFrame),
                    "::",
                    stringify!(dynamicString_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ProfilingStackFrame>())).spOrScript as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ProfilingStackFrame),
                    "::",
                    stringify!(spOrScript)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ProfilingStackFrame>())).pcOffsetIfJS_ as *const _
                        as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ProfilingStackFrame),
                    "::",
                    stringify!(pcOffsetIfJS_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ProfilingStackFrame>())).realmID_ as *const _ as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ProfilingStackFrame),
                    "::",
                    stringify!(realmID_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ProfilingStackFrame>())).flagsAndCategoryPair_
                        as *const _ as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ProfilingStackFrame),
                    "::",
                    stringify!(flagsAndCategoryPair_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js24SetContextProfilingStackEP9JSContextP14ProfilingStack"]
            pub fn SetContextProfilingStack(
                cx: *mut root::JSContext,
                profilingStack: *mut root::ProfilingStack,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js27EnableContextProfilingStackEP9JSContextb"]
            pub fn EnableContextProfilingStack(cx: *mut root::JSContext, enabled: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js35RegisterContextProfilingEventMarkerEP9JSContextPFvPKcE"]
            pub fn RegisterContextProfilingEventMarker(
                cx: *mut root::JSContext,
                fn_: ::std::option::Option<
                    unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char),
                >,
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AutoGeckoProfilerEntry {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GeckoProfilerEntryMarker {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GeckoProfilerBaselineOSRMarker {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GeckoProfilerThread {
            pub profilingStack_: *mut root::ProfilingStack,
            pub profilingStackIfEnabled_: *mut root::ProfilingStack,
        }
        #[test]
        fn bindgen_test_layout_GeckoProfilerThread() {
            assert_eq!(
                ::std::mem::size_of::<GeckoProfilerThread>(),
                16usize,
                concat!("Size of: ", stringify!(GeckoProfilerThread))
            );
            assert_eq!(
                ::std::mem::align_of::<GeckoProfilerThread>(),
                8usize,
                concat!("Alignment of ", stringify!(GeckoProfilerThread))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GeckoProfilerThread>())).profilingStack_ as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GeckoProfilerThread),
                    "::",
                    stringify!(profilingStack_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GeckoProfilerThread>())).profilingStackIfEnabled_
                        as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GeckoProfilerThread),
                    "::",
                    stringify!(profilingStackIfEnabled_)
                )
            );
        }
        pub type UniquePtr = u8;
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct UniqueSelector {
                pub _address: u8,
            }
            pub type UniqueSelector_SingleObject = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct PtrBarrierMethodsBase {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct DefineComparisonOps {
                pub _base: root::mozilla::FalseType,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct TypeIsGCThing {
                pub _base: root::mozilla::FalseType,
            }
            #[test]
            fn __bindgen_test_layout_TypeIsGCThing_open0_Value_close0_instantiation() {
                assert_eq!(
                    ::std::mem::size_of::<root::js::detail::TypeIsGCThing>(),
                    1usize,
                    concat!(
                        "Size of template specialization: ",
                        stringify!(root::js::detail::TypeIsGCThing)
                    )
                );
                assert_eq!(
                    ::std::mem::align_of::<root::js::detail::TypeIsGCThing>(),
                    1usize,
                    concat!(
                        "Alignment of template specialization: ",
                        stringify!(root::js::detail::TypeIsGCThing)
                    )
                );
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js6detail13IdMatchesAtomEN2JS11PropertyKeyEP6JSAtom"]
                pub fn IdMatchesAtom(id: root::jsid, atom: *mut root::JSAtom) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js6detail13IdMatchesAtomEN2JS11PropertyKeyEP8JSString"]
                pub fn IdMatchesAtom1(id: root::jsid, atom: *mut root::JSString) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js6detail12IsWindowSlowEP8JSObject"]
                pub fn IsWindowSlow(obj: *mut root::JSObject) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js6detail25ToWindowProxyIfWindowSlowEP8JSObject"]
                pub fn ToWindowProxyIfWindowSlow(obj: *mut root::JSObject) -> *mut root::JSObject;
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BarrierMethods {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct WrappedPtrOperations {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MutableWrappedPtrOperations {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RootedBase {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HandleBase {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MutableHandleBase {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HeapBase {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IsHeapConstructibleType {
            pub _address: u8,
        }
        #[test]
        fn __bindgen_test_layout_IsHeapConstructibleType_open0_ptr_Symbol_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsHeapConstructibleType_open0_ptr_BigInt_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsHeapConstructibleType_open0_ptr_JSAtom_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsHeapConstructibleType_open0_ptr_JSFunction_close0_instantiation()
        {
            assert_eq!(
                ::std::mem::size_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsHeapConstructibleType_open0_ptr_JSObject_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsHeapConstructibleType_open0_ptr_JSScript_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsHeapConstructibleType_open0_ptr_JSString_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsHeapConstructibleType_open0_Value_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_IsHeapConstructibleType_open0_PropertyKey_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::js::IsHeapConstructibleType>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::js::IsHeapConstructibleType)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PersistentRootedBase {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct FakeRooted {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct FakeMutableHandle {
            pub _address: u8,
        }
        #[test]
        fn __bindgen_test_layout_BarrierMethods_open0_ptr_JSObject_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::js::BarrierMethods>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::js::BarrierMethods)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::js::BarrierMethods>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::js::BarrierMethods)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_BarrierMethods_open0_ptr_JSFunction_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::js::BarrierMethods>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::js::BarrierMethods)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::js::BarrierMethods>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::js::BarrierMethods)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_BarrierMethods_open0_ptr_JSString_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::js::BarrierMethods>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::js::BarrierMethods)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::js::BarrierMethods>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::js::BarrierMethods)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MovableCellHasher {
            pub _address: u8,
        }
        pub type MovableCellHasher_Key<T> = T;
        pub type MovableCellHasher_Lookup<T> = T;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DispatchWrapper<T> {
            pub tracer: root::js::DispatchWrapper_TraceFn<T>,
            pub storage: T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        pub type DispatchWrapper_TraceFn<T> = ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut root::JSTracer,
                arg2: *mut T,
                arg3: *const ::std::os::raw::c_char,
            ),
        >;
        #[repr(u32)]
        #[doc = " Types for a variable that either should or shouldn't be rooted, depending on"]
        #[doc = " the template parameter allowGC. Used for implementing functions that can"]
        #[doc = " operate on either rooted or unrooted data."]
        #[doc = ""]
        #[doc = " The toHandle() and toMutableHandle() functions are for calling functions"]
        #[doc = " which require handle types and are only called in the CanGC case. These"]
        #[doc = " allow the calling code to type check."]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum AllowGC {
            NoGC = 0,
            CanGC = 1,
        }
        pub mod gcstats {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Statistics {
                _unused: [u8; 0],
            }
        }
        #[test]
        fn __bindgen_test_layout_BarrierMethods_open0_Value_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::js::BarrierMethods>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::js::BarrierMethods)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::js::BarrierMethods>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::js::BarrierMethods)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MutableValueOperations {
            pub _address: u8,
        }
        #[test]
        fn __bindgen_test_layout_BarrierMethods_open0_PropertyKey_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::js::BarrierMethods>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::js::BarrierMethods)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::js::BarrierMethods>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::js::BarrierMethods)
                )
            );
        }
        pub type LookupPropertyOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                objp: root::JS::MutableHandleObject,
                propp: root::JS::MutableHandle<root::JS::PropertyResult>,
            ) -> bool,
        >;
        pub type DefinePropertyOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                desc: root::JS::Handle<root::JS::PropertyDescriptor>,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool,
        >;
        pub type HasPropertyOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                foundp: *mut bool,
            ) -> bool,
        >;
        pub type GetPropertyOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                receiver: root::JS::HandleValue,
                id: root::JS::HandleId,
                vp: root::JS::MutableHandleValue,
            ) -> bool,
        >;
        pub type SetPropertyOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                v: root::JS::HandleValue,
                receiver: root::JS::HandleValue,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool,
        >;
        pub type GetOwnPropertyOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
            ) -> bool,
        >;
        pub type DeletePropertyOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool,
        >;
        #[repr(C)]
        pub struct ElementAdder {
            pub resObj_: root::JS::RootedObject,
            pub vp_: *mut root::JS::Value,
            pub index_: u32,
            pub getBehavior_: root::js::ElementAdder_GetBehavior,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ElementAdder_GetBehavior {
            CheckHasElemPreserveHoles = 0,
            GetElement = 1,
        }
        #[test]
        fn bindgen_test_layout_ElementAdder() {
            assert_eq!(
                ::std::mem::size_of::<ElementAdder>(),
                40usize,
                concat!("Size of: ", stringify!(ElementAdder))
            );
            assert_eq!(
                ::std::mem::align_of::<ElementAdder>(),
                8usize,
                concat!("Alignment of ", stringify!(ElementAdder))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ElementAdder>())).resObj_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ElementAdder),
                    "::",
                    stringify!(resObj_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ElementAdder>())).vp_ as *const _ as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ElementAdder),
                    "::",
                    stringify!(vp_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ElementAdder>())).index_ as *const _ as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ElementAdder),
                    "::",
                    stringify!(index_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ElementAdder>())).getBehavior_ as *const _ as usize
                },
                36usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ElementAdder),
                    "::",
                    stringify!(getBehavior_)
                )
            );
        }
        pub type GetElementsOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                begin: u32,
                end: u32,
                adder: *mut root::js::ElementAdder,
            ) -> bool,
        >;
        #[doc = " Callback for the creation of constructor and prototype objects."]
        pub type ClassObjectCreationOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                key: root::JSProtoKey,
            ) -> *mut root::JSObject,
        >;
        #[doc = " Callback for custom post-processing after class initialization via"]
        #[doc = " ClassSpec."]
        pub type FinishClassInitOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                ctor: root::JS::HandleObject,
                proto: root::JS::HandleObject,
            ) -> bool,
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ClassSpec {
            pub createConstructor: root::js::ClassObjectCreationOp,
            pub createPrototype: root::js::ClassObjectCreationOp,
            pub constructorFunctions: *const root::JSFunctionSpec,
            pub constructorProperties: *const root::JSPropertySpec,
            pub prototypeFunctions: *const root::JSFunctionSpec,
            pub prototypeProperties: *const root::JSPropertySpec,
            pub finishInit: root::js::FinishClassInitOp,
            pub flags: usize,
        }
        pub const ClassSpec_ProtoKeyWidth: usize = 7;
        pub const ClassSpec_ProtoKeyMask: usize = 127;
        pub const ClassSpec_DontDefineConstructor: usize = 128;
        #[test]
        fn bindgen_test_layout_ClassSpec() {
            assert_eq!(
                ::std::mem::size_of::<ClassSpec>(),
                64usize,
                concat!("Size of: ", stringify!(ClassSpec))
            );
            assert_eq!(
                ::std::mem::align_of::<ClassSpec>(),
                8usize,
                concat!("Alignment of ", stringify!(ClassSpec))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ClassSpec>())).createConstructor as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassSpec),
                    "::",
                    stringify!(createConstructor)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ClassSpec>())).createPrototype as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassSpec),
                    "::",
                    stringify!(createPrototype)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ClassSpec>())).constructorFunctions as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassSpec),
                    "::",
                    stringify!(constructorFunctions)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ClassSpec>())).constructorProperties as *const _ as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassSpec),
                    "::",
                    stringify!(constructorProperties)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ClassSpec>())).prototypeFunctions as *const _ as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassSpec),
                    "::",
                    stringify!(prototypeFunctions)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ClassSpec>())).prototypeProperties as *const _ as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassSpec),
                    "::",
                    stringify!(prototypeProperties)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ClassSpec>())).finishInit as *const _ as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassSpec),
                    "::",
                    stringify!(finishInit)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ClassSpec>())).flags as *const _ as usize },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassSpec),
                    "::",
                    stringify!(flags)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ClassExtension {
            #[doc = " Optional hook called when an object is moved by generational or"]
            #[doc = " compacting GC."]
            #[doc = ""]
            #[doc = " There may exist weak pointers to an object that are not traced through"]
            #[doc = " when the normal trace APIs are used, for example objects in the wrapper"]
            #[doc = " cache. This hook allows these pointers to be updated."]
            #[doc = ""]
            #[doc = " Note that this hook can be called before JS_NewObject() returns if a GC"]
            #[doc = " is triggered during construction of the object. This can happen for"]
            #[doc = " global objects for example."]
            #[doc = ""]
            #[doc = " The function should return the difference between nursery bytes used and"]
            #[doc = " tenured bytes used, which may be nonzero e.g. if some nursery-allocated"]
            #[doc = " data beyond the actual GC thing is moved into malloced memory."]
            #[doc = ""]
            #[doc = " This is used to compute the nursery promotion rate."]
            pub objectMovedOp: root::JSObjectMovedOp,
        }
        #[test]
        fn bindgen_test_layout_ClassExtension() {
            assert_eq!(
                ::std::mem::size_of::<ClassExtension>(),
                8usize,
                concat!("Size of: ", stringify!(ClassExtension))
            );
            assert_eq!(
                ::std::mem::align_of::<ClassExtension>(),
                8usize,
                concat!("Alignment of ", stringify!(ClassExtension))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ClassExtension>())).objectMovedOp as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassExtension),
                    "::",
                    stringify!(objectMovedOp)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ObjectOps {
            pub lookupProperty: root::js::LookupPropertyOp,
            pub defineProperty: root::js::DefinePropertyOp,
            pub hasProperty: root::js::HasPropertyOp,
            pub getProperty: root::js::GetPropertyOp,
            pub setProperty: root::js::SetPropertyOp,
            pub getOwnPropertyDescriptor: root::js::GetOwnPropertyOp,
            pub deleteProperty: root::js::DeletePropertyOp,
            pub getElements: root::js::GetElementsOp,
            pub funToString: root::JSFunToStringOp,
        }
        #[test]
        fn bindgen_test_layout_ObjectOps() {
            assert_eq!(
                ::std::mem::size_of::<ObjectOps>(),
                72usize,
                concat!("Size of: ", stringify!(ObjectOps))
            );
            assert_eq!(
                ::std::mem::align_of::<ObjectOps>(),
                8usize,
                concat!("Alignment of ", stringify!(ObjectOps))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ObjectOps>())).lookupProperty as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ObjectOps),
                    "::",
                    stringify!(lookupProperty)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ObjectOps>())).defineProperty as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ObjectOps),
                    "::",
                    stringify!(defineProperty)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ObjectOps>())).hasProperty as *const _ as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ObjectOps),
                    "::",
                    stringify!(hasProperty)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ObjectOps>())).getProperty as *const _ as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ObjectOps),
                    "::",
                    stringify!(getProperty)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ObjectOps>())).setProperty as *const _ as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ObjectOps),
                    "::",
                    stringify!(setProperty)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ObjectOps>())).getOwnPropertyDescriptor as *const _
                        as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ObjectOps),
                    "::",
                    stringify!(getOwnPropertyDescriptor)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ObjectOps>())).deleteProperty as *const _ as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ObjectOps),
                    "::",
                    stringify!(deleteProperty)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ObjectOps>())).getElements as *const _ as usize },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ObjectOps),
                    "::",
                    stringify!(getElements)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ObjectOps>())).funToString as *const _ as usize },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ObjectOps),
                    "::",
                    stringify!(funToString)
                )
            );
        }
        #[repr(i32)]
        #[doc = " Enumeration describing possible values of the [[Class]] internal property"]
        #[doc = " value of objects."]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ESClass {
            Object = 0,
            Array = 1,
            Number = 2,
            String = 3,
            Boolean = 4,
            RegExp = 5,
            ArrayBuffer = 6,
            SharedArrayBuffer = 7,
            Date = 8,
            Set = 9,
            Map = 10,
            Promise = 11,
            MapIterator = 12,
            SetIterator = 13,
            Arguments = 14,
            Error = 15,
            BigInt = 16,
            #[doc = " None of the above."]
            Other = 17,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js5UnboxEP9JSContextN2JS6HandleIP8JSObjectEENS2_13MutableHandleINS2_5ValueEEE"]
            pub fn Unbox(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                vp: root::JS::MutableHandleValue,
            ) -> bool;
        }
        pub type Vector = u8;
        #[repr(C)]
        #[derive(Debug)]
        pub struct RefCounted {
            pub mRefCnt: root::MozRefCountType,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AtomicRefCounted {
            pub mRefCnt: u64,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js16AssertHeapIsIdleEv"]
            pub fn AssertHeapIsIdle();
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ScriptSource {
            _unused: [u8; 0],
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StackFormat {
            SpiderMonkey = 0,
            V8 = 1,
            Default = 2,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js14SetStackFormatEP9JSContextNS_11StackFormatE"]
            pub fn SetStackFormat(cx: *mut root::JSContext, format: root::js::StackFormat);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js14GetStackFormatEP9JSContext"]
            pub fn GetStackFormat(cx: *mut root::JSContext) -> root::js::StackFormat;
        }
        extern "C" {
            #[doc = " Hint that we expect a crash. Currently, the only thing that cares is the"]
            #[doc = " breakpad injector, which (if loaded) will suppress minidump generation."]
            #[link_name = "\u{1}_ZN2js20NoteIntentionalCrashEv"]
            pub fn NoteIntentionalCrash();
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum CompletionKind {
            Normal = 0,
            Return = 1,
            Throw = 2,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BaseProxyHandler {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct InterpreterFrame {
            _unused: [u8; 0],
        }
        extern "C" {
            #[doc = " Get the script private value associated with an object, if any."]
            #[doc = ""]
            #[doc = " The private value is set with SetScriptPrivate() or SetModulePrivate() and is"]
            #[doc = " internally stored on the relevant ScriptSourceObject."]
            #[doc = ""]
            #[doc = " This is used by the cycle collector to trace through"]
            #[doc = " ScriptSourceObjects. This allows private values to contain an nsISupports"]
            #[doc = " pointer and hence support references to cycle collected C++ objects."]
            #[link_name = "\u{1}_ZN2js21MaybeGetScriptPrivateEP8JSObject"]
            pub fn MaybeGetScriptPrivate(object: *mut root::JSObject) -> root::JS::Value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js31AssertCompartmentHasSingleRealmEPN2JS11CompartmentE"]
            pub fn AssertCompartmentHasSingleRealm(comp: *mut root::JS::Compartment);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js14GetScriptRealmEP8JSScript"]
            pub fn GetScriptRealm(script: *mut root::JSScript) -> *mut root::JS::Realm;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js15GetBuiltinClassEP9JSContextN2JS6HandleIP8JSObjectEEPNS_7ESClassE"]
            pub fn GetBuiltinClass(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                cls: *mut root::js::ESClass,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js17IsArgumentsObjectEN2JS6HandleIP8JSObjectEE"]
            pub fn IsArgumentsObject(obj: root::JS::HandleObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js15ObjectClassNameEP9JSContextN2JS6HandleIP8JSObjectEE"]
            pub fn ObjectClassName(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
            ) -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js18ReportOverRecursedEP9JSContext"]
            pub fn ReportOverRecursed(maybecx: *mut root::JSContext);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js15AddRawValueRootEP9JSContextPN2JS5ValueEPKc"]
            pub fn AddRawValueRoot(
                cx: *mut root::JSContext,
                vp: *mut root::JS::Value,
                name: *const ::std::os::raw::c_char,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js18RemoveRawValueRootEP9JSContextPN2JS5ValueE"]
            pub fn RemoveRawValueRoot(cx: *mut root::JSContext, vp: *mut root::JS::Value);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js21GetPropertyNameFromPCEP8JSScriptPh"]
            pub fn GetPropertyNameFromPC(
                script: *mut root::JSScript,
                pc: *mut root::jsbytecode,
            ) -> *mut root::JSAtom;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js10DumpStringEP8JSStringP8_IO_FILE"]
            pub fn DumpString(str: *mut root::JSString, fp: *mut root::FILE);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js8DumpAtomEP6JSAtomP8_IO_FILE"]
            pub fn DumpAtom(atom: *mut root::JSAtom, fp: *mut root::FILE);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js10DumpObjectEP8JSObjectP8_IO_FILE"]
            pub fn DumpObject(obj: *mut root::JSObject, fp: *mut root::FILE);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js9DumpCharsEPKDsmP8_IO_FILE"]
            pub fn DumpChars(s: *const u16, n: usize, fp: *mut root::FILE);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js9DumpValueERKN2JS5ValueEP8_IO_FILE"]
            pub fn DumpValue(val: *const root::JS::Value, fp: *mut root::FILE);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js6DumpIdEN2JS11PropertyKeyEP8_IO_FILE"]
            pub fn DumpId(id: root::jsid, fp: *mut root::FILE);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js20DumpInterpreterFrameEP9JSContextP8_IO_FILEPNS_16InterpreterFrameE"]
            pub fn DumpInterpreterFrame(
                cx: *mut root::JSContext,
                fp: *mut root::FILE,
                start: *mut root::js::InterpreterFrame,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js6DumpPCEP9JSContextP8_IO_FILE"]
            pub fn DumpPC(cx: *mut root::JSContext, fp: *mut root::FILE) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js10DumpScriptEP9JSContextP8JSScriptP8_IO_FILE"]
            pub fn DumpScript(
                cx: *mut root::JSContext,
                scriptArg: *mut root::JSScript,
                fp: *mut root::FILE,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js10DumpStringEP8JSString"]
            pub fn DumpString1(str: *mut root::JSString);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js8DumpAtomEP6JSAtom"]
            pub fn DumpAtom1(atom: *mut root::JSAtom);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js10DumpObjectEP8JSObject"]
            pub fn DumpObject1(obj: *mut root::JSObject);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js9DumpCharsEPKDsm"]
            pub fn DumpChars1(s: *const u16, n: usize);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js9DumpValueERKN2JS5ValueE"]
            pub fn DumpValue1(val: *const root::JS::Value);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js6DumpIdEN2JS11PropertyKeyE"]
            pub fn DumpId1(id: root::jsid);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js20DumpInterpreterFrameEP9JSContextPNS_16InterpreterFrameE"]
            pub fn DumpInterpreterFrame1(
                cx: *mut root::JSContext,
                start: *mut root::js::InterpreterFrame,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js6DumpPCEP9JSContext"]
            pub fn DumpPC1(cx: *mut root::JSContext) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js10DumpScriptEP9JSContextP8JSScript"]
            pub fn DumpScript1(cx: *mut root::JSContext, scriptArg: *mut root::JSScript) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js13DumpBacktraceEP9JSContextP8_IO_FILE"]
            pub fn DumpBacktrace(cx: *mut root::JSContext, fp: *mut root::FILE);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js13DumpBacktraceEP9JSContext"]
            pub fn DumpBacktrace1(cx: *mut root::JSContext);
        }
        extern "C" {
            #[doc = " Use the runtime's internal handling of job queues for Promise jobs."]
            #[doc = ""]
            #[doc = " Most embeddings, notably web browsers, will have their own task scheduling"]
            #[doc = " systems and need to integrate handling of Promise jobs into that, so they"]
            #[doc = " will want to manage job queues themselves. For basic embeddings such as the"]
            #[doc = " JS shell that don't have an event loop of their own, it's easier to have"]
            #[doc = " SpiderMonkey handle job queues internally."]
            #[doc = ""]
            #[doc = " Note that the embedding still has to trigger processing of job queues at"]
            #[doc = " right time(s), such as after evaluation of a script has run to completion."]
            #[link_name = "\u{1}_ZN2js20UseInternalJobQueuesEP9JSContext"]
            pub fn UseInternalJobQueues(cx: *mut root::JSContext) -> bool;
        }
        extern "C" {
            #[doc = " Enqueue |job| on the internal job queue."]
            #[doc = ""]
            #[doc = " This is useful in tests for creating situations where a call occurs with no"]
            #[doc = " other JavaScript on the stack."]
            #[link_name = "\u{1}_ZN2js10EnqueueJobEP9JSContextN2JS6HandleIP8JSObjectEE"]
            pub fn EnqueueJob(cx: *mut root::JSContext, job: root::JS::HandleObject) -> bool;
        }
        extern "C" {
            #[doc = " Instruct the runtime to stop draining the internal job queue."]
            #[doc = ""]
            #[doc = " Useful if the embedding is in the process of quitting in reaction to a"]
            #[doc = " builtin being called, or if it wants to resume executing jobs later on."]
            #[link_name = "\u{1}_ZN2js20StopDrainingJobQueueEP9JSContext"]
            pub fn StopDrainingJobQueue(cx: *mut root::JSContext);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js7RunJobsEP9JSContext"]
            pub fn RunJobs(cx: *mut root::JSContext);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js12GetRealmZoneEPN2JS5RealmE"]
            pub fn GetRealmZone(realm: *mut root::JS::Realm) -> *mut root::JS::Zone;
        }
        pub type PreserveWrapperCallback = ::std::option::Option<
            unsafe extern "C" fn(cx: *mut root::JSContext, obj: root::JS::HandleObject) -> bool,
        >;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum DumpHeapNurseryBehaviour {
            CollectNurseryBeforeDump = 0,
            IgnoreNurseryObjects = 1,
        }
        extern "C" {
            #[doc = " Dump the complete object graph of heap-allocated things."]
            #[doc = " fp is the file for the dump output."]
            #[link_name = "\u{1}_ZN2js8DumpHeapEP9JSContextP8_IO_FILENS_24DumpHeapNurseryBehaviourEPFmPKvE"]
            pub fn DumpHeap(
                cx: *mut root::JSContext,
                fp: *mut root::FILE,
                nurseryBehaviour: root::js::DumpHeapNurseryBehaviour,
                mallocSizeOf: root::mozilla::MallocSizeOf,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js13IsSystemRealmEPN2JS5RealmE"]
            pub fn IsSystemRealm(realm: *mut root::JS::Realm) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js19IsSystemCompartmentEPN2JS11CompartmentE"]
            pub fn IsSystemCompartment(comp: *mut root::JS::Compartment) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js12IsSystemZoneEPN2JS4ZoneE"]
            pub fn IsSystemZone(zone: *mut root::JS::Zone) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js11IsAtomsZoneEPN2JS4ZoneE"]
            pub fn IsAtomsZone(zone: *mut root::JS::Zone) -> bool;
        }
        #[repr(C)]
        pub struct WeakMapTracer__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct WeakMapTracer {
            pub vtable_: *const WeakMapTracer__bindgen_vtable,
            pub runtime: *mut root::JSRuntime,
        }
        #[test]
        fn bindgen_test_layout_WeakMapTracer() {
            assert_eq!(
                ::std::mem::size_of::<WeakMapTracer>(),
                16usize,
                concat!("Size of: ", stringify!(WeakMapTracer))
            );
            assert_eq!(
                ::std::mem::align_of::<WeakMapTracer>(),
                8usize,
                concat!("Alignment of ", stringify!(WeakMapTracer))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<WeakMapTracer>())).runtime as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(WeakMapTracer),
                    "::",
                    stringify!(runtime)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js13TraceWeakMapsEPNS_13WeakMapTracerE"]
            pub fn TraceWeakMaps(trc: *mut root::js::WeakMapTracer);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js18AreGCGrayBitsValidEP9JSRuntime"]
            pub fn AreGCGrayBitsValid(rt: *mut root::JSRuntime) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js21ZoneGlobalsAreAllGrayEPN2JS4ZoneE"]
            pub fn ZoneGlobalsAreAllGray(zone: *mut root::JS::Zone) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js37IsCompartmentZoneSweepingOrCompactingEPN2JS11CompartmentE"]
            pub fn IsCompartmentZoneSweepingOrCompacting(comp: *mut root::JS::Compartment) -> bool;
        }
        pub type GCThingCallback = ::std::option::Option<
            unsafe extern "C" fn(closure: *mut ::std::os::raw::c_void, thing: root::JS::GCCellPtr),
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN2js23VisitGrayWrapperTargetsEPN2JS4ZoneEPFvPvNS0_9GCCellPtrEES3_"]
            pub fn VisitGrayWrapperTargets(
                zone: *mut root::JS::Zone,
                callback: root::js::GCThingCallback,
                closure: *mut ::std::os::raw::c_void,
            );
        }
        extern "C" {
            #[doc = " Invoke cellCallback on every gray JSObject in the given zone."]
            #[link_name = "\u{1}_ZN2js18IterateGrayObjectsEPN2JS4ZoneEPFvPvNS0_9GCCellPtrEES3_"]
            pub fn IterateGrayObjects(
                zone: *mut root::JS::Zone,
                cellCallback: root::js::GCThingCallback,
                data: *mut ::std::os::raw::c_void,
            );
        }
        extern "C" {
            #[doc = " Invoke cellCallback on every gray JSObject in the given zone while cycle"]
            #[doc = " collection is in progress."]
            #[link_name = "\u{1}_ZN2js25IterateGrayObjectsUnderCCEPN2JS4ZoneEPFvPvNS0_9GCCellPtrEES3_"]
            pub fn IterateGrayObjectsUnderCC(
                zone: *mut root::JS::Zone,
                cellCallback: root::js::GCThingCallback,
                data: *mut ::std::os::raw::c_void,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js17GetAnyRealmInZoneEPN2JS4ZoneE"]
            pub fn GetAnyRealmInZone(zone: *mut root::JS::Zone) -> *mut root::JS::Realm;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js27GetFirstGlobalInCompartmentEPN2JS11CompartmentE"]
            pub fn GetFirstGlobalInCompartment(
                comp: *mut root::JS::Compartment,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js24CompartmentHasLiveGlobalEPN2JS11CompartmentE"]
            pub fn CompartmentHasLiveGlobal(comp: *mut root::JS::Compartment) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js21IsSharableCompartmentEPN2JS11CompartmentE"]
            pub fn IsSharableCompartment(comp: *mut root::JS::Compartment) -> bool;
        }
        pub mod shadow {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ObjectGroup {
                pub clasp: *const root::JSClass,
                pub proto: *mut root::JSObject,
                pub realm: *mut root::JS::Realm,
            }
            #[test]
            fn bindgen_test_layout_ObjectGroup() {
                assert_eq!(
                    ::std::mem::size_of::<ObjectGroup>(),
                    24usize,
                    concat!("Size of: ", stringify!(ObjectGroup))
                );
                assert_eq!(
                    ::std::mem::align_of::<ObjectGroup>(),
                    8usize,
                    concat!("Alignment of ", stringify!(ObjectGroup))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<ObjectGroup>())).clasp as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ObjectGroup),
                        "::",
                        stringify!(clasp)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<ObjectGroup>())).proto as *const _ as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ObjectGroup),
                        "::",
                        stringify!(proto)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<ObjectGroup>())).realm as *const _ as usize },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ObjectGroup),
                        "::",
                        stringify!(realm)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct BaseShape {
                pub clasp_: *const root::JSClass,
                pub parent: *mut root::JSObject,
            }
            #[test]
            fn bindgen_test_layout_BaseShape() {
                assert_eq!(
                    ::std::mem::size_of::<BaseShape>(),
                    16usize,
                    concat!("Size of: ", stringify!(BaseShape))
                );
                assert_eq!(
                    ::std::mem::align_of::<BaseShape>(),
                    8usize,
                    concat!("Alignment of ", stringify!(BaseShape))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<BaseShape>())).clasp_ as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BaseShape),
                        "::",
                        stringify!(clasp_)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<BaseShape>())).parent as *const _ as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BaseShape),
                        "::",
                        stringify!(parent)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Shape {
                pub base: *mut root::js::shadow::BaseShape,
                pub _1: root::jsid,
                pub immutableFlags: u32,
            }
            pub const Shape_FIXED_SLOTS_SHIFT: u32 = 24;
            pub const Shape_FIXED_SLOTS_MASK: u32 = 520093696;
            #[test]
            fn bindgen_test_layout_Shape() {
                assert_eq!(
                    ::std::mem::size_of::<Shape>(),
                    24usize,
                    concat!("Size of: ", stringify!(Shape))
                );
                assert_eq!(
                    ::std::mem::align_of::<Shape>(),
                    8usize,
                    concat!("Alignment of ", stringify!(Shape))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Shape>())).base as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Shape),
                        "::",
                        stringify!(base)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Shape>()))._1 as *const _ as usize },
                    8usize,
                    concat!("Offset of field: ", stringify!(Shape), "::", stringify!(_1))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<Shape>())).immutableFlags as *const _ as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Shape),
                        "::",
                        stringify!(immutableFlags)
                    )
                );
            }
            #[doc = " This layout is shared by all native objects. For non-native objects, the"]
            #[doc = " group may always be accessed safely, and other members may be as well,"]
            #[doc = " depending on the object's specific layout."]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Object {
                pub group: *mut root::js::shadow::ObjectGroup,
                pub shape: *mut root::js::shadow::Shape,
                pub slots: *mut root::JS::Value,
                pub _1: *mut ::std::os::raw::c_void,
            }
            pub const Object_MAX_FIXED_SLOTS: usize = 16;
            #[test]
            fn bindgen_test_layout_Object() {
                assert_eq!(
                    ::std::mem::size_of::<Object>(),
                    32usize,
                    concat!("Size of: ", stringify!(Object))
                );
                assert_eq!(
                    ::std::mem::align_of::<Object>(),
                    8usize,
                    concat!("Alignment of ", stringify!(Object))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Object>())).group as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Object),
                        "::",
                        stringify!(group)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Object>())).shape as *const _ as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Object),
                        "::",
                        stringify!(shape)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Object>())).slots as *const _ as usize },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Object),
                        "::",
                        stringify!(slots)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Object>()))._1 as *const _ as usize },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Object),
                        "::",
                        stringify!(_1)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Function {
                pub base: root::js::shadow::Object,
                pub nargs: u16,
                pub flags: u16,
                pub native: root::JSNative,
                pub jitinfo: *const root::JSJitInfo,
                pub _1: *mut ::std::os::raw::c_void,
            }
            #[test]
            fn bindgen_test_layout_Function() {
                assert_eq!(
                    ::std::mem::size_of::<Function>(),
                    64usize,
                    concat!("Size of: ", stringify!(Function))
                );
                assert_eq!(
                    ::std::mem::align_of::<Function>(),
                    8usize,
                    concat!("Alignment of ", stringify!(Function))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Function>())).base as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Function),
                        "::",
                        stringify!(base)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Function>())).nargs as *const _ as usize },
                    32usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Function),
                        "::",
                        stringify!(nargs)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Function>())).flags as *const _ as usize },
                    34usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Function),
                        "::",
                        stringify!(flags)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Function>())).native as *const _ as usize },
                    40usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Function),
                        "::",
                        stringify!(native)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Function>())).jitinfo as *const _ as usize },
                    48usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Function),
                        "::",
                        stringify!(jitinfo)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Function>()))._1 as *const _ as usize },
                    56usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Function),
                        "::",
                        stringify!(_1)
                    )
                );
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js15ProtoKeyToClassE10JSProtoKey"]
            pub fn ProtoKeyToClass(key: root::JSProtoKey) -> *const root::JSClass;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js30ShouldIgnorePropertyDefinitionEP9JSContext10JSProtoKeyN2JS11PropertyKeyE"]
            pub fn ShouldIgnorePropertyDefinition(
                cx: *mut root::JSContext,
                key: root::JSProtoKey,
                id: root::jsid,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js16IsFunctionObjectEP8JSObject"]
            pub fn IsFunctionObject(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js34UninlinedIsCrossCompartmentWrapperEPK8JSObject"]
            pub fn UninlinedIsCrossCompartmentWrapper(obj: *const root::JSObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js19GetPrototypeNoProxyEP8JSObject"]
            pub fn GetPrototypeNoProxy(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js21AssertSameCompartmentEP9JSContextP8JSObject"]
            pub fn AssertSameCompartment(cx: *mut root::JSContext, obj: *mut root::JSObject);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js21AssertSameCompartmentEP9JSContextN2JS6HandleINS2_5ValueEEE"]
            pub fn AssertSameCompartment1(cx: *mut root::JSContext, v: root::JS::HandleValue);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js23NotifyAnimationActivityEP8JSObject"]
            pub fn NotifyAnimationActivity(obj: *mut root::JSObject);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js26DefineFunctionWithReservedEP9JSContextP8JSObjectPKcPFbS1_jPN2JS5ValueEEjj"]
            pub fn DefineFunctionWithReserved(
                cx: *mut root::JSContext,
                obj: *mut root::JSObject,
                name: *const ::std::os::raw::c_char,
                call: root::JSNative,
                nargs: ::std::os::raw::c_uint,
                attrs: ::std::os::raw::c_uint,
            ) -> *mut root::JSFunction;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js23NewFunctionWithReservedEP9JSContextPFbS1_jPN2JS5ValueEEjjPKc"]
            pub fn NewFunctionWithReserved(
                cx: *mut root::JSContext,
                call: root::JSNative,
                nargs: ::std::os::raw::c_uint,
                flags: ::std::os::raw::c_uint,
                name: *const ::std::os::raw::c_char,
            ) -> *mut root::JSFunction;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js27NewFunctionByIdWithReservedEP9JSContextPFbS1_jPN2JS5ValueEEjjNS2_11PropertyKeyE"]
            pub fn NewFunctionByIdWithReserved(
                cx: *mut root::JSContext,
                native: root::JSNative,
                nargs: ::std::os::raw::c_uint,
                flags: ::std::os::raw::c_uint,
                id: root::jsid,
            ) -> *mut root::JSFunction;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js25GetFunctionNativeReservedEP8JSObjectm"]
            pub fn GetFunctionNativeReserved(
                fun: *mut root::JSObject,
                which: usize,
            ) -> *const root::JS::Value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js25SetFunctionNativeReservedEP8JSObjectmRKN2JS5ValueE"]
            pub fn SetFunctionNativeReserved(
                fun: *mut root::JSObject,
                which: usize,
                val: *const root::JS::Value,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js25FunctionHasNativeReservedEP8JSObject"]
            pub fn FunctionHasNativeReserved(fun: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js14GetObjectProtoEP9JSContextN2JS6HandleIP8JSObjectEENS2_13MutableHandleIS5_EE"]
            pub fn GetObjectProto(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                proto: root::JS::MutableHandleObject,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js18GetStaticPrototypeEP8JSObject"]
            pub fn GetStaticPrototype(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js20GetRealmOriginalEvalEP9JSContextN2JS13MutableHandleIP8JSObjectEE"]
            pub fn GetRealmOriginalEval(
                cx: *mut root::JSContext,
                eval: root::JS::MutableHandleObject,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js26SetReservedSlotWithBarrierEP8JSObjectmRKN2JS5ValueE"]
            pub fn SetReservedSlotWithBarrier(
                obj: *mut root::JSObject,
                slot: usize,
                value: *const root::JS::Value,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js17GetObjectSlotSpanEP8JSObject"]
            pub fn GetObjectSlotSpan(obj: *mut root::JSObject) -> u32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js24StringToLinearStringSlowEP9JSContextP8JSString"]
            pub fn StringToLinearStringSlow(
                cx: *mut root::JSContext,
                str: *mut root::JSString,
            ) -> *mut root::JSLinearString;
        }
        extern "C" {
            #[doc = " Add some or all property keys of obj to the id vector *props."]
            #[doc = ""]
            #[doc = " The flags parameter controls which property keys are added. Pass a"]
            #[doc = " combination of the following bits:"]
            #[doc = ""]
            #[doc = "     JSITER_OWNONLY - Don't also search the prototype chain; only consider"]
            #[doc = "       obj's own properties."]
            #[doc = ""]
            #[doc = "     JSITER_HIDDEN - Include nonenumerable properties."]
            #[doc = ""]
            #[doc = "     JSITER_SYMBOLS - Include property keys that are symbols. The default"]
            #[doc = "       behavior is to filter out symbols."]
            #[doc = ""]
            #[doc = "     JSITER_SYMBOLSONLY - Exclude non-symbol property keys."]
            #[doc = ""]
            #[doc = " This is the closest C++ API we have to `Reflect.ownKeys(obj)`, or"]
            #[doc = " equivalently, the ES6 [[OwnPropertyKeys]] internal method. Pass"]
            #[doc = " `JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS` as flags to get"]
            #[doc = " results that match the output of Reflect.ownKeys."]
            #[link_name = "\u{1}_ZN2js15GetPropertyKeysEP9JSContextN2JS6HandleIP8JSObjectEEjNS2_13MutableHandleINS2_13StackGCVectorINS2_11PropertyKeyENS_15TempAllocPolicyEEEEE"]
            pub fn GetPropertyKeys(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                flags: ::std::os::raw::c_uint,
                props: root::JS::MutableHandleIdVector,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js12AppendUniqueEP9JSContextN2JS13MutableHandleINS2_13StackGCVectorINS2_11PropertyKeyENS_15TempAllocPolicyEEEEENS2_6HandleIS7_EE"]
            pub fn AppendUnique(
                cx: *mut root::JSContext,
                base: root::JS::MutableHandleIdVector,
                others: root::JS::HandleIdVector,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Determine whether the given string is an array index in the sense of"]
            #[doc = " <https://tc39.github.io/ecma262/#array-index>."]
            #[doc = ""]
            #[doc = " If it isn't, returns false."]
            #[doc = ""]
            #[doc = " If it is, returns true and outputs the index in *indexp."]
            #[link_name = "\u{1}_ZN2js18StringIsArrayIndexEP14JSLinearStringPj"]
            pub fn StringIsArrayIndex(str: *mut root::JSLinearString, indexp: *mut u32) -> bool;
        }
        extern "C" {
            #[doc = " Overloads of StringIsArrayIndex taking (char*,length) pairs.  These"]
            #[doc = " behave the same as the JSLinearString version."]
            #[link_name = "\u{1}_ZN2js18StringIsArrayIndexEPKcjPj"]
            pub fn StringIsArrayIndex1(
                str: *const ::std::os::raw::c_char,
                length: u32,
                indexp: *mut u32,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js18StringIsArrayIndexEPKDsjPj"]
            pub fn StringIsArrayIndex2(str: *const u16, length: u32, indexp: *mut u32) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js26SetPreserveWrapperCallbackEP9JSContextPFbS1_N2JS6HandleIP8JSObjectEEE"]
            pub fn SetPreserveWrapperCallback(
                cx: *mut root::JSContext,
                callback: root::js::PreserveWrapperCallback,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js28IsObjectInContextCompartmentEP8JSObjectPK9JSContext"]
            pub fn IsObjectInContextCompartment(
                obj: *mut root::JSObject,
                cx: *const root::JSContext,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js28RunningWithTrustedPrincipalsEP9JSContext"]
            pub fn RunningWithTrustedPrincipals(cx: *mut root::JSContext) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js21StartPCCountProfilingEP9JSContext"]
            pub fn StartPCCountProfiling(cx: *mut root::JSContext);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js20StopPCCountProfilingEP9JSContext"]
            pub fn StopPCCountProfiling(cx: *mut root::JSContext);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js13PurgePCCountsEP9JSContext"]
            pub fn PurgePCCounts(cx: *mut root::JSContext);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js21GetPCCountScriptCountEP9JSContext"]
            pub fn GetPCCountScriptCount(cx: *mut root::JSContext) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js23GetPCCountScriptSummaryEP9JSContextm"]
            pub fn GetPCCountScriptSummary(
                cx: *mut root::JSContext,
                script: usize,
            ) -> *mut root::JSString;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js24GetPCCountScriptContentsEP9JSContextm"]
            pub fn GetPCCountScriptContents(
                cx: *mut root::JSContext,
                script: usize,
            ) -> *mut root::JSString;
        }
        extern "C" {
            #[doc = " Generate lcov trace file content for the current realm, and allocate a new"]
            #[doc = " buffer and return the content in it, the size of the newly allocated content"]
            #[doc = " within the buffer would be set to the length out-param. The 'All' variant"]
            #[doc = " will collect data for all realms in the runtime."]
            #[doc = ""]
            #[doc = " In case of out-of-memory, this function returns nullptr. The length"]
            #[doc = " out-param is undefined on failure."]
            #[link_name = "\u{1}_ZN2js22GetCodeCoverageSummaryEP9JSContextPm"]
            pub fn GetCodeCoverageSummary(
                cx: *mut root::JSContext,
                length: *mut usize,
            ) -> root::JS::UniqueChars;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js25GetCodeCoverageSummaryAllEP9JSContextPm"]
            pub fn GetCodeCoverageSummaryAll(
                cx: *mut root::JSContext,
                length: *mut usize,
            ) -> root::JS::UniqueChars;
        }
        pub type DOMInstanceClassHasProtoAtDepth = ::std::option::Option<
            unsafe extern "C" fn(
                instanceClass: *const root::JSClass,
                protoID: u32,
                depth: u32,
            ) -> bool,
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct JSDOMCallbacks {
            pub instanceClassMatchesProto: root::js::DOMInstanceClassHasProtoAtDepth,
        }
        #[test]
        fn bindgen_test_layout_JSDOMCallbacks() {
            assert_eq!(
                ::std::mem::size_of::<JSDOMCallbacks>(),
                8usize,
                concat!("Size of: ", stringify!(JSDOMCallbacks))
            );
            assert_eq!(
                ::std::mem::align_of::<JSDOMCallbacks>(),
                8usize,
                concat!("Alignment of ", stringify!(JSDOMCallbacks))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<JSDOMCallbacks>())).instanceClassMatchesProto as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(JSDOMCallbacks),
                    "::",
                    stringify!(instanceClassMatchesProto)
                )
            );
        }
        pub type DOMCallbacks = root::js::JSDOMCallbacks;
        extern "C" {
            #[link_name = "\u{1}_ZN2js15SetDOMCallbacksEP9JSContextPKNS_14JSDOMCallbacksE"]
            pub fn SetDOMCallbacks(
                cx: *mut root::JSContext,
                callbacks: *const root::js::DOMCallbacks,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js15GetDOMCallbacksEP9JSContext"]
            pub fn GetDOMCallbacks(cx: *mut root::JSContext) -> *const root::js::DOMCallbacks;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js19GetTestingFunctionsEP9JSContext"]
            pub fn GetTestingFunctions(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Get an error type name from a JSExnType constant."]
            #[doc = " Returns nullptr for invalid arguments and JSEXN_INTERNALERR"]
            #[link_name = "\u{1}_ZN2js16GetErrorTypeNameEP9JSContexts"]
            pub fn GetErrorTypeName(
                cx: *mut root::JSContext,
                exnType: i16,
            ) -> *mut root::JSLinearString;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js23RegExpToSharedNonInlineEP9JSContextN2JS6HandleIP8JSObjectEE"]
            pub fn RegExpToSharedNonInline(
                cx: *mut root::JSContext,
                regexp: root::JS::HandleObject,
            ) -> *mut root::js::RegExpShared;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum NukeReferencesToWindow {
            NukeWindowReferences = 0,
            DontNukeWindowReferences = 1,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum NukeReferencesFromTarget {
            NukeAllReferences = 0,
            NukeIncomingReferences = 1,
        }
        #[repr(C)]
        pub struct CompartmentFilter__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CompartmentFilter {
            pub vtable_: *const CompartmentFilter__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_CompartmentFilter() {
            assert_eq!(
                ::std::mem::size_of::<CompartmentFilter>(),
                8usize,
                concat!("Size of: ", stringify!(CompartmentFilter))
            );
            assert_eq!(
                ::std::mem::align_of::<CompartmentFilter>(),
                8usize,
                concat!("Alignment of ", stringify!(CompartmentFilter))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AllCompartments {
            pub _base: root::js::CompartmentFilter,
        }
        #[test]
        fn bindgen_test_layout_AllCompartments() {
            assert_eq!(
                ::std::mem::size_of::<AllCompartments>(),
                8usize,
                concat!("Size of: ", stringify!(AllCompartments))
            );
            assert_eq!(
                ::std::mem::align_of::<AllCompartments>(),
                8usize,
                concat!("Alignment of ", stringify!(AllCompartments))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ContentCompartmentsOnly {
            pub _base: root::js::CompartmentFilter,
        }
        #[test]
        fn bindgen_test_layout_ContentCompartmentsOnly() {
            assert_eq!(
                ::std::mem::size_of::<ContentCompartmentsOnly>(),
                8usize,
                concat!("Size of: ", stringify!(ContentCompartmentsOnly))
            );
            assert_eq!(
                ::std::mem::align_of::<ContentCompartmentsOnly>(),
                8usize,
                concat!("Alignment of ", stringify!(ContentCompartmentsOnly))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ChromeCompartmentsOnly {
            pub _base: root::js::CompartmentFilter,
        }
        #[test]
        fn bindgen_test_layout_ChromeCompartmentsOnly() {
            assert_eq!(
                ::std::mem::size_of::<ChromeCompartmentsOnly>(),
                8usize,
                concat!("Size of: ", stringify!(ChromeCompartmentsOnly))
            );
            assert_eq!(
                ::std::mem::align_of::<ChromeCompartmentsOnly>(),
                8usize,
                concat!("Alignment of ", stringify!(ChromeCompartmentsOnly))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SingleCompartment {
            pub _base: root::js::CompartmentFilter,
            pub ours: *mut root::JS::Compartment,
        }
        #[test]
        fn bindgen_test_layout_SingleCompartment() {
            assert_eq!(
                ::std::mem::size_of::<SingleCompartment>(),
                16usize,
                concat!("Size of: ", stringify!(SingleCompartment))
            );
            assert_eq!(
                ::std::mem::align_of::<SingleCompartment>(),
                8usize,
                concat!("Alignment of ", stringify!(SingleCompartment))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<SingleCompartment>())).ours as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SingleCompartment),
                    "::",
                    stringify!(ours)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js28NukeCrossCompartmentWrappersEP9JSContextRKNS_17CompartmentFilterEPN2JS5RealmENS_22NukeReferencesToWindowENS_24NukeReferencesFromTargetE"]
            pub fn NukeCrossCompartmentWrappers(
                cx: *mut root::JSContext,
                sourceFilter: *const root::js::CompartmentFilter,
                target: *mut root::JS::Realm,
                nukeReferencesToWindow: root::js::NukeReferencesToWindow,
                nukeReferencesFromTarget: root::js::NukeReferencesFromTarget,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js15AllowNewWrapperEPN2JS11CompartmentEP8JSObject"]
            pub fn AllowNewWrapper(
                target: *mut root::JS::Compartment,
                obj: *mut root::JSObject,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js16NukedObjectRealmEP8JSObject"]
            pub fn NukedObjectRealm(obj: *mut root::JSObject) -> bool;
        }
        #[repr(C)]
        pub struct ExpandoAndGeneration {
            pub expando: root::JS::Heap<root::JS::Value>,
            pub generation: u64,
        }
        #[test]
        fn bindgen_test_layout_ExpandoAndGeneration() {
            assert_eq!(
                ::std::mem::size_of::<ExpandoAndGeneration>(),
                16usize,
                concat!("Size of: ", stringify!(ExpandoAndGeneration))
            );
            assert_eq!(
                ::std::mem::align_of::<ExpandoAndGeneration>(),
                8usize,
                concat!("Alignment of ", stringify!(ExpandoAndGeneration))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ExpandoAndGeneration>())).expando as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExpandoAndGeneration),
                    "::",
                    stringify!(expando)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ExpandoAndGeneration>())).generation as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ExpandoAndGeneration),
                    "::",
                    stringify!(generation)
                )
            );
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum DOMProxyShadowsResult {
            ShadowCheckFailed = 0,
            Shadows = 1,
            DoesntShadow = 2,
            DoesntShadowUnique = 3,
            ShadowsViaDirectExpando = 4,
            ShadowsViaIndirectExpando = 5,
        }
        pub type DOMProxyShadowsCheck = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                object: root::JS::HandleObject,
                id: root::JS::HandleId,
            ) -> root::js::DOMProxyShadowsResult,
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN2js22SetDOMProxyInformationEPKvPFNS_21DOMProxyShadowsResultEP9JSContextN2JS6HandleIP8JSObjectEENS6_INS5_11PropertyKeyEEEES1_"]
            pub fn SetDOMProxyInformation(
                domProxyHandlerFamily: *const ::std::os::raw::c_void,
                domProxyShadowsCheck: root::js::DOMProxyShadowsCheck,
                domRemoteProxyHandlerFamily: *const ::std::os::raw::c_void,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js24GetDOMProxyHandlerFamilyEv"]
            pub fn GetDOMProxyHandlerFamily() -> *const ::std::os::raw::c_void;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js23GetDOMProxyShadowsCheckEv"]
            pub fn GetDOMProxyShadowsCheck() -> root::js::DOMProxyShadowsCheck;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js30GetDOMRemoteProxyHandlerFamilyEv"]
            pub fn GetDOMRemoteProxyHandlerFamily() -> *const ::std::os::raw::c_void;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js22IsDOMRemoteProxyObjectEP8JSObject"]
            pub fn IsDOMRemoteProxyObject(object: *mut root::JSObject) -> bool;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct XrayJitInfo {
            pub isCrossCompartmentXray: ::std::option::Option<
                unsafe extern "C" fn(handler: *const root::js::BaseProxyHandler) -> bool,
            >,
            pub compartmentHasExclusiveExpandos:
                ::std::option::Option<unsafe extern "C" fn(obj: *mut root::JSObject) -> bool>,
            pub xrayHolderSlot: usize,
            pub holderExpandoSlot: usize,
            pub expandoProtoSlot: usize,
        }
        #[test]
        fn bindgen_test_layout_XrayJitInfo() {
            assert_eq!(
                ::std::mem::size_of::<XrayJitInfo>(),
                40usize,
                concat!("Size of: ", stringify!(XrayJitInfo))
            );
            assert_eq!(
                ::std::mem::align_of::<XrayJitInfo>(),
                8usize,
                concat!("Alignment of ", stringify!(XrayJitInfo))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<XrayJitInfo>())).isCrossCompartmentXray as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(XrayJitInfo),
                    "::",
                    stringify!(isCrossCompartmentXray)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<XrayJitInfo>())).compartmentHasExclusiveExpandos
                        as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(XrayJitInfo),
                    "::",
                    stringify!(compartmentHasExclusiveExpandos)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<XrayJitInfo>())).xrayHolderSlot as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(XrayJitInfo),
                    "::",
                    stringify!(xrayHolderSlot)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<XrayJitInfo>())).holderExpandoSlot as *const _ as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(XrayJitInfo),
                    "::",
                    stringify!(holderExpandoSlot)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<XrayJitInfo>())).expandoProtoSlot as *const _ as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(XrayJitInfo),
                    "::",
                    stringify!(expandoProtoSlot)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js14SetXrayJitInfoEPNS_11XrayJitInfoE"]
            pub fn SetXrayJitInfo(info: *mut root::js::XrayJitInfo);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js14GetXrayJitInfoEv"]
            pub fn GetXrayJitInfo() -> *mut root::js::XrayJitInfo;
        }
        extern "C" {
            #[doc = " Detect whether the internal date value is NaN."]
            #[link_name = "\u{1}_ZN2js11DateIsValidEP9JSContextN2JS6HandleIP8JSObjectEEPb"]
            pub fn DateIsValid(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                isValid: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js21DateGetMsecSinceEpochEP9JSContextN2JS6HandleIP8JSObjectEEPd"]
            pub fn DateGetMsecSinceEpoch(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                msecSinceEpoch: *mut f64,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js15GetErrorMessageEPvj"]
            pub fn GetErrorMessage(
                userRef: *mut ::std::os::raw::c_void,
                errorNumber: ::std::os::raw::c_uint,
            ) -> *const root::JSErrorFormatString;
        }
        #[repr(C)]
        pub struct ErrorReport {
            pub reportp: *mut root::JSErrorReport,
            pub ownedReport: root::JSErrorReport,
            pub exnObject: root::JS::RootedObject,
            pub filename: root::JS::UniqueChars,
            pub toStringResult_: root::JS::ConstUTF8CharsZ,
            pub toStringResultBytesStorage: root::JS::UniqueChars,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ErrorReport_SniffingBehavior {
            WithSideEffects = 0,
            NoSideEffects = 1,
        }
        #[test]
        fn bindgen_test_layout_ErrorReport() {
            assert_eq!(
                ::std::mem::size_of::<ErrorReport>(),
                136usize,
                concat!("Size of: ", stringify!(ErrorReport))
            );
            assert_eq!(
                ::std::mem::align_of::<ErrorReport>(),
                8usize,
                concat!("Alignment of ", stringify!(ErrorReport))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ErrorReport>())).reportp as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ErrorReport),
                    "::",
                    stringify!(reportp)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ErrorReport>())).ownedReport as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ErrorReport),
                    "::",
                    stringify!(ownedReport)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ErrorReport>())).exnObject as *const _ as usize },
                88usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ErrorReport),
                    "::",
                    stringify!(exnObject)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ErrorReport>())).filename as *const _ as usize },
                112usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ErrorReport),
                    "::",
                    stringify!(filename)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ErrorReport>())).toStringResult_ as *const _ as usize
                },
                120usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ErrorReport),
                    "::",
                    stringify!(toStringResult_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ErrorReport>())).toStringResultBytesStorage as *const _
                        as usize
                },
                128usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ErrorReport),
                    "::",
                    stringify!(toStringResultBytesStorage)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js11GetSCOffsetEP23JSStructuredCloneWriter"]
            pub fn GetSCOffset(writer: *mut root::JSStructuredCloneWriter) -> u64;
        }
        pub mod Scalar {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum Type {
                Int8 = 0,
                Uint8 = 1,
                Int16 = 2,
                Uint16 = 3,
                Int32 = 4,
                Uint32 = 5,
                Float32 = 6,
                Float64 = 7,
                #[doc = " Special type that is a uint8_t, but assignments are clamped to [0, 256)."]
                #[doc = " Treat the raw data type as a uint8_t."]
                Uint8Clamped = 8,
                #[doc = " Special type that is a uint8_t, but assignments are clamped to [0, 256)."]
                #[doc = " Treat the raw data type as a uint8_t."]
                BigInt64 = 9,
                #[doc = " Special type that is a uint8_t, but assignments are clamped to [0, 256)."]
                #[doc = " Treat the raw data type as a uint8_t."]
                BigUint64 = 10,
                #[doc = " Types that don't have their own TypedArray equivalent, for now."]
                MaxTypedArrayViewType = 11,
                #[doc = " Types that don't have their own TypedArray equivalent, for now."]
                Int64 = 12,
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js15UnwrapInt8ArrayEP8JSObject"]
            pub fn UnwrapInt8Array(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js16UnwrapUint8ArrayEP8JSObject"]
            pub fn UnwrapUint8Array(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js23UnwrapUint8ClampedArrayEP8JSObject"]
            pub fn UnwrapUint8ClampedArray(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js16UnwrapInt16ArrayEP8JSObject"]
            pub fn UnwrapInt16Array(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js17UnwrapUint16ArrayEP8JSObject"]
            pub fn UnwrapUint16Array(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js16UnwrapInt32ArrayEP8JSObject"]
            pub fn UnwrapInt32Array(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js17UnwrapUint32ArrayEP8JSObject"]
            pub fn UnwrapUint32Array(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js19UnwrapBigInt64ArrayEP8JSObject"]
            pub fn UnwrapBigInt64Array(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js20UnwrapBigUint64ArrayEP8JSObject"]
            pub fn UnwrapBigUint64Array(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js18UnwrapFloat32ArrayEP8JSObject"]
            pub fn UnwrapFloat32Array(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js18UnwrapFloat64ArrayEP8JSObject"]
            pub fn UnwrapFloat64Array(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js21UnwrapArrayBufferViewEP8JSObject"]
            pub fn UnwrapArrayBufferView(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js20UnwrapReadableStreamEP8JSObject"]
            pub fn UnwrapReadableStream(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js31GetArrayBufferViewLengthAndDataEP8JSObjectPjPbPPh"]
            pub fn GetArrayBufferViewLengthAndData(
                obj: *mut root::JSObject,
                length: *mut u32,
                isSharedMemory: *mut bool,
                data: *mut *mut u8,
            );
        }
        #[repr(C)]
        pub struct ScriptEnvironmentPreparer__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " PrepareScriptEnvironmentAndInvoke asserts the embedder has registered a"]
        #[doc = " ScriptEnvironmentPreparer and then it calls the preparer's 'invoke' method"]
        #[doc = " with the given |closure|, with the assumption that the preparer will set up"]
        #[doc = " any state necessary to run script in |global|, invoke |closure| with a valid"]
        #[doc = " JSContext*, report any exceptions thrown from the closure, and return."]
        #[doc = ""]
        #[doc = " PrepareScriptEnvironmentAndInvoke will report any exceptions that are thrown"]
        #[doc = " by the closure.  Consumers who want to propagate back whether the closure"]
        #[doc = " succeeded should do so via members of the closure itself."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ScriptEnvironmentPreparer {
            pub vtable_: *const ScriptEnvironmentPreparer__bindgen_vtable,
        }
        #[repr(C)]
        pub struct ScriptEnvironmentPreparer_Closure__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ScriptEnvironmentPreparer_Closure {
            pub vtable_: *const ScriptEnvironmentPreparer_Closure__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_ScriptEnvironmentPreparer_Closure() {
            assert_eq!(
                ::std::mem::size_of::<ScriptEnvironmentPreparer_Closure>(),
                8usize,
                concat!("Size of: ", stringify!(ScriptEnvironmentPreparer_Closure))
            );
            assert_eq!(
                ::std::mem::align_of::<ScriptEnvironmentPreparer_Closure>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(ScriptEnvironmentPreparer_Closure)
                )
            );
        }
        #[test]
        fn bindgen_test_layout_ScriptEnvironmentPreparer() {
            assert_eq!(
                ::std::mem::size_of::<ScriptEnvironmentPreparer>(),
                8usize,
                concat!("Size of: ", stringify!(ScriptEnvironmentPreparer))
            );
            assert_eq!(
                ::std::mem::align_of::<ScriptEnvironmentPreparer>(),
                8usize,
                concat!("Alignment of ", stringify!(ScriptEnvironmentPreparer))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js33PrepareScriptEnvironmentAndInvokeEP9JSContextN2JS6HandleIP8JSObjectEERNS_25ScriptEnvironmentPreparer7ClosureE"]
            pub fn PrepareScriptEnvironmentAndInvoke(
                cx: *mut root::JSContext,
                global: root::JS::HandleObject,
                closure: *mut root::js::ScriptEnvironmentPreparer_Closure,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js28SetScriptEnvironmentPreparerEP9JSContextPNS_25ScriptEnvironmentPreparerE"]
            pub fn SetScriptEnvironmentPreparer(
                cx: *mut root::JSContext,
                preparer: *mut root::js::ScriptEnvironmentPreparer,
            );
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum CTypesActivityType {
            CTYPES_CALL_BEGIN = 0,
            CTYPES_CALL_END = 1,
            CTYPES_CALLBACK_BEGIN = 2,
            CTYPES_CALLBACK_END = 3,
        }
        pub type CTypesActivityCallback = ::std::option::Option<
            unsafe extern "C" fn(cx: *mut root::JSContext, type_: root::js::CTypesActivityType),
        >;
        extern "C" {
            #[doc = " Sets a callback that is run whenever js-ctypes is about to be used when"]
            #[doc = " calling into C."]
            #[link_name = "\u{1}_ZN2js25SetCTypesActivityCallbackEP9JSContextPFvS1_NS_18CTypesActivityTypeEE"]
            pub fn SetCTypesActivityCallback(
                cx: *mut root::JSContext,
                cb: root::js::CTypesActivityCallback,
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoCTypesActivityCallback {
            pub cx: *mut root::JSContext,
            pub callback: root::js::CTypesActivityCallback,
            pub endType: root::js::CTypesActivityType,
        }
        #[test]
        fn bindgen_test_layout_AutoCTypesActivityCallback() {
            assert_eq!(
                ::std::mem::size_of::<AutoCTypesActivityCallback>(),
                24usize,
                concat!("Size of: ", stringify!(AutoCTypesActivityCallback))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoCTypesActivityCallback>(),
                8usize,
                concat!("Alignment of ", stringify!(AutoCTypesActivityCallback))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AutoCTypesActivityCallback>())).cx as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoCTypesActivityCallback),
                    "::",
                    stringify!(cx)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AutoCTypesActivityCallback>())).callback as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoCTypesActivityCallback),
                    "::",
                    stringify!(callback)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AutoCTypesActivityCallback>())).endType as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoCTypesActivityCallback),
                    "::",
                    stringify!(endType)
                )
            );
        }
        #[repr(C)]
        pub struct AllocationMetadataBuilder__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AllocationMetadataBuilder {
            pub vtable_: *const AllocationMetadataBuilder__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_AllocationMetadataBuilder() {
            assert_eq!(
                ::std::mem::size_of::<AllocationMetadataBuilder>(),
                8usize,
                concat!("Size of: ", stringify!(AllocationMetadataBuilder))
            );
            assert_eq!(
                ::std::mem::align_of::<AllocationMetadataBuilder>(),
                8usize,
                concat!("Alignment of ", stringify!(AllocationMetadataBuilder))
            );
        }
        extern "C" {
            #[doc = " Specify a callback to invoke when creating each JS object in the current"]
            #[doc = " compartment, which may return a metadata object to associate with the"]
            #[doc = " object."]
            #[link_name = "\u{1}_ZN2js28SetAllocationMetadataBuilderEP9JSContextPKNS_25AllocationMetadataBuilderE"]
            pub fn SetAllocationMetadataBuilder(
                cx: *mut root::JSContext,
                callback: *const root::js::AllocationMetadataBuilder,
            );
        }
        extern "C" {
            #[doc = " Get the metadata associated with an object."]
            #[link_name = "\u{1}_ZN2js21GetAllocationMetadataEP8JSObject"]
            pub fn GetAllocationMetadata(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js20GetElementsWithAdderEP9JSContextN2JS6HandleIP8JSObjectEES6_jjPNS_12ElementAdderE"]
            pub fn GetElementsWithAdder(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                receiver: root::JS::HandleObject,
                begin: u32,
                end: u32,
                adder: *mut root::js::ElementAdder,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js15ForwardToNativeEP9JSContextPFbS1_jPN2JS5ValueEERKNS2_8CallArgsE"]
            pub fn ForwardToNative(
                cx: *mut root::JSContext,
                native: root::JSNative,
                args: *const root::JS::CallArgs,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Helper function for HTMLDocument and HTMLFormElement."]
            #[doc = ""]
            #[doc = " These are the only two interfaces that have [OverrideBuiltins], a named"]
            #[doc = " getter, and no named setter. They're implemented as proxies with a custom"]
            #[doc = " getOwnPropertyDescriptor() method. Unfortunately, overriding"]
            #[doc = " getOwnPropertyDescriptor() automatically affects the behavior of set(),"]
            #[doc = " which normally is just common sense but is *not* desired for these two"]
            #[doc = " interfaces."]
            #[doc = ""]
            #[doc = " The fix is for these two interfaces to override set() to ignore the"]
            #[doc = " getOwnPropertyDescriptor() override."]
            #[doc = ""]
            #[doc = " SetPropertyIgnoringNamedGetter is exposed to make it easier to override"]
            #[doc = " set() in this way.  It carries out all the steps of BaseProxyHandler::set()"]
            #[doc = " except the initial getOwnPropertyDescriptor() call.  The caller must supply"]
            #[doc = " that descriptor as the 'ownDesc' parameter."]
            #[doc = ""]
            #[doc = " Implemented in proxy/BaseProxyHandler.cpp."]
            #[link_name = "\u{1}_ZN2js30SetPropertyIgnoringNamedGetterEP9JSContextN2JS6HandleIP8JSObjectEENS3_INS2_11PropertyKeyEEENS3_INS2_5ValueEEESA_NS3_INS2_18PropertyDescriptorEEERNS2_14ObjectOpResultE"]
            pub fn SetPropertyIgnoringNamedGetter(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                v: root::JS::HandleValue,
                receiver: root::JS::HandleValue,
                ownDesc: root::JS::Handle<root::JS::PropertyDescriptor>,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js31ExecuteInFrameScriptEnvironmentEP9JSContextN2JS6HandleIP8JSObjectEENS3_IP8JSScriptEENS2_13MutableHandleIS5_EE"]
            pub fn ExecuteInFrameScriptEnvironment(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                script: root::JS::HandleScript,
                scope: root::JS::MutableHandleObject,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js17NewJSMEnvironmentEP9JSContext"]
            pub fn NewJSMEnvironment(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js23ExecuteInJSMEnvironmentEP9JSContextN2JS6HandleIP8JSScriptEENS3_IP8JSObjectEE"]
            pub fn ExecuteInJSMEnvironment(
                cx: *mut root::JSContext,
                script: root::JS::HandleScript,
                jsmEnv: root::JS::HandleObject,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js23ExecuteInJSMEnvironmentEP9JSContextN2JS6HandleIP8JSScriptEENS3_IP8JSObjectEENS3_INS2_13StackGCVectorIS8_NS_15TempAllocPolicyEEEEE"]
            pub fn ExecuteInJSMEnvironment1(
                cx: *mut root::JSContext,
                script: root::JS::HandleScript,
                jsmEnv: root::JS::HandleObject,
                targetObj: root::JS::HandleObjectVector,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js33GetJSMEnvironmentOfScriptedCallerEP9JSContext"]
            pub fn GetJSMEnvironmentOfScriptedCaller(
                cx: *mut root::JSContext,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js16IsJSMEnvironmentEP8JSObject"]
            pub fn IsJSMEnvironment(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js19ReportIsNotFunctionEP9JSContextN2JS6HandleINS2_5ValueEEE"]
            pub fn ReportIsNotFunction(cx: *mut root::JSContext, v: root::JS::HandleValue) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js18ConvertArgsToArrayEP9JSContextRKN2JS8CallArgsE"]
            pub fn ConvertArgsToArray(
                cx: *mut root::JSContext,
                args: *const root::JS::CallArgs,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Tell the JS engine which Class is used for WindowProxy objects. Used by the"]
            #[doc = " functions below."]
            #[link_name = "\u{1}_ZN2js19SetWindowProxyClassEP9JSContextPK7JSClass"]
            pub fn SetWindowProxyClass(cx: *mut root::JSContext, clasp: *const root::JSClass);
        }
        extern "C" {
            #[doc = " Associates a WindowProxy with a Window (global object). `windowProxy` must"]
            #[doc = " have the Class set by SetWindowProxyClass."]
            #[link_name = "\u{1}_ZN2js14SetWindowProxyEP9JSContextN2JS6HandleIP8JSObjectEES6_"]
            pub fn SetWindowProxy(
                cx: *mut root::JSContext,
                global: root::JS::HandleObject,
                windowProxy: root::JS::HandleObject,
            );
        }
        extern "C" {
            #[doc = " Returns true iff `obj` has the WindowProxy Class (see SetWindowProxyClass)."]
            #[link_name = "\u{1}_ZN2js13IsWindowProxyEP8JSObject"]
            pub fn IsWindowProxy(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[doc = " If `obj` is a WindowProxy, get its associated Window (the compartment's"]
            #[doc = " global), else return `obj`. This function is infallible and never returns"]
            #[doc = " nullptr."]
            #[link_name = "\u{1}_ZN2js21ToWindowIfWindowProxyEP8JSObject"]
            pub fn ToWindowIfWindowProxy(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js31AddMozDateTimeFormatConstructorEP9JSContextN2JS6HandleIP8JSObjectEE"]
            pub fn AddMozDateTimeFormatConstructor(
                cx: *mut root::JSContext,
                intl: root::JS::Handle<*mut root::JSObject>,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js20AddLocaleConstructorEP9JSContextN2JS6HandleIP8JSObjectEE"]
            pub fn AddLocaleConstructor(
                cx: *mut root::JSContext,
                intl: root::JS::Handle<*mut root::JSObject>,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js24AddListFormatConstructorEP9JSContextN2JS6HandleIP8JSObjectEE"]
            pub fn AddListFormatConstructor(
                cx: *mut root::JSContext,
                intl: root::JS::Handle<*mut root::JSObject>,
            ) -> bool;
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoAssertNoContentJS {
            pub context_: *mut root::JSContext,
            pub prevAllowContentJS_: bool,
        }
        #[test]
        fn bindgen_test_layout_AutoAssertNoContentJS() {
            assert_eq!(
                ::std::mem::size_of::<AutoAssertNoContentJS>(),
                16usize,
                concat!("Size of: ", stringify!(AutoAssertNoContentJS))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoAssertNoContentJS>(),
                8usize,
                concat!("Alignment of ", stringify!(AutoAssertNoContentJS))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AutoAssertNoContentJS>())).context_ as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoAssertNoContentJS),
                    "::",
                    stringify!(context_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AutoAssertNoContentJS>())).prevAllowContentJS_
                        as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoAssertNoContentJS),
                    "::",
                    stringify!(prevAllowContentJS_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js22EnableAccessValidationEP9JSContextb"]
            pub fn EnableAccessValidation(cx: *mut root::JSContext, enabled: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js22SetRealmValidAccessPtrEP9JSContextN2JS6HandleIP8JSObjectEEPb"]
            pub fn SetRealmValidAccessPtr(
                cx: *mut root::JSContext,
                global: root::JS::HandleObject,
                accessp: *mut bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js19SystemZoneAvailableEP9JSContext"]
            pub fn SystemZoneAvailable(cx: *mut root::JSContext) -> bool;
        }
        pub type LogCtorDtor = ::std::option::Option<
            unsafe extern "C" fn(
                self_: *mut ::std::os::raw::c_void,
                type_: *const ::std::os::raw::c_char,
                sz: u32,
            ),
        >;
        extern "C" {
            #[doc = " Set global function used to monitor a few internal classes to highlight"]
            #[doc = " leaks, and to hint at the origin of the leaks."]
            #[link_name = "\u{1}_ZN2js23SetLogCtorDtorFunctionsEPFvPvPKcjES4_"]
            pub fn SetLogCtorDtorFunctions(
                ctor: root::js::LogCtorDtor,
                dtor: root::js::LogCtorDtor,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js7LogCtorEPvPKcj"]
            pub fn LogCtor(
                self_: *mut ::std::os::raw::c_void,
                type_: *const ::std::os::raw::c_char,
                sz: u32,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js7LogDtorEPvPKcj"]
            pub fn LogDtor(
                self_: *mut ::std::os::raw::c_void,
                type_: *const ::std::os::raw::c_char,
                sz: u32,
            );
        }
        extern "C" {
            #[doc = " This function only reports GC heap memory,"]
            #[doc = " and not malloc allocated memory associated with GC things."]
            #[link_name = "\u{1}_ZN2js27GetGCHeapUsageForObjectZoneEP8JSObject"]
            pub fn GetGCHeapUsageForObjectZone(obj: *mut root::JSObject) -> u64;
        }
        extern "C" {
            #[doc = " Return whether a global object's realm has had instrumentation enabled by a"]
            #[doc = " Debugger."]
            #[link_name = "\u{1}_ZN2js24GlobalHasInstrumentationEP8JSObject"]
            pub fn GlobalHasInstrumentation(global: *mut root::JSObject) -> bool;
        }
        #[repr(C)]
        pub struct CompartmentTransplantCallback__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CompartmentTransplantCallback {
            pub vtable_: *const CompartmentTransplantCallback__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_CompartmentTransplantCallback() {
            assert_eq!(
                ::std::mem::size_of::<CompartmentTransplantCallback>(),
                8usize,
                concat!("Size of: ", stringify!(CompartmentTransplantCallback))
            );
            assert_eq!(
                ::std::mem::align_of::<CompartmentTransplantCallback>(),
                8usize,
                concat!("Alignment of ", stringify!(CompartmentTransplantCallback))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js24RemapRemoteWindowProxiesEP9JSContextPNS_29CompartmentTransplantCallbackEN2JS13MutableHandleIP8JSObjectEE"]
            pub fn RemapRemoteWindowProxies(
                cx: *mut root::JSContext,
                callback: *mut root::js::CompartmentTransplantCallback,
                newTarget: root::JS::MutableHandleObject,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js13ToBooleanSlowEN2JS6HandleINS0_5ValueEEE"]
            pub fn ToBooleanSlow(v: root::JS::HandleValue) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js12ToNumberSlowEP9JSContextN2JS6HandleINS2_5ValueEEEPd"]
            pub fn ToNumberSlow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                dp: *mut f64,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js10ToInt8SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPa"]
            pub fn ToInt8Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut i8,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js11ToUint8SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPh"]
            pub fn ToUint8Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut u8,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js11ToInt16SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPs"]
            pub fn ToInt16Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut i16,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js11ToInt32SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPi"]
            pub fn ToInt32Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut i32,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js12ToUint32SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPj"]
            pub fn ToUint32Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut u32,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js12ToUint16SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPt"]
            pub fn ToUint16Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut u16,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js11ToInt64SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPl"]
            pub fn ToInt64Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut i64,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js12ToUint64SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPm"]
            pub fn ToUint64Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut u64,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js12ToStringSlowEP9JSContextN2JS6HandleINS2_5ValueEEE"]
            pub fn ToStringSlow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
            ) -> *mut root::JSString;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js12ToObjectSlowEP9JSContextN2JS6HandleINS2_5ValueEEEb"]
            pub fn ToObjectSlow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                reportScanStack: bool,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " In memory reporting, we have concept of \"sundries\", line items which are too"]
            #[doc = " small to be worth reporting individually.  Under some circumstances, a memory"]
            #[doc = " reporter gets tossed into the sundries bucket if it's smaller than"]
            #[doc = " MemoryReportingSundriesThreshold() bytes."]
            #[doc = ""]
            #[doc = " We need to define this value here, rather than in the code which actually"]
            #[doc = " generates the memory reports, because NotableStringInfo uses this value."]
            #[link_name = "\u{1}_ZN2js32MemoryReportingSundriesThresholdEv"]
            pub fn MemoryReportingSundriesThreshold() -> usize;
        }
        #[doc = " This hash policy avoids flattening ropes (which perturbs the site being"]
        #[doc = " measured and requires a JSContext) at the expense of doing a FULL ROPE COPY"]
        #[doc = " on every hash and match! Beware."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct InefficientNonFlatteningStringHashPolicy {
            pub _address: u8,
        }
        pub type InefficientNonFlatteningStringHashPolicy_Lookup = *mut root::JSString;
        #[test]
        fn bindgen_test_layout_InefficientNonFlatteningStringHashPolicy() {
            assert_eq!(
                ::std::mem::size_of::<InefficientNonFlatteningStringHashPolicy>(),
                1usize,
                concat!(
                    "Size of: ",
                    stringify!(InefficientNonFlatteningStringHashPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<InefficientNonFlatteningStringHashPolicy>(),
                1usize,
                concat!(
                    "Alignment of ",
                    stringify!(InefficientNonFlatteningStringHashPolicy)
                )
            );
        }
        extern "C" {
            #[doc = " Get the first SavedFrame object in this SavedFrame stack whose principals are"]
            #[doc = " subsumed by the given |principals|. If there is no such frame, return"]
            #[doc = " nullptr."]
            #[doc = ""]
            #[doc = " Do NOT pass a non-SavedFrame object here."]
            #[link_name = "\u{1}_ZN2js26GetFirstSubsumedSavedFrameEP9JSContextP12JSPrincipalsN2JS6HandleIP8JSObjectEENS4_20SavedFrameSelfHostedE"]
            pub fn GetFirstSubsumedSavedFrame(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> *mut root::JSObject;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SharedArrayRawBuffer {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct SharedArrayRawBufferRefs {
            pub refs_: [u64; 3usize],
        }
        #[test]
        fn bindgen_test_layout_SharedArrayRawBufferRefs() {
            assert_eq!(
                ::std::mem::size_of::<SharedArrayRawBufferRefs>(),
                24usize,
                concat!("Size of: ", stringify!(SharedArrayRawBufferRefs))
            );
            assert_eq!(
                ::std::mem::align_of::<SharedArrayRawBufferRefs>(),
                8usize,
                concat!("Alignment of ", stringify!(SharedArrayRawBufferRefs))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<SharedArrayRawBufferRefs>())).refs_ as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SharedArrayRawBufferRefs),
                    "::",
                    stringify!(refs_)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BufferIterator {
            pub _address: u8,
        }
    }
    pub mod JS {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type Heap<T> = ::jsgc::Heap<T>;
        pub type Rooted<T> = ::jsgc::Rooted<T>;
        #[doc = " Type representing a JS error or exception. At the moment this only"]
        #[doc = " \"represents\" an error in a rather abstract way."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Error {
            pub dummy: ::std::os::raw::c_int,
        }
        #[test]
        fn bindgen_test_layout_Error() {
            assert_eq!(
                ::std::mem::size_of::<Error>(),
                4usize,
                concat!("Size of: ", stringify!(Error))
            );
            assert_eq!(
                ::std::mem::align_of::<Error>(),
                4usize,
                concat!("Alignment of ", stringify!(Error))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Error>())).dummy as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Error),
                    "::",
                    stringify!(dummy)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct OOM {
            pub _base: root::JS::Error,
        }
        #[test]
        fn bindgen_test_layout_OOM() {
            assert_eq!(
                ::std::mem::size_of::<OOM>(),
                4usize,
                concat!("Size of: ", stringify!(OOM))
            );
            assert_eq!(
                ::std::mem::align_of::<OOM>(),
                4usize,
                concat!("Alignment of ", stringify!(OOM))
            );
        }
        #[doc = " `Result` is intended to be the return type of JSAPI calls and internal"]
        #[doc = " functions that can run JS code or allocate memory from the JS GC heap. Such"]
        #[doc = " functions can:"]
        #[doc = ""]
        #[doc = " -   succeed, possibly returning a value;"]
        #[doc = ""]
        #[doc = " -   fail with a JS exception (out-of-memory falls in this category); or"]
        #[doc = ""]
        #[doc = " -   fail because JS execution was terminated, which occurs when e.g. a"]
        #[doc = "     user kills a script from the \"slow script\" UI. This is also how we"]
        #[doc = "     unwind the stack when the debugger forces the current function to"]
        #[doc = "     return. JS `catch` blocks can't catch this kind of failure,"]
        #[doc = "     and JS `finally` blocks don't execute."]
        pub type Result = root::mozilla::Result;
        pub type Latin1Char = ::std::os::raw::c_uchar;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Symbol {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BigInt {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Compartment {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Realm {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Runtime {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Zone {
            _unused: [u8; 0],
        }
        pub type HandleFunction = root::JS::Handle<*mut root::JSFunction>;
        pub type HandleId = root::JS::Handle<root::JS::PropertyKey>;
        pub type HandleObject = root::JS::Handle<*mut root::JSObject>;
        pub type HandleScript = root::JS::Handle<*mut root::JSScript>;
        pub type HandleString = root::JS::Handle<*mut root::JSString>;
        pub type HandleSymbol = root::JS::Handle<*mut root::JS::Symbol>;
        pub type HandleBigInt = root::JS::Handle<*mut root::JS::BigInt>;
        pub type HandleValue = root::JS::Handle<root::JS::Value>;
        pub type HandleValueVector = u8;
        pub type HandleIdVector = u8;
        pub type MutableHandleFunction = root::JS::MutableHandle<*mut root::JSFunction>;
        pub type MutableHandleId = root::JS::MutableHandle<root::JS::PropertyKey>;
        pub type MutableHandleObject = root::JS::MutableHandle<*mut root::JSObject>;
        pub type MutableHandleScript = root::JS::MutableHandle<*mut root::JSScript>;
        pub type MutableHandleString = root::JS::MutableHandle<*mut root::JSString>;
        pub type MutableHandleSymbol = root::JS::MutableHandle<*mut root::JS::Symbol>;
        pub type MutableHandleBigInt = root::JS::MutableHandle<*mut root::JS::BigInt>;
        pub type MutableHandleValue = root::JS::MutableHandle<root::JS::Value>;
        pub type MutableHandleValueVector = u8;
        pub type RootedObject = root::JS::Rooted<*mut root::JSObject>;
        pub type RootedFunction = root::JS::Rooted<*mut root::JSFunction>;
        pub type RootedScript = root::JS::Rooted<*mut root::JSScript>;
        pub type RootedString = root::JS::Rooted<*mut root::JSString>;
        pub type RootedSymbol = root::JS::Rooted<*mut root::JS::Symbol>;
        pub type RootedBigInt = root::JS::Rooted<*mut root::JS::BigInt>;
        pub type RootedId = root::JS::Rooted<root::JS::PropertyKey>;
        pub type RootedValue = root::JS::Rooted<root::JS::Value>;
        pub type PersistentRootedFunction = u8;
        pub type PersistentRootedId = u8;
        pub type PersistentRootedObject = [u64; 4usize];
        pub type PersistentRootedScript = [u64; 4usize];
        pub type PersistentRootedString = [u64; 4usize];
        pub type PersistentRootedSymbol = u8;
        pub type PersistentRootedBigInt = u8;
        pub type PersistentRootedValue = u8;
        pub type PersistentRootedIdVector = u8;
        pub type PersistentRootedObjectVector = u8;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum TraceKind {
            Object = 0,
            String = 2,
            Symbol = 3,
            Script = 1,
            Shape = 4,
            ObjectGroup = 5,
            Null = 6,
            BaseShape = 15,
            JitCode = 31,
            LazyScript = 47,
            Scope = 63,
            RegExpShared = 79,
            BigInt = 95,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MapTypeToTraceKind {
            pub _address: u8,
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToTraceKind_open0_BaseShape_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToTraceKind_open0_JitCode_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToTraceKind_open0_LazyScript_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToTraceKind_open0_Scope_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToTraceKind_open0_JSObject_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToTraceKind_open0_ObjectGroup_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToTraceKind_open0_JSScript_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToTraceKind_open0_Shape_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToTraceKind_open0_JSString_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToTraceKind_open0_Symbol_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToTraceKind_open0_BigInt_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToTraceKind_open0_RegExpShared_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToTraceKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToTraceKind)
                )
            );
        }
        #[repr(i8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum RootKind {
            BaseShape = 0,
            JitCode = 1,
            LazyScript = 2,
            Scope = 3,
            Object = 4,
            ObjectGroup = 5,
            Script = 6,
            Shape = 7,
            String = 8,
            Symbol = 9,
            BigInt = 10,
            RegExpShared = 11,
            Id = 12,
            Value = 13,
            Traceable = 14,
            Limit = 15,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MapTypeToRootKind {
            pub _address: u8,
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToRootKind_open0_ptr_Realm_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToRootKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToRootKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToRootKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToRootKind)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToRootKind_open0_Value_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToRootKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToRootKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToRootKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToRootKind)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToRootKind_open0_PropertyKey_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToRootKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToRootKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToRootKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToRootKind)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_MapTypeToRootKind_open0_ptr_JSFunction_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToRootKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToRootKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToRootKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToRootKind)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoEnterCycleCollection {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_AutoEnterCycleCollection() {
            assert_eq!(
                ::std::mem::size_of::<AutoEnterCycleCollection>(),
                1usize,
                concat!("Size of: ", stringify!(AutoEnterCycleCollection))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoEnterCycleCollection>(),
                1usize,
                concat!("Alignment of ", stringify!(AutoEnterCycleCollection))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DeletePolicy {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct FreePolicy {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_FreePolicy() {
            assert_eq!(
                ::std::mem::size_of::<FreePolicy>(),
                1usize,
                concat!("Size of: ", stringify!(FreePolicy))
            );
            assert_eq!(
                ::std::mem::align_of::<FreePolicy>(),
                1usize,
                concat!("Alignment of ", stringify!(FreePolicy))
            );
        }
        pub type UniqueChars = u64;
        pub type UniqueTwoByteChars = u8;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum BinASTFormat {
            Multipart = 0,
            Context = 1,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum HeapState {
            Idle = 0,
            Tracing = 1,
            MajorCollecting = 2,
            MinorCollecting = 3,
            CycleCollecting = 4,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS16RuntimeHeapStateEv"]
            pub fn RuntimeHeapState() -> root::JS::HeapState;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StackKind {
            StackForSystemCode = 0,
            StackForTrustedScript = 1,
            StackForUntrustedScript = 2,
            StackKindCount = 3,
        }
        pub mod shadow {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Zone {
                pub runtime_: *mut root::JSRuntime,
                pub barrierTracer_: *mut root::JSTracer,
                pub needsIncrementalBarrier_: u32,
                pub gcState_: root::JS::shadow::Zone_GCState,
            }
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum Zone_GCState {
                NoGC = 0,
                MarkBlackOnly = 1,
                MarkBlackAndGray = 2,
                Sweep = 3,
                Finished = 4,
                Compact = 5,
            }
            #[test]
            fn bindgen_test_layout_Zone() {
                assert_eq!(
                    ::std::mem::size_of::<Zone>(),
                    24usize,
                    concat!("Size of: ", stringify!(Zone))
                );
                assert_eq!(
                    ::std::mem::align_of::<Zone>(),
                    8usize,
                    concat!("Alignment of ", stringify!(Zone))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Zone>())).runtime_ as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Zone),
                        "::",
                        stringify!(runtime_)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Zone>())).barrierTracer_ as *const _ as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Zone),
                        "::",
                        stringify!(barrierTracer_)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<Zone>())).needsIncrementalBarrier_ as *const _
                            as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Zone),
                        "::",
                        stringify!(needsIncrementalBarrier_)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Zone>())).gcState_ as *const _ as usize },
                    20usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Zone),
                        "::",
                        stringify!(gcState_)
                    )
                );
            }
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct String {
                pub flags_: usize,
                pub __bindgen_anon_1: root::JS::shadow::String__bindgen_ty_1,
                pub externalCallbacks: *const root::JSExternalStringCallbacks,
            }
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub union String__bindgen_ty_1 {
                pub nonInlineCharsLatin1: *const root::JS::Latin1Char,
                pub nonInlineCharsTwoByte: *const u16,
                pub inlineStorageLatin1: [root::JS::Latin1Char; 1usize],
                pub inlineStorageTwoByte: [u16; 1usize],
                _bindgen_union_align: u64,
            }
            #[test]
            fn bindgen_test_layout_String__bindgen_ty_1() {
                assert_eq!(
                    ::std::mem::size_of::<String__bindgen_ty_1>(),
                    8usize,
                    concat!("Size of: ", stringify!(String__bindgen_ty_1))
                );
                assert_eq!(
                    ::std::mem::align_of::<String__bindgen_ty_1>(),
                    8usize,
                    concat!("Alignment of ", stringify!(String__bindgen_ty_1))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<String__bindgen_ty_1>())).nonInlineCharsLatin1
                            as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(String__bindgen_ty_1),
                        "::",
                        stringify!(nonInlineCharsLatin1)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<String__bindgen_ty_1>())).nonInlineCharsTwoByte
                            as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(String__bindgen_ty_1),
                        "::",
                        stringify!(nonInlineCharsTwoByte)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<String__bindgen_ty_1>())).inlineStorageLatin1
                            as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(String__bindgen_ty_1),
                        "::",
                        stringify!(inlineStorageLatin1)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<String__bindgen_ty_1>())).inlineStorageTwoByte
                            as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(String__bindgen_ty_1),
                        "::",
                        stringify!(inlineStorageTwoByte)
                    )
                );
            }
            pub const String_NON_ATOM_BIT: u32 = 2;
            pub const String_LINEAR_BIT: u32 = 16;
            pub const String_INLINE_CHARS_BIT: u32 = 64;
            pub const String_LATIN1_CHARS_BIT: u32 = 512;
            pub const String_EXTERNAL_FLAGS: u32 = 274;
            pub const String_TYPE_FLAGS_MASK: u32 = 506;
            pub const String_PERMANENT_ATOM_MASK: u32 = 258;
            pub const String_PERMANENT_ATOM_FLAGS: u32 = 256;
            #[test]
            fn bindgen_test_layout_String() {
                assert_eq!(
                    ::std::mem::size_of::<String>(),
                    24usize,
                    concat!("Size of: ", stringify!(String))
                );
                assert_eq!(
                    ::std::mem::align_of::<String>(),
                    8usize,
                    concat!("Alignment of ", stringify!(String))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<String>())).flags_ as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(String),
                        "::",
                        stringify!(flags_)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<String>())).externalCallbacks as *const _ as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(String),
                        "::",
                        stringify!(externalCallbacks)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Symbol {
                pub _1: *mut ::std::os::raw::c_void,
                pub code_: u32,
            }
            pub const Symbol_WellKnownAPILimit: u32 = 2147483648;
            #[test]
            fn bindgen_test_layout_Symbol() {
                assert_eq!(
                    ::std::mem::size_of::<Symbol>(),
                    16usize,
                    concat!("Size of: ", stringify!(Symbol))
                );
                assert_eq!(
                    ::std::mem::align_of::<Symbol>(),
                    8usize,
                    concat!("Alignment of ", stringify!(Symbol))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Symbol>()))._1 as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Symbol),
                        "::",
                        stringify!(_1)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Symbol>())).code_ as *const _ as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Symbol),
                        "::",
                        stringify!(code_)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Realm {
                pub compartment_: *mut root::JS::Compartment,
            }
            #[test]
            fn bindgen_test_layout_Realm() {
                assert_eq!(
                    ::std::mem::size_of::<Realm>(),
                    8usize,
                    concat!("Size of: ", stringify!(Realm))
                );
                assert_eq!(
                    ::std::mem::align_of::<Realm>(),
                    8usize,
                    concat!("Alignment of ", stringify!(Realm))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Realm>())).compartment_ as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Realm),
                        "::",
                        stringify!(compartment_)
                    )
                );
            }
        }
        #[doc = " A GC pointer, tagged with the trace kind."]
        #[doc = ""]
        #[doc = " In general, a GC pointer should be stored with an exact type. This class"]
        #[doc = " is for use when that is not possible because a single pointer must point"]
        #[doc = " to several kinds of GC thing."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GCCellPtr {
            pub ptr: usize,
        }
        #[test]
        fn bindgen_test_layout_GCCellPtr() {
            assert_eq!(
                ::std::mem::size_of::<GCCellPtr>(),
                8usize,
                concat!("Size of: ", stringify!(GCCellPtr))
            );
            assert_eq!(
                ::std::mem::align_of::<GCCellPtr>(),
                8usize,
                concat!("Alignment of ", stringify!(GCCellPtr))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<GCCellPtr>())).ptr as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GCCellPtr),
                    "::",
                    stringify!(ptr)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20GetNurseryStringZoneEP8JSString"]
            pub fn GetNurseryStringZone(str: *mut root::JSString) -> *mut root::JS::Zone;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13GetObjectZoneEP8JSObject"]
            pub fn GetObjectZone(obj: *mut root::JSObject) -> *mut root::JS::Zone;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS16GCThingTraceKindEPv"]
            pub fn GCThingTraceKind(thing: *mut ::std::os::raw::c_void) -> root::JS::TraceKind;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20EnableNurseryStringsEP9JSContext"]
            pub fn EnableNurseryStrings(cx: *mut root::JSContext);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS21DisableNurseryStringsEP9JSContext"]
            pub fn DisableNurseryStrings(cx: *mut root::JSContext);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS26IsIncrementalBarrierNeededEP9JSContext"]
            pub fn IsIncrementalBarrierNeeded(cx: *mut root::JSContext) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS26IncrementalPreWriteBarrierEP8JSObject"]
            pub fn IncrementalPreWriteBarrier(obj: *mut root::JSObject);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS26IncrementalPreWriteBarrierENS_9GCCellPtrE"]
            pub fn IncrementalPreWriteBarrier1(thing: root::JS::GCCellPtr);
        }
        extern "C" {
            #[doc = " Unsets the gray bit for anything reachable from |thing|. |kind| should not be"]
            #[doc = " JS::TraceKind::Shape. |thing| should be non-null. The return value indicates"]
            #[doc = " if anything was unmarked."]
            #[link_name = "\u{1}_ZN2JS28UnmarkGrayGCThingRecursivelyENS_9GCCellPtrE"]
            pub fn UnmarkGrayGCThingRecursively(thing: root::JS::GCCellPtr) -> bool;
        }
        extern "C" {
            #[doc = " Returns a static string equivalent of |kind|."]
            #[link_name = "\u{1}_ZN2JS18GCTraceKindToAsciiENS_9TraceKindE"]
            pub fn GCTraceKindToAscii(kind: root::JS::TraceKind) -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[doc = " Returns the base size in bytes of the GC thing of kind |kind|."]
            #[link_name = "\u{1}_ZN2JS15GCTraceKindSizeENS_9TraceKindE"]
            pub fn GCTraceKindSize(kind: root::JS::TraceKind) -> usize;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AutoTracingCallback {
            _unused: [u8; 0],
        }
        #[repr(C)]
        pub struct CallbackTracer__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CallbackTracer {
            pub vtable_: *const CallbackTracer__bindgen_vtable,
            pub _base: root::JSTracer,
            pub contextName_: *const ::std::os::raw::c_char,
            pub contextIndex_: usize,
            pub contextFunctor_: *mut root::JS::CallbackTracer_ContextFunctor,
        }
        #[repr(C)]
        pub struct CallbackTracer_ContextFunctor__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CallbackTracer_ContextFunctor {
            pub vtable_: *const CallbackTracer_ContextFunctor__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_CallbackTracer_ContextFunctor() {
            assert_eq!(
                ::std::mem::size_of::<CallbackTracer_ContextFunctor>(),
                8usize,
                concat!("Size of: ", stringify!(CallbackTracer_ContextFunctor))
            );
            assert_eq!(
                ::std::mem::align_of::<CallbackTracer_ContextFunctor>(),
                8usize,
                concat!("Alignment of ", stringify!(CallbackTracer_ContextFunctor))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS14CallbackTracer12InvalidIndexE"]
            pub static CallbackTracer_InvalidIndex: usize;
        }
        #[test]
        fn bindgen_test_layout_CallbackTracer() {
            assert_eq!(
                ::std::mem::size_of::<CallbackTracer>(),
                56usize,
                concat!("Size of: ", stringify!(CallbackTracer))
            );
            assert_eq!(
                ::std::mem::align_of::<CallbackTracer>(),
                8usize,
                concat!("Alignment of ", stringify!(CallbackTracer))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<CallbackTracer>())).contextName_ as *const _ as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CallbackTracer),
                    "::",
                    stringify!(contextName_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<CallbackTracer>())).contextIndex_ as *const _ as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CallbackTracer),
                    "::",
                    stringify!(contextIndex_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<CallbackTracer>())).contextFunctor_ as *const _ as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CallbackTracer),
                    "::",
                    stringify!(contextFunctor_)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoTracingName {
            pub trc_: *mut root::JS::CallbackTracer,
            pub prior_: *const ::std::os::raw::c_char,
        }
        #[test]
        fn bindgen_test_layout_AutoTracingName() {
            assert_eq!(
                ::std::mem::size_of::<AutoTracingName>(),
                16usize,
                concat!("Size of: ", stringify!(AutoTracingName))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoTracingName>(),
                8usize,
                concat!("Alignment of ", stringify!(AutoTracingName))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<AutoTracingName>())).trc_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoTracingName),
                    "::",
                    stringify!(trc_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<AutoTracingName>())).prior_ as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoTracingName),
                    "::",
                    stringify!(prior_)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoTracingIndex {
            pub trc_: *mut root::JS::CallbackTracer,
        }
        #[test]
        fn bindgen_test_layout_AutoTracingIndex() {
            assert_eq!(
                ::std::mem::size_of::<AutoTracingIndex>(),
                8usize,
                concat!("Size of: ", stringify!(AutoTracingIndex))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoTracingIndex>(),
                8usize,
                concat!("Alignment of ", stringify!(AutoTracingIndex))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<AutoTracingIndex>())).trc_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoTracingIndex),
                    "::",
                    stringify!(trc_)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoTracingDetails {
            pub trc_: *mut root::JS::CallbackTracer,
        }
        #[test]
        fn bindgen_test_layout_AutoTracingDetails() {
            assert_eq!(
                ::std::mem::size_of::<AutoTracingDetails>(),
                8usize,
                concat!("Size of: ", stringify!(AutoTracingDetails))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoTracingDetails>(),
                8usize,
                concat!("Alignment of ", stringify!(AutoTracingDetails))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<AutoTracingDetails>())).trc_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoTracingDetails),
                    "::",
                    stringify!(trc_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13TraceChildrenEP8JSTracerNS_9GCCellPtrE"]
            pub fn TraceChildren(trc: *mut root::JSTracer, thing: root::JS::GCCellPtr);
        }
        pub type ZoneSet = u8;
        pub type CompartmentSet = u8;
        extern "C" {
            #[doc = " Trace every value within |compartments| that is wrapped by a"]
            #[doc = " cross-compartment wrapper from a compartment that is not an element of"]
            #[doc = " |compartments|."]
            #[link_name = "\u{1}_ZN2JS17TraceIncomingCCWsEP8JSTracerRKN7mozilla7HashSetIPNS_11CompartmentENS2_13DefaultHasherIS5_EEN2js17SystemAllocPolicyEEE"]
            pub fn TraceIncomingCCWs(
                trc: *mut root::JSTracer,
                compartments: *const root::JS::CompartmentSet,
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct StructGCPolicy {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GCPolicy {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IgnoreGCPolicy {
            pub _address: u8,
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_unsigned_int_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_unsigned_long_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GCPointerPolicy {
            pub _address: u8,
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_Symbol_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_Symbol_close0_instantiation_1() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_BigInt_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_BigInt_close0_instantiation_1() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_JSAtom_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_JSAtom_close0_instantiation_1() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_JSFunction_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_JSFunction_close0_instantiation_1() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_JSObject_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_JSObject_close0_instantiation_1() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_JSScript_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_JSScript_close0_instantiation_1() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_JSString_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_JSString_close0_instantiation_1() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct NonGCPointerPolicy {
            pub _address: u8,
        }
        impl root::JS::ProfilingCategoryPair {
            pub const LAST: root::JS::ProfilingCategoryPair = ProfilingCategoryPair::IPC;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ProfilingCategoryPair {
            IDLE = 0,
            OTHER_PreferenceRead = 1,
            OTHER = 2,
            LAYOUT = 3,
            LAYOUT_FrameConstruction = 4,
            LAYOUT_Reflow = 5,
            LAYOUT_CSSParsing = 6,
            LAYOUT_SelectorQuery = 7,
            LAYOUT_StyleComputation = 8,
            JS = 9,
            JS_Parsing = 10,
            JS_IonCompilation = 11,
            JS_BaselineCompilation = 12,
            GCCC = 13,
            NETWORK = 14,
            GRAPHICS = 15,
            GRAPHICS_DisplayListBuilding = 16,
            GRAPHICS_DisplayListMerging = 17,
            GRAPHICS_LayerBuilding = 18,
            GRAPHICS_TileAllocation = 19,
            GRAPHICS_WRDisplayList = 20,
            GRAPHICS_Rasterization = 21,
            GRAPHICS_FlushingAsyncPaints = 22,
            GRAPHICS_ImageDecoding = 23,
            DOM = 24,
            IPC = 25,
            COUNT = 26,
        }
        impl root::JS::ProfilingCategory {
            pub const LAST: root::JS::ProfilingCategory = ProfilingCategory::IPC;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ProfilingCategory {
            IDLE = 0,
            OTHER = 1,
            LAYOUT = 2,
            JS = 3,
            GCCC = 4,
            NETWORK = 5,
            GRAPHICS = 6,
            DOM = 7,
            IPC = 8,
            COUNT = 9,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ProfilingCategoryPairInfo {
            pub mCategory: root::JS::ProfilingCategory,
            pub mSubcategoryIndex: u32,
            pub mLabel: *const ::std::os::raw::c_char,
        }
        #[test]
        fn bindgen_test_layout_ProfilingCategoryPairInfo() {
            assert_eq!(
                ::std::mem::size_of::<ProfilingCategoryPairInfo>(),
                16usize,
                concat!("Size of: ", stringify!(ProfilingCategoryPairInfo))
            );
            assert_eq!(
                ::std::mem::align_of::<ProfilingCategoryPairInfo>(),
                8usize,
                concat!("Alignment of ", stringify!(ProfilingCategoryPairInfo))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ProfilingCategoryPairInfo>())).mCategory as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ProfilingCategoryPairInfo),
                    "::",
                    stringify!(mCategory)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ProfilingCategoryPairInfo>())).mSubcategoryIndex
                        as *const _ as usize
                },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ProfilingCategoryPairInfo),
                    "::",
                    stringify!(mSubcategoryIndex)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ProfilingCategoryPairInfo>())).mLabel as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ProfilingCategoryPairInfo),
                    "::",
                    stringify!(mLabel)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS28GetProfilingCategoryPairInfoENS_21ProfilingCategoryPairE"]
            pub fn GetProfilingCategoryPairInfo(
                aCategoryPair: root::JS::ProfilingCategoryPair,
            ) -> *const root::JS::ProfilingCategoryPairInfo;
        }
        pub type RegisterThreadCallback = ::std::option::Option<
            unsafe extern "C" fn(
                threadName: *const ::std::os::raw::c_char,
                stackBase: *mut ::std::os::raw::c_void,
            ) -> *mut root::ProfilingStack,
        >;
        pub type UnregisterThreadCallback = ::std::option::Option<unsafe extern "C" fn()>;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS27SetProfilingThreadCallbacksEPFP14ProfilingStackPKcPvEPFvvE"]
            pub fn SetProfilingThreadCallbacks(
                registerThread: root::JS::RegisterThreadCallback,
                unregisterThread: root::JS::UnregisterThreadCallback,
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_Realm_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS21GetCurrentRealmOrNullEP9JSContext"]
            pub fn GetCurrentRealmOrNull(cx: *mut root::JSContext) -> *mut root::JS::Realm;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20GetObjectRealmOrNullEP8JSObject"]
            pub fn GetObjectRealmOrNull(obj: *mut root::JSObject) -> *mut root::JS::Realm;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15GetRealmPrivateEPNS_5RealmE"]
            pub fn GetRealmPrivate(realm: *mut root::JS::Realm) -> *mut ::std::os::raw::c_void;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15SetRealmPrivateEPNS_5RealmEPv"]
            pub fn SetRealmPrivate(realm: *mut root::JS::Realm, data: *mut ::std::os::raw::c_void);
        }
        pub type DestroyRealmCallback = ::std::option::Option<
            unsafe extern "C" fn(fop: *mut root::JSFreeOp, realm: *mut root::JS::Realm),
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23SetDestroyRealmCallbackEP9JSContextPFvP8JSFreeOpPNS_5RealmEE"]
            pub fn SetDestroyRealmCallback(
                cx: *mut root::JSContext,
                callback: root::JS::DestroyRealmCallback,
            );
        }
        pub type RealmNameCallback = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                realm: root::JS::Handle<*mut root::JS::Realm>,
                buf: *mut ::std::os::raw::c_char,
                bufsize: usize,
            ),
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20SetRealmNameCallbackEP9JSContextPFvS1_NS_6HandleIPNS_5RealmEEEPcmE"]
            pub fn SetRealmNameCallback(
                cx: *mut root::JSContext,
                callback: root::JS::RealmNameCallback,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20GetRealmGlobalOrNullENS_6HandleIPNS_5RealmEEE"]
            pub fn GetRealmGlobalOrNull(
                realm: root::JS::Handle<*mut root::JS::Realm>,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS24InitRealmStandardClassesEP9JSContext"]
            pub fn InitRealmStandardClasses(cx: *mut root::JSContext) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23GetRealmObjectPrototypeEP9JSContext"]
            pub fn GetRealmObjectPrototype(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS25GetRealmFunctionPrototypeEP9JSContext"]
            pub fn GetRealmFunctionPrototype(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS22GetRealmArrayPrototypeEP9JSContext"]
            pub fn GetRealmArrayPrototype(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS22GetRealmErrorPrototypeEP9JSContext"]
            pub fn GetRealmErrorPrototype(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS25GetRealmIteratorPrototypeEP9JSContext"]
            pub fn GetRealmIteratorPrototype(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS16GetFunctionRealmEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn GetFunctionRealm(
                cx: *mut root::JSContext,
                objArg: root::JS::HandleObject,
            ) -> *mut root::JS::Realm;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS26HeapObjectPostWriteBarrierEPP8JSObjectS1_S1_"]
            pub fn HeapObjectPostWriteBarrier(
                objp: *mut *mut root::JSObject,
                prev: *mut root::JSObject,
                next: *mut root::JSObject,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS26HeapStringPostWriteBarrierEPP8JSStringS1_S1_"]
            pub fn HeapStringPostWriteBarrier(
                objp: *mut *mut root::JSString,
                prev: *mut root::JSString,
                next: *mut root::JSString,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23HeapObjectWriteBarriersEPP8JSObjectS1_S1_"]
            pub fn HeapObjectWriteBarriers(
                objp: *mut *mut root::JSObject,
                prev: *mut root::JSObject,
                next: *mut root::JSObject,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23HeapStringWriteBarriersEPP8JSStringS1_S1_"]
            pub fn HeapStringWriteBarriers(
                objp: *mut *mut root::JSString,
                prev: *mut root::JSString,
                next: *mut root::JSString,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23HeapScriptWriteBarriersEPP8JSScriptS1_S1_"]
            pub fn HeapScriptWriteBarriers(
                objp: *mut *mut root::JSScript,
                prev: *mut root::JSScript,
                next: *mut root::JSScript,
            );
        }
        pub type Heap_ElementType<T> = T;
        #[doc = " The TenuredHeap<T> class is similar to the Heap<T> class above in that it"]
        #[doc = " encapsulates the GC concerns of an on-heap reference to a JS object. However,"]
        #[doc = " it has two important differences:"]
        #[doc = ""]
        #[doc = "  1) Pointers which are statically known to only reference \"tenured\" objects"]
        #[doc = "     can avoid the extra overhead of SpiderMonkey's write barriers."]
        #[doc = ""]
        #[doc = "  2) Objects in the \"tenured\" heap have stronger alignment restrictions than"]
        #[doc = "     those in the \"nursery\", so it is possible to store flags in the lower"]
        #[doc = "     bits of pointers known to be tenured. TenuredHeap wraps a normal tagged"]
        #[doc = "     pointer with a nice API for accessing the flag bits and adds various"]
        #[doc = "     assertions to ensure that it is not mis-used."]
        #[doc = ""]
        #[doc = " GC things are said to be \"tenured\" when they are located in the long-lived"]
        #[doc = " heap: e.g. they have gained tenure as an object by surviving past at least"]
        #[doc = " one GC. For performance, SpiderMonkey allocates some things which are known"]
        #[doc = " to normally be long lived directly into the tenured generation; for example,"]
        #[doc = " global objects. Additionally, SpiderMonkey does not visit individual objects"]
        #[doc = " when deleting non-tenured objects, so object with finalizers are also always"]
        #[doc = " tenured; for instance, this includes most DOM objects."]
        #[doc = ""]
        #[doc = " The considerations to keep in mind when using a TenuredHeap<T> vs a normal"]
        #[doc = " Heap<T> are:"]
        #[doc = ""]
        #[doc = "  - It is invalid for a TenuredHeap<T> to refer to a non-tenured thing."]
        #[doc = "  - It is however valid for a Heap<T> to refer to a tenured thing."]
        #[doc = "  - It is not possible to store flag bits in a Heap<T>."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TenuredHeap {
            pub bits: usize,
        }
        pub type TenuredHeap_ElementType<T> = T;
        pub const TenuredHeap_maskBits: root::JS::TenuredHeap__bindgen_ty_1 =
            TenuredHeap__bindgen_ty_1::maskBits;
        pub const TenuredHeap_flagsMask: root::JS::TenuredHeap__bindgen_ty_1 =
            TenuredHeap__bindgen_ty_1::maskBits;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum TenuredHeap__bindgen_ty_1 {
            maskBits = 0,
        }
        #[doc = " Reference to a T that has been rooted elsewhere. This is most useful"]
        #[doc = " as a parameter type, which guarantees that the T lvalue is properly"]
        #[doc = " rooted. See \"Move GC Stack Rooting\" above."]
        #[doc = ""]
        #[doc = " If you want to add additional methods to Handle for a specific"]
        #[doc = " specialization, define a HandleBase<T> specialization containing them."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Handle<T> {
            pub ptr: *const T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        pub type Handle_ElementType<T> = T;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum Handle_Disambiguator {
            DeliberatelyChoosingThisOverload = 0,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum Handle_CallerIdentity {
            ImUsingThisOnlyInFromFromMarkedLocation = 0,
        }
        #[doc = " Similar to a handle, but the underlying storage can be changed. This is"]
        #[doc = " useful for outparams."]
        #[doc = ""]
        #[doc = " If you want to add additional methods to MutableHandle for a specific"]
        #[doc = " specialization, define a MutableHandleBase<T> specialization containing"]
        #[doc = " them."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MutableHandle<T> {
            pub ptr: *mut T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        pub type MutableHandle_ElementType<T> = T;
        #[test]
        fn __bindgen_test_layout_MapTypeToRootKind_open0_ptr_void_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::MapTypeToRootKind>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::MapTypeToRootKind)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::MapTypeToRootKind>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::MapTypeToRootKind)
                )
            );
        }
        pub type RootedListHeads = [u64; 15usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RootingContext {
            pub stackRoots_: root::JS::RootedListHeads,
            pub autoGCRooters_: *mut root::JS::AutoGCRooter,
            pub geckoProfiler_: root::js::GeckoProfilerThread,
            pub realm_: *mut root::JS::Realm,
            pub zone_: *mut root::JS::Zone,
            pub nativeStackLimit: [usize; 3usize],
        }
        #[test]
        fn bindgen_test_layout_RootingContext() {
            assert_eq!(
                ::std::mem::size_of::<RootingContext>(),
                184usize,
                concat!("Size of: ", stringify!(RootingContext))
            );
            assert_eq!(
                ::std::mem::align_of::<RootingContext>(),
                8usize,
                concat!("Alignment of ", stringify!(RootingContext))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RootingContext>())).stackRoots_ as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RootingContext),
                    "::",
                    stringify!(stackRoots_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RootingContext>())).autoGCRooters_ as *const _ as usize
                },
                120usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RootingContext),
                    "::",
                    stringify!(autoGCRooters_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RootingContext>())).geckoProfiler_ as *const _ as usize
                },
                128usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RootingContext),
                    "::",
                    stringify!(geckoProfiler_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<RootingContext>())).realm_ as *const _ as usize },
                144usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RootingContext),
                    "::",
                    stringify!(realm_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<RootingContext>())).zone_ as *const _ as usize },
                152usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RootingContext),
                    "::",
                    stringify!(zone_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RootingContext>())).nativeStackLimit as *const _ as usize
                },
                160usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RootingContext),
                    "::",
                    stringify!(nativeStackLimit)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoGCRooter {
            pub down: *mut root::JS::AutoGCRooter,
            pub stackTop: *mut *mut root::JS::AutoGCRooter,
            pub tag_: root::JS::AutoGCRooter_Tag,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum AutoGCRooter_Tag {
            Array = 0,
            ValueArray = 1,
            Parser = 2,
            BinASTParser = 3,
            WrapperVector = 4,
            Wrapper = 5,
            Custom = 6,
        }
        #[test]
        fn bindgen_test_layout_AutoGCRooter() {
            assert_eq!(
                ::std::mem::size_of::<AutoGCRooter>(),
                24usize,
                concat!("Size of: ", stringify!(AutoGCRooter))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoGCRooter>(),
                8usize,
                concat!("Alignment of ", stringify!(AutoGCRooter))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<AutoGCRooter>())).down as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoGCRooter),
                    "::",
                    stringify!(down)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<AutoGCRooter>())).stackTop as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoGCRooter),
                    "::",
                    stringify!(stackTop)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<AutoGCRooter>())).tag_ as *const _ as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoGCRooter),
                    "::",
                    stringify!(tag_)
                )
            );
        }
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub type MaybeWrapped = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct FallbackOverload {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_FallbackOverload() {
                assert_eq!(
                    ::std::mem::size_of::<FallbackOverload>(),
                    1usize,
                    concat!("Size of: ", stringify!(FallbackOverload))
                );
                assert_eq!(
                    ::std::mem::align_of::<FallbackOverload>(),
                    1usize,
                    concat!("Alignment of ", stringify!(FallbackOverload))
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct PreferredOverload {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_PreferredOverload() {
                assert_eq!(
                    ::std::mem::size_of::<PreferredOverload>(),
                    1usize,
                    concat!("Size of: ", stringify!(PreferredOverload))
                );
                assert_eq!(
                    ::std::mem::align_of::<PreferredOverload>(),
                    1usize,
                    concat!("Alignment of ", stringify!(PreferredOverload))
                );
            }
            pub type OverloadSelector = root::JS::detail::PreferredOverload;
            extern "C" {
                #[link_name = "\u{1}_ZN2JS6detail11ComputeThisEP9JSContextPNS_5ValueENS_13MutableHandleIP8JSObjectEE"]
                pub fn ComputeThis(
                    cx: *mut root::JSContext,
                    vp: *mut root::JS::Value,
                    thisObject: root::JS::MutableHandleObject,
                ) -> bool;
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IncludeUsedRval {
                pub usedRval_: bool,
            }
            #[test]
            fn bindgen_test_layout_IncludeUsedRval() {
                assert_eq!(
                    ::std::mem::size_of::<IncludeUsedRval>(),
                    1usize,
                    concat!("Size of: ", stringify!(IncludeUsedRval))
                );
                assert_eq!(
                    ::std::mem::align_of::<IncludeUsedRval>(),
                    1usize,
                    concat!("Alignment of ", stringify!(IncludeUsedRval))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<IncludeUsedRval>())).usedRval_ as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(IncludeUsedRval),
                        "::",
                        stringify!(usedRval_)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct NoUsedRval {
                pub _address: u8,
            }
            #[test]
            fn bindgen_test_layout_NoUsedRval() {
                assert_eq!(
                    ::std::mem::size_of::<NoUsedRval>(),
                    1usize,
                    concat!("Size of: ", stringify!(NoUsedRval))
                );
                assert_eq!(
                    ::std::mem::align_of::<NoUsedRval>(),
                    1usize,
                    concat!("Alignment of ", stringify!(NoUsedRval))
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CallArgsBase {
                pub _address: u8,
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS6detail19CallMethodIfWrappedEP9JSContextPFbNS_6HandleINS_5ValueEEEEPFbS2_RKNS_8CallArgsEESA_"]
                pub fn CallMethodIfWrapped(
                    cx: *mut root::JSContext,
                    test: root::JS::IsAcceptableThis,
                    impl_: root::JS::NativeImpl,
                    args: *const root::JS::CallArgs,
                ) -> bool;
            }
            #[repr(i32)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
            pub enum InitState {
                Uninitialized = 0,
                Initializing = 1,
                Running = 2,
                ShutDown = 3,
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS6detail25InitWithFailureDiagnosticEb"]
                pub fn InitWithFailureDiagnostic(
                    isDebugBuild: bool,
                ) -> *const ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS6detail19ReportSourceTooLongEP9JSContext"]
                pub fn ReportSourceTooLong(cx: *mut root::JSContext);
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Rooted_CtorDispatcher {
            pub _address: u8,
        }
        pub type Rooted_ElementType<T> = T;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17AddPersistentRootEPNS_14RootingContextENS_8RootKindEPNS_16PersistentRootedIPvEE"]
            pub fn AddPersistentRoot(
                cx: *mut root::JS::RootingContext,
                kind: root::JS::RootKind,
                root: *mut [u64; 5usize],
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17AddPersistentRootEP9JSRuntimeNS_8RootKindEPNS_16PersistentRootedIPvEE"]
            pub fn AddPersistentRoot1(
                rt: *mut root::JSRuntime,
                kind: root::JS::RootKind,
                root: *mut [u64; 5usize],
            );
        }
        #[doc = " A copyable, assignable global GC root type with arbitrary lifetime, an"]
        #[doc = " infallible constructor, and automatic unrooting on destruction."]
        #[doc = ""]
        #[doc = " These roots can be used in heap-allocated data structures, so they are not"]
        #[doc = " associated with any particular JSContext or stack. They are registered with"]
        #[doc = " the JSRuntime itself, without locking. Initialization may take place on"]
        #[doc = " construction, or in two phases if the no-argument constructor is called"]
        #[doc = " followed by init()."]
        #[doc = ""]
        #[doc = " Note that you must not use an PersistentRooted in an object owned by a JS"]
        #[doc = " object:"]
        #[doc = ""]
        #[doc = " Whenever one object whose lifetime is decided by the GC refers to another"]
        #[doc = " such object, that edge must be traced only if the owning JS object is traced."]
        #[doc = " This applies not only to JS objects (which obviously are managed by the GC)"]
        #[doc = " but also to C++ objects owned by JS objects."]
        #[doc = ""]
        #[doc = " If you put a PersistentRooted in such a C++ object, that is almost certainly"]
        #[doc = " a leak. When a GC begins, the referent of the PersistentRooted is treated as"]
        #[doc = " live, unconditionally (because a PersistentRooted is a *root*), even if the"]
        #[doc = " JS object that owns it is unreachable. If there is any path from that"]
        #[doc = " referent back to the JS object, then the C++ object containing the"]
        #[doc = " PersistentRooted will not be destructed, and the whole blob of objects will"]
        #[doc = " not be freed, even if there are no references to them from the outside."]
        #[doc = ""]
        #[doc = " In the context of Firefox, this is a severe restriction: almost everything in"]
        #[doc = " Firefox is owned by some JS object or another, so using PersistentRooted in"]
        #[doc = " such objects would introduce leaks. For these kinds of edges, Heap<T> or"]
        #[doc = " TenuredHeap<T> would be better types. It's up to the implementor of the type"]
        #[doc = " containing Heap<T> or TenuredHeap<T> members to make sure their referents get"]
        #[doc = " marked when the object itself is marked."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PersistentRooted {
            pub _address: u8,
        }
        pub type PersistentRooted_ListBase = u8;
        pub type PersistentRooted_ElementType = u8;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum GCReason {
            API = 0,
            EAGER_ALLOC_TRIGGER = 1,
            DESTROY_RUNTIME = 2,
            ROOTS_REMOVED = 3,
            LAST_DITCH = 4,
            TOO_MUCH_MALLOC = 5,
            ALLOC_TRIGGER = 6,
            DEBUG_GC = 7,
            COMPARTMENT_REVIVED = 8,
            RESET = 9,
            OUT_OF_NURSERY = 10,
            EVICT_NURSERY = 11,
            DELAYED_ATOMS_GC = 12,
            SHARED_MEMORY_LIMIT = 13,
            IDLE_TIME_COLLECTION = 14,
            INCREMENTAL_TOO_SLOW = 15,
            ABORT_GC = 16,
            FULL_WHOLE_CELL_BUFFER = 17,
            FULL_GENERIC_BUFFER = 18,
            FULL_VALUE_BUFFER = 19,
            FULL_CELL_PTR_OBJ_BUFFER = 20,
            FULL_SLOT_BUFFER = 21,
            FULL_SHAPE_BUFFER = 22,
            TOO_MUCH_WASM_MEMORY = 23,
            DISABLE_GENERATIONAL_GC = 24,
            FINISH_GC = 25,
            PREPARE_FOR_TRACING = 26,
            INCREMENTAL_ALLOC_TRIGGER = 27,
            FULL_CELL_PTR_STR_BUFFER = 28,
            TOO_MUCH_JIT_CODE = 29,
            RESERVED6 = 30,
            RESERVED7 = 31,
            RESERVED8 = 32,
            DOM_WINDOW_UTILS = 33,
            COMPONENT_UTILS = 34,
            MEM_PRESSURE = 35,
            CC_WAITING = 36,
            CC_FORCED = 37,
            LOAD_END = 38,
            UNUSED3 = 39,
            PAGE_HIDE = 40,
            NSJSCONTEXT_DESTROY = 41,
            WORKER_SHUTDOWN = 42,
            SET_DOC_SHELL = 43,
            DOM_UTILS = 44,
            DOM_IPC = 45,
            DOM_WORKER = 46,
            INTER_SLICE_GC = 47,
            UNUSED1 = 48,
            FULL_GC_TIMER = 49,
            SHUTDOWN_CC = 50,
            UNUSED2 = 51,
            USER_INACTIVE = 52,
            XPCONNECT_SHUTDOWN = 53,
            DOCSHELL = 54,
            HTML_PARSER = 55,
            NO_REASON = 56,
            NUM_REASONS = 57,
            NUM_TELEMETRY_REASONS = 100,
        }
        extern "C" {
            #[doc = " Get a statically allocated C string explaining the given GC reason."]
            #[link_name = "\u{1}_ZN2JS15ExplainGCReasonENS_8GCReasonE"]
            pub fn ExplainGCReason(reason: root::JS::GCReason) -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[doc = " Schedule the given zone to be collected as part of the next GC."]
            #[link_name = "\u{1}_ZN2JS16PrepareZoneForGCEPNS_4ZoneE"]
            pub fn PrepareZoneForGC(zone: *mut root::JS::Zone);
        }
        extern "C" {
            #[doc = " Schedule all zones to be collected in the next GC."]
            #[link_name = "\u{1}_ZN2JS16PrepareForFullGCEP9JSContext"]
            pub fn PrepareForFullGC(cx: *mut root::JSContext);
        }
        extern "C" {
            #[doc = " When performing an incremental GC, the zones that were selected for the"]
            #[doc = " previous incremental slice must be selected in subsequent slices as well."]
            #[doc = " This function selects those slices automatically."]
            #[link_name = "\u{1}_ZN2JS23PrepareForIncrementalGCEP9JSContext"]
            pub fn PrepareForIncrementalGC(cx: *mut root::JSContext);
        }
        extern "C" {
            #[doc = " Returns true if any zone in the system has been scheduled for GC with one of"]
            #[doc = " the functions above or by the JS engine."]
            #[link_name = "\u{1}_ZN2JS13IsGCScheduledEP9JSContext"]
            pub fn IsGCScheduled(cx: *mut root::JSContext) -> bool;
        }
        extern "C" {
            #[doc = " Undoes the effect of the Prepare methods above. The given zone will not be"]
            #[doc = " collected in the next GC."]
            #[link_name = "\u{1}_ZN2JS13SkipZoneForGCEPNS_4ZoneE"]
            pub fn SkipZoneForGC(zone: *mut root::JS::Zone);
        }
        extern "C" {
            #[doc = " Performs a non-incremental collection of all selected zones."]
            #[doc = ""]
            #[doc = " If the gckind argument is GC_NORMAL, then some objects that are unreachable"]
            #[doc = " from the program may still be alive afterwards because of internal"]
            #[doc = " references; if GC_SHRINK is passed then caches and other temporary references"]
            #[doc = " to objects will be cleared and all unreferenced objects will be removed from"]
            #[doc = " the system."]
            #[link_name = "\u{1}_ZN2JS16NonIncrementalGCEP9JSContext18JSGCInvocationKindNS_8GCReasonE"]
            pub fn NonIncrementalGC(
                cx: *mut root::JSContext,
                gckind: root::JSGCInvocationKind,
                reason: root::JS::GCReason,
            );
        }
        extern "C" {
            #[doc = " Begin an incremental collection and perform one slice worth of work. When"]
            #[doc = " this function returns, the collection may not be complete."]
            #[doc = " IncrementalGCSlice() must be called repeatedly until"]
            #[doc = " !IsIncrementalGCInProgress(cx)."]
            #[doc = ""]
            #[doc = " Note: SpiderMonkey's GC is not realtime. Slices in practice may be longer or"]
            #[doc = "       shorter than the requested interval."]
            #[link_name = "\u{1}_ZN2JS18StartIncrementalGCEP9JSContext18JSGCInvocationKindNS_8GCReasonEl"]
            pub fn StartIncrementalGC(
                cx: *mut root::JSContext,
                gckind: root::JSGCInvocationKind,
                reason: root::JS::GCReason,
                millis: i64,
            );
        }
        extern "C" {
            #[doc = " Perform a slice of an ongoing incremental collection. When this function"]
            #[doc = " returns, the collection may not be complete. It must be called repeatedly"]
            #[doc = " until !IsIncrementalGCInProgress(cx)."]
            #[doc = ""]
            #[doc = " Note: SpiderMonkey's GC is not realtime. Slices in practice may be longer or"]
            #[doc = "       shorter than the requested interval."]
            #[link_name = "\u{1}_ZN2JS18IncrementalGCSliceEP9JSContextNS_8GCReasonEl"]
            pub fn IncrementalGCSlice(
                cx: *mut root::JSContext,
                reason: root::JS::GCReason,
                millis: i64,
            );
        }
        extern "C" {
            #[doc = " Return whether an incremental GC has work to do on the foreground thread and"]
            #[doc = " would make progress if a slice was run now. If this returns false then the GC"]
            #[doc = " is waiting for background threads to finish their work and a slice started"]
            #[doc = " now would return immediately."]
            #[link_name = "\u{1}_ZN2JS30IncrementalGCHasForegroundWorkEP9JSContext"]
            pub fn IncrementalGCHasForegroundWork(cx: *mut root::JSContext) -> bool;
        }
        extern "C" {
            #[doc = " If IsIncrementalGCInProgress(cx), this call finishes the ongoing collection"]
            #[doc = " by performing an arbitrarily long slice. If !IsIncrementalGCInProgress(cx),"]
            #[doc = " this is equivalent to NonIncrementalGC. When this function returns,"]
            #[doc = " IsIncrementalGCInProgress(cx) will always be false."]
            #[link_name = "\u{1}_ZN2JS19FinishIncrementalGCEP9JSContextNS_8GCReasonE"]
            pub fn FinishIncrementalGC(cx: *mut root::JSContext, reason: root::JS::GCReason);
        }
        extern "C" {
            #[doc = " If IsIncrementalGCInProgress(cx), this call aborts the ongoing collection and"]
            #[doc = " performs whatever work needs to be done to return the collector to its idle"]
            #[doc = " state. This may take an arbitrarily long time. When this function returns,"]
            #[doc = " IsIncrementalGCInProgress(cx) will always be false."]
            #[link_name = "\u{1}_ZN2JS18AbortIncrementalGCEP9JSContext"]
            pub fn AbortIncrementalGC(cx: *mut root::JSContext);
        }
        pub mod dbg {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug)]
            pub struct GarbageCollectionEvent {
                pub majorGCNumber_: u64,
                pub reason: *const ::std::os::raw::c_char,
                pub nonincrementalReason: *const ::std::os::raw::c_char,
                pub collections: [u64; 3usize],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct GarbageCollectionEvent_Collection {
                pub startTimestamp: root::mozilla::TimeStamp,
                pub endTimestamp: root::mozilla::TimeStamp,
            }
            #[test]
            fn bindgen_test_layout_GarbageCollectionEvent_Collection() {
                assert_eq!(
                    ::std::mem::size_of::<GarbageCollectionEvent_Collection>(),
                    16usize,
                    concat!("Size of: ", stringify!(GarbageCollectionEvent_Collection))
                );
                assert_eq!(
                    ::std::mem::align_of::<GarbageCollectionEvent_Collection>(),
                    8usize,
                    concat!(
                        "Alignment of ",
                        stringify!(GarbageCollectionEvent_Collection)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<GarbageCollectionEvent_Collection>())).startTimestamp
                            as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(GarbageCollectionEvent_Collection),
                        "::",
                        stringify!(startTimestamp)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<GarbageCollectionEvent_Collection>())).endTimestamp
                            as *const _ as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(GarbageCollectionEvent_Collection),
                        "::",
                        stringify!(endTimestamp)
                    )
                );
            }
            pub type GarbageCollectionEvent_Ptr = u8;
            #[test]
            fn bindgen_test_layout_GarbageCollectionEvent() {
                assert_eq!(
                    ::std::mem::size_of::<GarbageCollectionEvent>(),
                    48usize,
                    concat!("Size of: ", stringify!(GarbageCollectionEvent))
                );
                assert_eq!(
                    ::std::mem::align_of::<GarbageCollectionEvent>(),
                    8usize,
                    concat!("Alignment of ", stringify!(GarbageCollectionEvent))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<GarbageCollectionEvent>())).majorGCNumber_
                            as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(GarbageCollectionEvent),
                        "::",
                        stringify!(majorGCNumber_)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<GarbageCollectionEvent>())).reason as *const _
                            as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(GarbageCollectionEvent),
                        "::",
                        stringify!(reason)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<GarbageCollectionEvent>())).nonincrementalReason
                            as *const _ as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(GarbageCollectionEvent),
                        "::",
                        stringify!(nonincrementalReason)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<GarbageCollectionEvent>())).collections as *const _
                            as usize
                    },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(GarbageCollectionEvent),
                        "::",
                        stringify!(collections)
                    )
                );
            }
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum GCProgress {
            GC_CYCLE_BEGIN = 0,
            GC_SLICE_BEGIN = 1,
            GC_SLICE_END = 2,
            GC_CYCLE_END = 3,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GCDescription {
            pub isZone_: bool,
            pub isComplete_: bool,
            pub invocationKind_: root::JSGCInvocationKind,
            pub reason_: root::JS::GCReason,
        }
        #[test]
        fn bindgen_test_layout_GCDescription() {
            assert_eq!(
                ::std::mem::size_of::<GCDescription>(),
                12usize,
                concat!("Size of: ", stringify!(GCDescription))
            );
            assert_eq!(
                ::std::mem::align_of::<GCDescription>(),
                4usize,
                concat!("Alignment of ", stringify!(GCDescription))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<GCDescription>())).isZone_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GCDescription),
                    "::",
                    stringify!(isZone_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GCDescription>())).isComplete_ as *const _ as usize
                },
                1usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GCDescription),
                    "::",
                    stringify!(isComplete_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GCDescription>())).invocationKind_ as *const _ as usize
                },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GCDescription),
                    "::",
                    stringify!(invocationKind_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<GCDescription>())).reason_ as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GCDescription),
                    "::",
                    stringify!(reason_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13MinorGcToJSONEP9JSContext"]
            pub fn MinorGcToJSON(cx: *mut root::JSContext) -> root::JS::UniqueChars;
        }
        pub type GCSliceCallback = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                progress: root::JS::GCProgress,
                desc: *const root::JS::GCDescription,
            ),
        >;
        extern "C" {
            #[doc = " The GC slice callback is called at the beginning and end of each slice. This"]
            #[doc = " callback may be used for GC notifications as well as to perform additional"]
            #[doc = " marking."]
            #[link_name = "\u{1}_ZN2JS18SetGCSliceCallbackEP9JSContextPFvS1_NS_10GCProgressERKNS_13GCDescriptionEE"]
            pub fn SetGCSliceCallback(
                cx: *mut root::JSContext,
                callback: root::JS::GCSliceCallback,
            ) -> root::JS::GCSliceCallback;
        }
        #[repr(i32)]
        #[doc = " Describes the progress of an observed nursery collection."]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum GCNurseryProgress {
            #[doc = " The nursery collection is starting."]
            GC_NURSERY_COLLECTION_START = 0,
            #[doc = " The nursery collection is ending."]
            GC_NURSERY_COLLECTION_END = 1,
        }
        #[doc = " A nursery collection callback receives the progress of the nursery collection"]
        #[doc = " and the reason for the collection."]
        pub type GCNurseryCollectionCallback = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                progress: root::JS::GCNurseryProgress,
                reason: root::JS::GCReason,
            ),
        >;
        extern "C" {
            #[doc = " Set the nursery collection callback for the given runtime. When set, it will"]
            #[doc = " be called at the start and end of every nursery collection."]
            #[link_name = "\u{1}_ZN2JS30SetGCNurseryCollectionCallbackEP9JSContextPFvS1_NS_17GCNurseryProgressENS_8GCReasonEE"]
            pub fn SetGCNurseryCollectionCallback(
                cx: *mut root::JSContext,
                callback: root::JS::GCNurseryCollectionCallback,
            ) -> root::JS::GCNurseryCollectionCallback;
        }
        pub type DoCycleCollectionCallback =
            ::std::option::Option<unsafe extern "C" fn(cx: *mut root::JSContext)>;
        extern "C" {
            #[doc = " The purge gray callback is called after any COMPARTMENT_REVIVED GC in which"]
            #[doc = " the majority of compartments have been marked gray."]
            #[link_name = "\u{1}_ZN2JS28SetDoCycleCollectionCallbackEP9JSContextPFvS1_E"]
            pub fn SetDoCycleCollectionCallback(
                cx: *mut root::JSContext,
                callback: root::JS::DoCycleCollectionCallback,
            ) -> root::JS::DoCycleCollectionCallback;
        }
        extern "C" {
            #[doc = " Incremental GC defaults to enabled, but may be disabled for testing or in"]
            #[doc = " embeddings that have not yet implemented barriers on their native classes."]
            #[doc = " There is not currently a way to re-enable incremental GC once it has been"]
            #[doc = " disabled on the runtime."]
            #[link_name = "\u{1}_ZN2JS20DisableIncrementalGCEP9JSContext"]
            pub fn DisableIncrementalGC(cx: *mut root::JSContext);
        }
        extern "C" {
            #[doc = " Returns true if incremental GC is enabled. Simply having incremental GC"]
            #[doc = " enabled is not sufficient to ensure incremental collections are happening."]
            #[doc = " See the comment \"Incremental GC\" above for reasons why incremental GC may be"]
            #[doc = " suppressed. Inspection of the \"nonincremental reason\" field of the"]
            #[doc = " GCDescription returned by GCSliceCallback may help narrow down the cause if"]
            #[doc = " collections are not happening incrementally when expected."]
            #[link_name = "\u{1}_ZN2JS22IsIncrementalGCEnabledEP9JSContext"]
            pub fn IsIncrementalGCEnabled(cx: *mut root::JSContext) -> bool;
        }
        extern "C" {
            #[doc = " Returns true while an incremental GC is ongoing, both when actively"]
            #[doc = " collecting and between slices."]
            #[link_name = "\u{1}_ZN2JS25IsIncrementalGCInProgressEP9JSContext"]
            pub fn IsIncrementalGCInProgress(cx: *mut root::JSContext) -> bool;
        }
        extern "C" {
            #[doc = " Returns true while an incremental GC is ongoing, both when actively"]
            #[doc = " collecting and between slices."]
            #[link_name = "\u{1}_ZN2JS25IsIncrementalGCInProgressEP9JSRuntime"]
            pub fn IsIncrementalGCInProgress1(rt: *mut root::JSRuntime) -> bool;
        }
        extern "C" {
            #[doc = " Returns true if the most recent GC ran incrementally."]
            #[link_name = "\u{1}_ZN2JS16WasIncrementalGCEP9JSRuntime"]
            pub fn WasIncrementalGC(rt: *mut root::JSRuntime) -> bool;
        }
        #[doc = " Ensure that generational GC is disabled within some scope."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoDisableGenerationalGC {
            pub cx: *mut root::JSContext,
        }
        #[test]
        fn bindgen_test_layout_AutoDisableGenerationalGC() {
            assert_eq!(
                ::std::mem::size_of::<AutoDisableGenerationalGC>(),
                8usize,
                concat!("Size of: ", stringify!(AutoDisableGenerationalGC))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoDisableGenerationalGC>(),
                8usize,
                concat!("Alignment of ", stringify!(AutoDisableGenerationalGC))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AutoDisableGenerationalGC>())).cx as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoDisableGenerationalGC),
                    "::",
                    stringify!(cx)
                )
            );
        }
        extern "C" {
            #[doc = " Returns true if generational allocation and collection is currently enabled"]
            #[doc = " on the given runtime."]
            #[link_name = "\u{1}_ZN2JS23IsGenerationalGCEnabledEP9JSRuntime"]
            pub fn IsGenerationalGCEnabled(rt: *mut root::JSRuntime) -> bool;
        }
        #[doc = " Pass a subclass of this \"abstract\" class to callees to require that they"]
        #[doc = " never GC. Subclasses can use assertions or the hazard analysis to ensure no"]
        #[doc = " GC happens."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoRequireNoGC {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_AutoRequireNoGC() {
            assert_eq!(
                ::std::mem::size_of::<AutoRequireNoGC>(),
                1usize,
                concat!("Size of: ", stringify!(AutoRequireNoGC))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoRequireNoGC>(),
                1usize,
                concat!("Alignment of ", stringify!(AutoRequireNoGC))
            );
        }
        #[doc = " Diagnostic assert (see MOZ_DIAGNOSTIC_ASSERT) that GC cannot occur while this"]
        #[doc = " class is live. This class does not disable the static rooting hazard"]
        #[doc = " analysis."]
        #[doc = ""]
        #[doc = " This works by entering a GC unsafe region, which is checked on allocation and"]
        #[doc = " on GC."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoAssertNoGC {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_AutoAssertNoGC() {
            assert_eq!(
                ::std::mem::size_of::<AutoAssertNoGC>(),
                1usize,
                concat!("Size of: ", stringify!(AutoAssertNoGC))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoAssertNoGC>(),
                1usize,
                concat!("Alignment of ", stringify!(AutoAssertNoGC))
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoSuppressGCAnalysis {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_AutoSuppressGCAnalysis() {
            assert_eq!(
                ::std::mem::size_of::<AutoSuppressGCAnalysis>(),
                1usize,
                concat!("Size of: ", stringify!(AutoSuppressGCAnalysis))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoSuppressGCAnalysis>(),
                1usize,
                concat!("Alignment of ", stringify!(AutoSuppressGCAnalysis))
            );
        }
        #[doc = " Assert that code is only ever called from a GC callback, disable the static"]
        #[doc = " rooting hazard analysis and assert if any allocation that could potentially"]
        #[doc = " trigger a GC occurs while this guard object is live."]
        #[doc = ""]
        #[doc = " This is useful to make the static analysis ignore code that runs in GC"]
        #[doc = " callbacks."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoAssertGCCallback {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_AutoAssertGCCallback() {
            assert_eq!(
                ::std::mem::size_of::<AutoAssertGCCallback>(),
                1usize,
                concat!("Size of: ", stringify!(AutoAssertGCCallback))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoAssertGCCallback>(),
                1usize,
                concat!("Alignment of ", stringify!(AutoAssertGCCallback))
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoCheckCannotGC {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_AutoCheckCannotGC() {
            assert_eq!(
                ::std::mem::size_of::<AutoCheckCannotGC>(),
                1usize,
                concat!("Size of: ", stringify!(AutoCheckCannotGC))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoCheckCannotGC>(),
                1usize,
                concat!("Alignment of ", stringify!(AutoCheckCannotGC))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17SetLowMemoryStateEP9JSContextb"]
            pub fn SetLowMemoryState(cx: *mut root::JSContext, newState: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20NotifyGCRootsRemovedEP9JSContext"]
            pub fn NotifyGCRootsRemoved(cx: *mut root::JSContext);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18IsIdleGCTaskNeededEP9JSRuntime"]
            pub fn IsIdleGCTaskNeeded(rt: *mut root::JSRuntime) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17RunIdleTimeGCTaskEP9JSRuntime"]
            pub fn RunIdleTimeGCTask(rt: *mut root::JSRuntime);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS39SetHostCleanupFinalizationGroupCallbackEP9JSContextPFvP8JSObjectPvES4_"]
            pub fn SetHostCleanupFinalizationGroupCallback(
                cx: *mut root::JSContext,
                cb: root::JSHostCleanupFinalizationGroupCallback,
                data: *mut ::std::os::raw::c_void,
            );
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ValueType {
            Double = 0,
            Int32 = 1,
            Boolean = 2,
            Undefined = 3,
            Null = 4,
            Magic = 5,
            String = 6,
            Symbol = 7,
            PrivateGCThing = 8,
            BigInt = 9,
            Object = 12,
        }
        #[doc = " [SMDOC] JS::Value type"]
        #[doc = ""]
        #[doc = " JS::Value is the interface for a single JavaScript Engine value.  A few"]
        #[doc = " general notes on JS::Value:"]
        #[doc = ""]
        #[doc = " - JS::Value has setX() and isX() members for X in"]
        #[doc = ""]
        #[doc = "     { Int32, Double, String, Symbol, BigInt, Boolean, Undefined, Null,"]
        #[doc = "       Object, Magic }"]
        #[doc = ""]
        #[doc = "   JS::Value also contains toX() for each of the non-singleton types."]
        #[doc = ""]
        #[doc = " - Magic is a singleton type whose payload contains either a JSWhyMagic"]
        #[doc = "   \"reason\" for the magic value or a uint32_t value. By providing JSWhyMagic"]
        #[doc = "   values when creating and checking for magic values, it is possible to"]
        #[doc = "   assert, at runtime, that only magic values with the expected reason flow"]
        #[doc = "   through a particular value. For example, if cx->exception has a magic"]
        #[doc = "   value, the reason must be JS_GENERATOR_CLOSING."]
        #[doc = ""]
        #[doc = " - The JS::Value operations are preferred.  The JSVAL_* operations remain for"]
        #[doc = "   compatibility; they may be removed at some point.  These operations mostly"]
        #[doc = "   provide similar functionality.  But there are a few key differences.  One"]
        #[doc = "   is that JS::Value gives null a separate type."]
        #[doc = "   Also, to help prevent mistakenly boxing a nullable JSObject* as an object,"]
        #[doc = "   Value::setObject takes a JSObject&. (Conversely, Value::toObject returns a"]
        #[doc = "   JSObject&.)  A convenience member Value::setObjectOrNull is provided."]
        #[doc = ""]
        #[doc = " - Note that JS::Value is 8 bytes on 32 and 64-bit architectures. Thus, on"]
        #[doc = "   32-bit user code should avoid copying jsval/JS::Value as much as possible,"]
        #[doc = "   preferring to pass by const Value&."]
        #[doc = ""]
        #[doc = " Spectre mitigations"]
        #[doc = " ==================="]
        #[doc = " To mitigate Spectre attacks, we do the following:"]
        #[doc = ""]
        #[doc = " - On 64-bit platforms, when unboxing a Value, we XOR the bits with the"]
        #[doc = "   expected type tag (instead of masking the payload bits). This guarantees"]
        #[doc = "   that toString, toObject, toSymbol will return an invalid pointer (because"]
        #[doc = "   some high bits will be set) when called on a Value with a different type"]
        #[doc = "   tag."]
        #[doc = ""]
        #[doc = " - On 32-bit platforms,when unboxing an object/string/symbol Value, we use a"]
        #[doc = "   conditional move (not speculated) to zero the payload register if the type"]
        #[doc = "   doesn't match."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Value {
            pub asBits_: u64,
        }
        pub type Value_PayloadType = u64;
        #[test]
        fn bindgen_test_layout_Value() {
            assert_eq!(
                ::std::mem::size_of::<Value>(),
                8usize,
                concat!("Size of: ", stringify!(Value))
            );
            assert_eq!(
                ::std::mem::align_of::<Value>(),
                8usize,
                concat!("Alignment of ", stringify!(Value))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Value>())).asBits_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Value),
                    "::",
                    stringify!(asBits_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS25HeapValuePostWriteBarrierEPNS_5ValueERKS0_S3_"]
            pub fn HeapValuePostWriteBarrier(
                valuep: *mut root::JS::Value,
                prev: *const root::JS::Value,
                next: *const root::JS::Value,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS22HeapValueWriteBarriersEPNS_5ValueERKS0_S3_"]
            pub fn HeapValueWriteBarriers(
                valuep: *mut root::JS::Value,
                prev: *const root::JS::Value,
                next: *const root::JS::Value,
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_Value_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15NullHandleValueE"]
            pub static NullHandleValue: root::JS::HandleValue;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20UndefinedHandleValueE"]
            pub static UndefinedHandleValue: root::JS::HandleValue;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15TrueHandleValueE"]
            pub static TrueHandleValue: root::JS::HandleValue;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Latin1Chars {
            pub _base: root::mozilla::Range<root::JS::Latin1Char>,
        }
        pub type Latin1Chars_Base = root::mozilla::Range<root::JS::Latin1Char>;
        pub type Latin1Chars_CharT = root::JS::Latin1Char;
        #[test]
        fn bindgen_test_layout_Latin1Chars() {
            assert_eq!(
                ::std::mem::size_of::<Latin1Chars>(),
                16usize,
                concat!("Size of: ", stringify!(Latin1Chars))
            );
            assert_eq!(
                ::std::mem::align_of::<Latin1Chars>(),
                8usize,
                concat!("Alignment of ", stringify!(Latin1Chars))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Latin1CharsZ {
            pub _base: root::mozilla::RangedPtr<root::JS::Latin1Char>,
        }
        pub type Latin1CharsZ_Base = root::mozilla::RangedPtr<root::JS::Latin1Char>;
        pub type Latin1CharsZ_CharT = root::JS::Latin1Char;
        #[test]
        fn bindgen_test_layout_Latin1CharsZ() {
            assert_eq!(
                ::std::mem::size_of::<Latin1CharsZ>(),
                8usize,
                concat!("Size of: ", stringify!(Latin1CharsZ))
            );
            assert_eq!(
                ::std::mem::align_of::<Latin1CharsZ>(),
                8usize,
                concat!("Alignment of ", stringify!(Latin1CharsZ))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct UTF8Chars {
            pub _base: root::mozilla::Range<::std::os::raw::c_uchar>,
        }
        pub type UTF8Chars_Base = root::mozilla::Range<::std::os::raw::c_uchar>;
        pub type UTF8Chars_CharT = ::std::os::raw::c_uchar;
        #[test]
        fn bindgen_test_layout_UTF8Chars() {
            assert_eq!(
                ::std::mem::size_of::<UTF8Chars>(),
                16usize,
                concat!("Size of: ", stringify!(UTF8Chars))
            );
            assert_eq!(
                ::std::mem::align_of::<UTF8Chars>(),
                8usize,
                concat!("Alignment of ", stringify!(UTF8Chars))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct WTF8Chars {
            pub _base: root::mozilla::Range<::std::os::raw::c_uchar>,
        }
        pub type WTF8Chars_Base = root::mozilla::Range<::std::os::raw::c_uchar>;
        pub type WTF8Chars_CharT = ::std::os::raw::c_uchar;
        #[test]
        fn bindgen_test_layout_WTF8Chars() {
            assert_eq!(
                ::std::mem::size_of::<WTF8Chars>(),
                16usize,
                concat!("Size of: ", stringify!(WTF8Chars))
            );
            assert_eq!(
                ::std::mem::align_of::<WTF8Chars>(),
                8usize,
                concat!("Alignment of ", stringify!(WTF8Chars))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct UTF8CharsZ {
            pub _base: root::mozilla::RangedPtr<::std::os::raw::c_uchar>,
        }
        pub type UTF8CharsZ_Base = root::mozilla::RangedPtr<::std::os::raw::c_uchar>;
        pub type UTF8CharsZ_CharT = ::std::os::raw::c_uchar;
        #[test]
        fn bindgen_test_layout_UTF8CharsZ() {
            assert_eq!(
                ::std::mem::size_of::<UTF8CharsZ>(),
                8usize,
                concat!("Size of: ", stringify!(UTF8CharsZ))
            );
            assert_eq!(
                ::std::mem::align_of::<UTF8CharsZ>(),
                8usize,
                concat!("Alignment of ", stringify!(UTF8CharsZ))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ConstUTF8CharsZ {
            pub data_: *const ::std::os::raw::c_char,
        }
        pub type ConstUTF8CharsZ_CharT = ::std::os::raw::c_uchar;
        #[test]
        fn bindgen_test_layout_ConstUTF8CharsZ() {
            assert_eq!(
                ::std::mem::size_of::<ConstUTF8CharsZ>(),
                8usize,
                concat!("Size of: ", stringify!(ConstUTF8CharsZ))
            );
            assert_eq!(
                ::std::mem::align_of::<ConstUTF8CharsZ>(),
                8usize,
                concat!("Alignment of ", stringify!(ConstUTF8CharsZ))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ConstUTF8CharsZ>())).data_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ConstUTF8CharsZ),
                    "::",
                    stringify!(data_)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TwoByteChars {
            pub _base: root::mozilla::Range<u16>,
        }
        pub type TwoByteChars_Base = root::mozilla::Range<u16>;
        pub type TwoByteChars_CharT = u16;
        #[test]
        fn bindgen_test_layout_TwoByteChars() {
            assert_eq!(
                ::std::mem::size_of::<TwoByteChars>(),
                16usize,
                concat!("Size of: ", stringify!(TwoByteChars))
            );
            assert_eq!(
                ::std::mem::align_of::<TwoByteChars>(),
                8usize,
                concat!("Alignment of ", stringify!(TwoByteChars))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TwoByteCharsZ {
            pub _base: root::mozilla::RangedPtr<u16>,
        }
        pub type TwoByteCharsZ_Base = root::mozilla::RangedPtr<u16>;
        pub type TwoByteCharsZ_CharT = u16;
        #[test]
        fn bindgen_test_layout_TwoByteCharsZ() {
            assert_eq!(
                ::std::mem::size_of::<TwoByteCharsZ>(),
                8usize,
                concat!("Size of: ", stringify!(TwoByteCharsZ))
            );
            assert_eq!(
                ::std::mem::align_of::<TwoByteCharsZ>(),
                8usize,
                concat!("Alignment of ", stringify!(TwoByteCharsZ))
            );
        }
        pub type ConstCharPtr = root::mozilla::RangedPtr<u16>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ConstTwoByteChars {
            pub _base: root::mozilla::Range<u16>,
        }
        pub type ConstTwoByteChars_Base = root::mozilla::Range<u16>;
        pub type ConstTwoByteChars_CharT = u16;
        #[test]
        fn bindgen_test_layout_ConstTwoByteChars() {
            assert_eq!(
                ::std::mem::size_of::<ConstTwoByteChars>(),
                16usize,
                concat!("Size of: ", stringify!(ConstTwoByteChars))
            );
            assert_eq!(
                ::std::mem::align_of::<ConstTwoByteChars>(),
                8usize,
                concat!("Alignment of ", stringify!(ConstTwoByteChars))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS34LossyTwoByteCharsToNewLatin1CharsZEP9JSContextN7mozilla5RangeIKDsEE"]
            pub fn LossyTwoByteCharsToNewLatin1CharsZ(
                cx: *mut root::JSContext,
                tbchars: root::mozilla::Range<u16>,
            ) -> root::JS::Latin1CharsZ;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17Utf8ToOneUcs4CharEPKhi"]
            pub fn Utf8ToOneUcs4Char(
                utf8Buffer: *const u8,
                utf8Length: ::std::os::raw::c_int,
            ) -> u32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS27UTF8CharsToNewTwoByteCharsZEP9JSContextNS_9UTF8CharsEPmm"]
            pub fn UTF8CharsToNewTwoByteCharsZ(
                cx: *mut root::JSContext,
                utf8: root::JS::UTF8Chars,
                outlen: *mut usize,
                destArenaId: root::arena_id_t,
            ) -> root::JS::TwoByteCharsZ;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS27WTF8CharsToNewTwoByteCharsZEP9JSContextNS_9WTF8CharsEPmm"]
            pub fn WTF8CharsToNewTwoByteCharsZ(
                cx: *mut root::JSContext,
                wtf8: root::JS::WTF8Chars,
                outlen: *mut usize,
                destArenaId: root::arena_id_t,
            ) -> root::JS::TwoByteCharsZ;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS27UTF8CharsToNewTwoByteCharsZEP9JSContextRKNS_15ConstUTF8CharsZEPmm"]
            pub fn UTF8CharsToNewTwoByteCharsZ1(
                cx: *mut root::JSContext,
                utf8: *const root::JS::ConstUTF8CharsZ,
                outlen: *mut usize,
                destArenaId: root::arena_id_t,
            ) -> root::JS::TwoByteCharsZ;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS32LossyUTF8CharsToNewTwoByteCharsZEP9JSContextNS_9UTF8CharsEPmm"]
            pub fn LossyUTF8CharsToNewTwoByteCharsZ(
                cx: *mut root::JSContext,
                utf8: root::JS::UTF8Chars,
                outlen: *mut usize,
                destArenaId: root::arena_id_t,
            ) -> root::JS::TwoByteCharsZ;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS32LossyUTF8CharsToNewTwoByteCharsZEP9JSContextRKNS_15ConstUTF8CharsZEPmm"]
            pub fn LossyUTF8CharsToNewTwoByteCharsZ1(
                cx: *mut root::JSContext,
                utf8: *const root::JS::ConstUTF8CharsZ,
                outlen: *mut usize,
                destArenaId: root::arena_id_t,
            ) -> root::JS::TwoByteCharsZ;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS27GetDeflatedUTF8StringLengthEP14JSLinearString"]
            pub fn GetDeflatedUTF8StringLength(s: *mut root::JSLinearString) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS25DeflateStringToUTF8BufferEP14JSLinearStringN7mozilla4SpanIcLm18446744073709551615EEE"]
            pub fn DeflateStringToUTF8Buffer(
                src: *mut root::JSLinearString,
                dst: [u64; 2usize],
            ) -> usize;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum SmallestEncoding {
            ASCII = 0,
            Latin1 = 1,
            UTF16 = 2,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20FindSmallestEncodingENS_9UTF8CharsE"]
            pub fn FindSmallestEncoding(utf8: root::JS::UTF8Chars) -> root::JS::SmallestEncoding;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS26UTF8CharsToNewLatin1CharsZEP9JSContextNS_9UTF8CharsEPmm"]
            pub fn UTF8CharsToNewLatin1CharsZ(
                cx: *mut root::JSContext,
                utf8: root::JS::UTF8Chars,
                outlen: *mut usize,
                destArenaId: root::arena_id_t,
            ) -> root::JS::Latin1CharsZ;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS31LossyUTF8CharsToNewLatin1CharsZEP9JSContextNS_9UTF8CharsEPmm"]
            pub fn LossyUTF8CharsToNewLatin1CharsZ(
                cx: *mut root::JSContext,
                utf8: root::JS::UTF8Chars,
                outlen: *mut usize,
                destArenaId: root::arena_id_t,
            ) -> root::JS::Latin1CharsZ;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13StringIsASCIIEPKc"]
            pub fn StringIsASCII(s: *const ::std::os::raw::c_char) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13StringIsASCIIEN7mozilla4SpanIKcLm18446744073709551615EEE"]
            pub fn StringIsASCII1(s: [u64; 2usize]) -> bool;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PropertyKey {
            pub asBits: usize,
        }
        #[test]
        fn bindgen_test_layout_PropertyKey() {
            assert_eq!(
                ::std::mem::size_of::<PropertyKey>(),
                8usize,
                concat!("Size of: ", stringify!(PropertyKey))
            );
            assert_eq!(
                ::std::mem::align_of::<PropertyKey>(),
                8usize,
                concat!("Alignment of ", stringify!(PropertyKey))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<PropertyKey>())).asBits as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PropertyKey),
                    "::",
                    stringify!(asBits)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_PropertyKey_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
        #[repr(i32)]
        #[doc = " The answer to a successful query as to whether an object is an Array per"]
        #[doc = " ES6's internal |IsArray| operation (as exposed by |Array.isArray|)."]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum IsArrayAnswer {
            Array = 0,
            NotArray = 1,
            RevokedProxy = 2,
        }
        extern "C" {
            #[doc = " ES6 7.2.2."]
            #[doc = ""]
            #[doc = " Returns false on failure, otherwise returns true and sets |*isArray|"]
            #[doc = " indicating whether the object passes ECMAScript's IsArray test.  This is the"]
            #[doc = " same test performed by |Array.isArray|."]
            #[doc = ""]
            #[doc = " This is NOT the same as asking whether |obj| is an Array or a wrapper around"]
            #[doc = " one.  If |obj| is a proxy created by |Proxy.revocable()| and has been"]
            #[doc = " revoked, or if |obj| is a proxy whose target (at any number of hops) is a"]
            #[doc = " revoked proxy, this method throws a TypeError and returns false."]
            #[link_name = "\u{1}_ZN2JS7IsArrayEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn IsArray(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                isArray: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Identical to IsArray above, but the nature of the object (if successfully"]
            #[doc = " determined) is communicated via |*answer|.  In particular this method"]
            #[doc = " returns true and sets |*answer = IsArrayAnswer::RevokedProxy| when called on"]
            #[doc = " a revoked proxy."]
            #[doc = ""]
            #[doc = " Most users will want the overload above, not this one."]
            #[link_name = "\u{1}_ZN2JS7IsArrayEP9JSContextNS_6HandleIP8JSObjectEEPNS_13IsArrayAnswerE"]
            pub fn IsArray1(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                answer: *mut root::JS::IsArrayAnswer,
            ) -> bool;
        }
        #[doc = " Per ES6, the [[DefineOwnProperty]] internal method has three different"]
        #[doc = " possible outcomes:"]
        #[doc = ""]
        #[doc = " -   It can throw an exception (which we indicate by returning false)."]
        #[doc = ""]
        #[doc = " -   It can return true, indicating unvarnished success."]
        #[doc = ""]
        #[doc = " -   It can return false, indicating \"strict failure\". The property could"]
        #[doc = "     not be defined. It's an error, but no exception was thrown."]
        #[doc = ""]
        #[doc = " It's not just [[DefineOwnProperty]]: all the mutating internal methods have"]
        #[doc = " the same three outcomes. (The other affected internal methods are [[Set]],"]
        #[doc = " [[Delete]], [[SetPrototypeOf]], and [[PreventExtensions]].)"]
        #[doc = ""]
        #[doc = " If you think this design is awful, you're not alone.  But as it's the"]
        #[doc = " standard, we must represent these boolean \"success\" values somehow."]
        #[doc = " ObjectOpSuccess is the class for this. It's like a bool, but when it's false"]
        #[doc = " it also stores an error code."]
        #[doc = ""]
        #[doc = " Typical usage:"]
        #[doc = ""]
        #[doc = "     ObjectOpResult result;"]
        #[doc = "     if (!DefineProperty(cx, obj, id, ..., result)) {"]
        #[doc = "         return false;"]
        #[doc = "     }"]
        #[doc = "     if (!result) {"]
        #[doc = "         return result.reportError(cx, obj, id);"]
        #[doc = "     }"]
        #[doc = ""]
        #[doc = " Users don't have to call `result.report()`; another possible ending is:"]
        #[doc = ""]
        #[doc = "     argv.rval().setBoolean(result.reallyOk());"]
        #[doc = "     return true;"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ObjectOpResult {
            #[doc = " code_ is either one of the special codes OkCode or Uninitialized, or"]
            #[doc = " an error code. For now the error codes are private to the JS engine;"]
            #[doc = " they're defined in js/src/js.msg."]
            #[doc = ""]
            #[doc = " code_ is uintptr_t (rather than uint32_t) for the convenience of the"]
            #[doc = " JITs, which would otherwise have to deal with either padding or stack"]
            #[doc = " alignment on 64-bit platforms."]
            pub code_: usize,
        }
        #[repr(u64)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ObjectOpResult_SpecialCodes {
            OkCode = 0,
            Uninitialized = 18446744073709551615,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS14ObjectOpResult11SoftFailBitE"]
            pub static ObjectOpResult_SoftFailBit: usize;
        }
        #[test]
        fn bindgen_test_layout_ObjectOpResult() {
            assert_eq!(
                ::std::mem::size_of::<ObjectOpResult>(),
                8usize,
                concat!("Size of: ", stringify!(ObjectOpResult))
            );
            assert_eq!(
                ::std::mem::align_of::<ObjectOpResult>(),
                8usize,
                concat!("Alignment of ", stringify!(ObjectOpResult))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ObjectOpResult>())).code_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ObjectOpResult),
                    "::",
                    stringify!(code_)
                )
            );
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct PropertyResult {
            pub __bindgen_anon_1: root::JS::PropertyResult__bindgen_ty_1,
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union PropertyResult__bindgen_ty_1 {
            pub shape_: *mut root::js::Shape,
            pub bits_: usize,
            _bindgen_union_align: u64,
        }
        #[test]
        fn bindgen_test_layout_PropertyResult__bindgen_ty_1() {
            assert_eq!(
                ::std::mem::size_of::<PropertyResult__bindgen_ty_1>(),
                8usize,
                concat!("Size of: ", stringify!(PropertyResult__bindgen_ty_1))
            );
            assert_eq!(
                ::std::mem::align_of::<PropertyResult__bindgen_ty_1>(),
                8usize,
                concat!("Alignment of ", stringify!(PropertyResult__bindgen_ty_1))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<PropertyResult__bindgen_ty_1>())).shape_ as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PropertyResult__bindgen_ty_1),
                    "::",
                    stringify!(shape_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<PropertyResult__bindgen_ty_1>())).bits_ as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PropertyResult__bindgen_ty_1),
                    "::",
                    stringify!(bits_)
                )
            );
        }
        pub const PropertyResult_NotFound: usize = 0;
        pub const PropertyResult_NonNativeProperty: usize = 1;
        pub const PropertyResult_DenseOrTypedArrayElement: usize = 1;
        #[test]
        fn bindgen_test_layout_PropertyResult() {
            assert_eq!(
                ::std::mem::size_of::<PropertyResult>(),
                8usize,
                concat!("Size of: ", stringify!(PropertyResult))
            );
            assert_eq!(
                ::std::mem::align_of::<PropertyResult>(),
                8usize,
                concat!("Alignment of ", stringify!(PropertyResult))
            );
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum AsmJSOption {
            Enabled = 0,
            Disabled = 1,
            DisabledByDebugger = 2,
        }
        #[repr(C)]
        pub struct TransitiveCompileOptions__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " The common base class for the CompileOptions hierarchy."]
        #[doc = ""]
        #[doc = " Use this in code that needs to propagate compile options from one"]
        #[doc = " compilation unit to another."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TransitiveCompileOptions {
            pub vtable_: *const TransitiveCompileOptions__bindgen_vtable,
            #[doc = " The Web Platform allows scripts to be loaded from arbitrary cross-origin"]
            #[doc = " sources. This allows an attack by which a malicious website loads a"]
            #[doc = " sensitive file (say, a bank statement) cross-origin (using the user's"]
            #[doc = " cookies), and sniffs the generated syntax errors (via a window.onerror"]
            #[doc = " handler) for juicy morsels of its contents."]
            #[doc = ""]
            #[doc = " To counter this attack, HTML5 specifies that script errors should be"]
            #[doc = " sanitized (\"muted\") when the script is not same-origin with the global"]
            #[doc = " for which it is loaded. Callers should set this flag for cross-origin"]
            #[doc = " scripts, and it will be propagated appropriately to child scripts and"]
            #[doc = " passed back in JSErrorReports."]
            pub mutedErrors_: bool,
            pub forceFullParse_: bool,
            pub forceStrictMode_: bool,
            pub filename_: *const ::std::os::raw::c_char,
            pub introducerFilename_: *const ::std::os::raw::c_char,
            pub sourceMapURL_: *const u16,
            pub selfHostingMode: bool,
            pub extraWarningsOption: bool,
            pub werrorOption: bool,
            pub asmJSOption: root::JS::AsmJSOption,
            pub throwOnAsmJSValidationFailureOption: bool,
            pub forceAsync: bool,
            pub discardSource: bool,
            pub sourceIsLazy: bool,
            pub allowHTMLComments: bool,
            pub hideScriptFromDebugger: bool,
            pub fieldsEnabledOption: bool,
            #[doc = " |introductionType| is a statically allocated C string: one of \"eval\","]
            #[doc = " \"Function\", or \"GeneratorFunction\"."]
            pub introductionType: *const ::std::os::raw::c_char,
            pub introductionLineno: ::std::os::raw::c_uint,
            pub introductionOffset: u32,
            pub hasIntroductionInfo: bool,
            pub instrumentationKinds: u32,
        }
        #[test]
        fn bindgen_test_layout_TransitiveCompileOptions() {
            assert_eq!(
                ::std::mem::size_of::<TransitiveCompileOptions>(),
                80usize,
                concat!("Size of: ", stringify!(TransitiveCompileOptions))
            );
            assert_eq!(
                ::std::mem::align_of::<TransitiveCompileOptions>(),
                8usize,
                concat!("Alignment of ", stringify!(TransitiveCompileOptions))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TransitiveCompileOptions>())).mutedErrors_ as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(mutedErrors_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TransitiveCompileOptions>())).forceFullParse_ as *const _
                        as usize
                },
                9usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(forceFullParse_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TransitiveCompileOptions>())).forceStrictMode_
                        as *const _ as usize
                },
                10usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(forceStrictMode_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TransitiveCompileOptions>())).filename_ as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(filename_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TransitiveCompileOptions>())).introducerFilename_
                        as *const _ as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(introducerFilename_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TransitiveCompileOptions>())).sourceMapURL_ as *const _
                        as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(sourceMapURL_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TransitiveCompileOptions>())).selfHostingMode as *const _
                        as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(selfHostingMode)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TransitiveCompileOptions>())).extraWarningsOption
                        as *const _ as usize
                },
                41usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(extraWarningsOption)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TransitiveCompileOptions>())).werrorOption as *const _
                        as usize
                },
                42usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(werrorOption)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TransitiveCompileOptions>())).asmJSOption as *const _
                        as usize
                },
                43usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(asmJSOption)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TransitiveCompileOptions>()))
                        .throwOnAsmJSValidationFailureOption as *const _
                        as usize
                },
                44usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(throwOnAsmJSValidationFailureOption)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TransitiveCompileOptions>())).forceAsync as *const _
                        as usize
                },
                45usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(forceAsync)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TransitiveCompileOptions>())).discardSource as *const _
                        as usize
                },
                46usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(discardSource)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TransitiveCompileOptions>())).sourceIsLazy as *const _
                        as usize
                },
                47usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(sourceIsLazy)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TransitiveCompileOptions>())).allowHTMLComments
                        as *const _ as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(allowHTMLComments)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TransitiveCompileOptions>())).hideScriptFromDebugger
                        as *const _ as usize
                },
                49usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(hideScriptFromDebugger)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TransitiveCompileOptions>())).fieldsEnabledOption
                        as *const _ as usize
                },
                50usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(fieldsEnabledOption)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TransitiveCompileOptions>())).introductionType
                        as *const _ as usize
                },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(introductionType)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TransitiveCompileOptions>())).introductionLineno
                        as *const _ as usize
                },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(introductionLineno)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TransitiveCompileOptions>())).introductionOffset
                        as *const _ as usize
                },
                68usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(introductionOffset)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TransitiveCompileOptions>())).hasIntroductionInfo
                        as *const _ as usize
                },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(hasIntroductionInfo)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TransitiveCompileOptions>())).instrumentationKinds
                        as *const _ as usize
                },
                76usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TransitiveCompileOptions),
                    "::",
                    stringify!(instrumentationKinds)
                )
            );
        }
        #[doc = " The class representing a full set of compile options."]
        #[doc = ""]
        #[doc = " Use this in code that only needs to access compilation options created"]
        #[doc = " elsewhere, like the compiler.  Don't instantiate this class (the constructor"]
        #[doc = " is protected anyway); instead, create instances only of the derived classes:"]
        #[doc = " CompileOptions and OwningCompileOptions."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ReadOnlyCompileOptions {
            pub _base: root::JS::TransitiveCompileOptions,
            pub lineno: ::std::os::raw::c_uint,
            pub column: ::std::os::raw::c_uint,
            pub scriptSourceOffset: ::std::os::raw::c_uint,
            pub isRunOnce: bool,
            pub nonSyntacticScope: bool,
            pub noScriptRval: bool,
            pub skipFilenameValidation_: bool,
        }
        #[test]
        fn bindgen_test_layout_ReadOnlyCompileOptions() {
            assert_eq!(
                ::std::mem::size_of::<ReadOnlyCompileOptions>(),
                96usize,
                concat!("Size of: ", stringify!(ReadOnlyCompileOptions))
            );
            assert_eq!(
                ::std::mem::align_of::<ReadOnlyCompileOptions>(),
                8usize,
                concat!("Alignment of ", stringify!(ReadOnlyCompileOptions))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReadOnlyCompileOptions>())).lineno as *const _ as usize
                },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReadOnlyCompileOptions),
                    "::",
                    stringify!(lineno)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReadOnlyCompileOptions>())).column as *const _ as usize
                },
                84usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReadOnlyCompileOptions),
                    "::",
                    stringify!(column)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReadOnlyCompileOptions>())).scriptSourceOffset
                        as *const _ as usize
                },
                88usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReadOnlyCompileOptions),
                    "::",
                    stringify!(scriptSourceOffset)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReadOnlyCompileOptions>())).isRunOnce as *const _
                        as usize
                },
                92usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReadOnlyCompileOptions),
                    "::",
                    stringify!(isRunOnce)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReadOnlyCompileOptions>())).nonSyntacticScope as *const _
                        as usize
                },
                93usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReadOnlyCompileOptions),
                    "::",
                    stringify!(nonSyntacticScope)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReadOnlyCompileOptions>())).noScriptRval as *const _
                        as usize
                },
                94usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReadOnlyCompileOptions),
                    "::",
                    stringify!(noScriptRval)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ReadOnlyCompileOptions>())).skipFilenameValidation_
                        as *const _ as usize
                },
                95usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ReadOnlyCompileOptions),
                    "::",
                    stringify!(skipFilenameValidation_)
                )
            );
        }
        #[doc = " Compilation options, with dynamic lifetime. An instance of this type"]
        #[doc = " makes a copy of / holds / roots all dynamically allocated resources"]
        #[doc = " (principals; elements; strings) that it refers to. Its destructor frees"]
        #[doc = " / drops / unroots them. This is heavier than CompileOptions, below, but"]
        #[doc = " unlike CompileOptions, it can outlive any given stack frame."]
        #[doc = ""]
        #[doc = " Note that this *roots* any JS values it refers to - they're live"]
        #[doc = " unconditionally. Thus, instances of this type can't be owned, directly"]
        #[doc = " or indirectly, by a JavaScript object: if any value that this roots ever"]
        #[doc = " comes to refer to the object that owns this, then the whole cycle, and"]
        #[doc = " anything else it entrains, will never be freed."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct OwningCompileOptions {
            pub _base: root::JS::ReadOnlyCompileOptions,
            pub elementRoot: [u64; 4usize],
            pub elementAttributeNameRoot: [u64; 4usize],
            pub introductionScriptRoot: [u64; 4usize],
            pub scriptOrModuleRoot: [u64; 4usize],
        }
        #[test]
        fn bindgen_test_layout_OwningCompileOptions() {
            assert_eq!(
                ::std::mem::size_of::<OwningCompileOptions>(),
                224usize,
                concat!("Size of: ", stringify!(OwningCompileOptions))
            );
            assert_eq!(
                ::std::mem::align_of::<OwningCompileOptions>(),
                8usize,
                concat!("Alignment of ", stringify!(OwningCompileOptions))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<OwningCompileOptions>())).elementRoot as *const _
                        as usize
                },
                96usize,
                concat!(
                    "Offset of field: ",
                    stringify!(OwningCompileOptions),
                    "::",
                    stringify!(elementRoot)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<OwningCompileOptions>())).elementAttributeNameRoot
                        as *const _ as usize
                },
                128usize,
                concat!(
                    "Offset of field: ",
                    stringify!(OwningCompileOptions),
                    "::",
                    stringify!(elementAttributeNameRoot)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<OwningCompileOptions>())).introductionScriptRoot
                        as *const _ as usize
                },
                160usize,
                concat!(
                    "Offset of field: ",
                    stringify!(OwningCompileOptions),
                    "::",
                    stringify!(introductionScriptRoot)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<OwningCompileOptions>())).scriptOrModuleRoot as *const _
                        as usize
                },
                192usize,
                concat!(
                    "Offset of field: ",
                    stringify!(OwningCompileOptions),
                    "::",
                    stringify!(scriptOrModuleRoot)
                )
            );
        }
        #[doc = " Compilation options stored on the stack. An instance of this type"]
        #[doc = " simply holds references to dynamically allocated resources (element;"]
        #[doc = " filename; source map URL) that are owned by something else. If you"]
        #[doc = " create an instance of this type, it's up to you to guarantee that"]
        #[doc = " everything you store in it will outlive it."]
        #[repr(C)]
        pub struct CompileOptions {
            pub _base: root::JS::ReadOnlyCompileOptions,
            pub elementRoot: root::JS::Rooted<*mut root::JSObject>,
            pub elementAttributeNameRoot: root::JS::Rooted<*mut root::JSString>,
            pub introductionScriptRoot: root::JS::Rooted<*mut root::JSScript>,
            pub scriptOrModuleRoot: root::JS::Rooted<*mut root::JSScript>,
        }
        #[test]
        fn bindgen_test_layout_CompileOptions() {
            assert_eq!(
                ::std::mem::size_of::<CompileOptions>(),
                192usize,
                concat!("Size of: ", stringify!(CompileOptions))
            );
            assert_eq!(
                ::std::mem::align_of::<CompileOptions>(),
                8usize,
                concat!("Alignment of ", stringify!(CompileOptions))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<CompileOptions>())).elementRoot as *const _ as usize
                },
                96usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CompileOptions),
                    "::",
                    stringify!(elementRoot)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<CompileOptions>())).elementAttributeNameRoot as *const _
                        as usize
                },
                120usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CompileOptions),
                    "::",
                    stringify!(elementAttributeNameRoot)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<CompileOptions>())).introductionScriptRoot as *const _
                        as usize
                },
                144usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CompileOptions),
                    "::",
                    stringify!(introductionScriptRoot)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<CompileOptions>())).scriptOrModuleRoot as *const _
                        as usize
                },
                168usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CompileOptions),
                    "::",
                    stringify!(scriptOrModuleRoot)
                )
            );
        }
        pub type GCVector_ElementType<T> = T;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct StackGCVector {
            pub _address: u8,
        }
        pub type StackGCVector_Base = u8;
        pub type RootedVector_Vec = u8;
        pub type RootedVector_Base = root::JS::Rooted<root::JS::RootedVector_Vec>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PersistentRootedVector {
            pub _address: u8,
        }
        pub type PersistentRootedVector_Vec = u8;
        pub type PersistentRootedVector_Base = u8;
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum MemoryUse {
            XPCWrappedNative = 0,
            DOMBinding = 1,
            CTypeFFIType = 2,
            CTypeFFITypeElements = 3,
            CTypeFunctionInfo = 4,
            CTypeFieldInfo = 5,
            CDataBufferPtr = 6,
            CDataBuffer = 7,
            CClosureInfo = 8,
            CTypesInt64 = 9,
            PerfMeasurement = 10,
            Embedding1 = 11,
            Embedding2 = 12,
            Embedding3 = 13,
            Embedding4 = 14,
            Embedding5 = 15,
        }
        extern "C" {
            #[doc = " Advise the GC of external memory owned by a JSObject. This is used to"]
            #[doc = " determine when to collect zones. Calls must be matched by calls to"]
            #[doc = " RemoveAssociatedMemory() when the memory is deallocated or no longer owned by"]
            #[doc = " the object."]
            #[link_name = "\u{1}_ZN2JS19AddAssociatedMemoryEP8JSObjectmNS_9MemoryUseE"]
            pub fn AddAssociatedMemory(
                obj: *mut root::JSObject,
                nbytes: usize,
                use_: root::JS::MemoryUse,
            );
        }
        extern "C" {
            #[doc = " Advise the GC that external memory reported by JS::AddAssociatedMemory() is"]
            #[doc = " no longer owned by a JSObject. Calls must match those to"]
            #[doc = " AddAssociatedMemory()."]
            #[link_name = "\u{1}_ZN2JS22RemoveAssociatedMemoryEP8JSObjectmNS_9MemoryUseE"]
            pub fn RemoveAssociatedMemory(
                obj: *mut root::JSObject,
                nbytes: usize,
                use_: root::JS::MemoryUse,
            );
        }
        pub type TranscodeBuffer = u8;
        pub type TranscodeRange = root::mozilla::Range<u8>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TranscodeSource {
            pub range: root::JS::TranscodeRange,
            pub filename: *const ::std::os::raw::c_char,
            pub lineno: u32,
        }
        #[test]
        fn bindgen_test_layout_TranscodeSource() {
            assert_eq!(
                ::std::mem::size_of::<TranscodeSource>(),
                32usize,
                concat!("Size of: ", stringify!(TranscodeSource))
            );
            assert_eq!(
                ::std::mem::align_of::<TranscodeSource>(),
                8usize,
                concat!("Alignment of ", stringify!(TranscodeSource))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TranscodeSource>())).range as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TranscodeSource),
                    "::",
                    stringify!(range)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TranscodeSource>())).filename as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TranscodeSource),
                    "::",
                    stringify!(filename)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TranscodeSource>())).lineno as *const _ as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TranscodeSource),
                    "::",
                    stringify!(lineno)
                )
            );
        }
        pub type TranscodeSources = u8;
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum TranscodeResult {
            TranscodeResult_Ok = 0,
            TranscodeResult_Failure = 16,
            TranscodeResult_Failure_BadBuildId = 17,
            TranscodeResult_Failure_RunOnceNotSupported = 18,
            TranscodeResult_Failure_AsmJSNotSupported = 19,
            TranscodeResult_Failure_BadDecode = 20,
            TranscodeResult_Failure_WrongCompileOption = 21,
            TranscodeResult_Failure_NotInterpretedFun = 22,
            TranscodeResult_Throw = 32,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS12EncodeScriptEP9JSContextRN7mozilla6VectorIhLm0ENS2_17MallocAllocPolicyEEENS_6HandleIP8JSScriptEE"]
            pub fn EncodeScript(
                cx: *mut root::JSContext,
                buffer: *mut root::JS::TranscodeBuffer,
                script: root::JS::Handle<*mut root::JSScript>,
            ) -> root::JS::TranscodeResult;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS25EncodeInterpretedFunctionEP9JSContextRN7mozilla6VectorIhLm0ENS2_17MallocAllocPolicyEEENS_6HandleIP8JSObjectEE"]
            pub fn EncodeInterpretedFunction(
                cx: *mut root::JSContext,
                buffer: *mut root::JS::TranscodeBuffer,
                funobj: root::JS::Handle<*mut root::JSObject>,
            ) -> root::JS::TranscodeResult;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS12DecodeScriptEP9JSContextRN7mozilla6VectorIhLm0ENS2_17MallocAllocPolicyEEENS_13MutableHandleIP8JSScriptEEm"]
            pub fn DecodeScript(
                cx: *mut root::JSContext,
                buffer: *mut root::JS::TranscodeBuffer,
                scriptp: root::JS::MutableHandle<*mut root::JSScript>,
                cursorIndex: usize,
            ) -> root::JS::TranscodeResult;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS12DecodeScriptEP9JSContextRKN7mozilla5RangeIhEENS_13MutableHandleIP8JSScriptEE"]
            pub fn DecodeScript1(
                cx: *mut root::JSContext,
                range: *const root::JS::TranscodeRange,
                scriptp: root::JS::MutableHandle<*mut root::JSScript>,
            ) -> root::JS::TranscodeResult;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS25DecodeInterpretedFunctionEP9JSContextRN7mozilla6VectorIhLm0ENS2_17MallocAllocPolicyEEENS_13MutableHandleIP10JSFunctionEEm"]
            pub fn DecodeInterpretedFunction(
                cx: *mut root::JSContext,
                buffer: *mut root::JS::TranscodeBuffer,
                funp: root::JS::MutableHandle<*mut root::JSFunction>,
                cursorIndex: usize,
            ) -> root::JS::TranscodeResult;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS24StartIncrementalEncodingEP9JSContextNS_6HandleIP8JSScriptEE"]
            pub fn StartIncrementalEncoding(
                cx: *mut root::JSContext,
                script: root::JS::Handle<*mut root::JSScript>,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS25FinishIncrementalEncodingEP9JSContextNS_6HandleIP8JSScriptEERN7mozilla6VectorIhLm0ENS6_17MallocAllocPolicyEEE"]
            pub fn FinishIncrementalEncoding(
                cx: *mut root::JSContext,
                script: root::JS::Handle<*mut root::JSScript>,
                buffer: *mut root::JS::TranscodeBuffer,
            ) -> bool;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct OffThreadToken {
            _unused: [u8; 0],
        }
        pub type OffThreadCompileCallback = ::std::option::Option<
            unsafe extern "C" fn(
                token: *mut root::JS::OffThreadToken,
                callbackData: *mut ::std::os::raw::c_void,
            ),
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS19CanCompileOffThreadEP9JSContextRKNS_22ReadOnlyCompileOptionsEm"]
            pub fn CanCompileOffThread(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                length: usize,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS16CompileOffThreadEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIDsEEPFvPNS_14OffThreadTokenEPvESA_"]
            pub fn CompileOffThread(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<u16>,
                callback: root::JS::OffThreadCompileCallback,
                callbackData: *mut ::std::os::raw::c_void,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS16CompileOffThreadEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIN7mozilla8Utf8UnitEEEPFvPNS_14OffThreadTokenEPvESC_"]
            pub fn CompileOffThread1(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<root::mozilla::Utf8Unit>,
                callback: root::JS::OffThreadCompileCallback,
                callbackData: *mut ::std::os::raw::c_void,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS21FinishOffThreadScriptEP9JSContextPNS_14OffThreadTokenE"]
            pub fn FinishOffThreadScript(
                cx: *mut root::JSContext,
                token: *mut root::JS::OffThreadToken,
            ) -> *mut root::JSScript;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS21CancelOffThreadScriptEP9JSContextPNS_14OffThreadTokenE"]
            pub fn CancelOffThreadScript(
                cx: *mut root::JSContext,
                token: *mut root::JS::OffThreadToken,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS22CompileOffThreadModuleEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIDsEEPFvPNS_14OffThreadTokenEPvESA_"]
            pub fn CompileOffThreadModule(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<u16>,
                callback: root::JS::OffThreadCompileCallback,
                callbackData: *mut ::std::os::raw::c_void,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS22CompileOffThreadModuleEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIN7mozilla8Utf8UnitEEEPFvPNS_14OffThreadTokenEPvESC_"]
            pub fn CompileOffThreadModule1(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<root::mozilla::Utf8Unit>,
                callback: root::JS::OffThreadCompileCallback,
                callbackData: *mut ::std::os::raw::c_void,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS21FinishOffThreadModuleEP9JSContextPNS_14OffThreadTokenE"]
            pub fn FinishOffThreadModule(
                cx: *mut root::JSContext,
                token: *mut root::JS::OffThreadToken,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS21CancelOffThreadModuleEP9JSContextPNS_14OffThreadTokenE"]
            pub fn CancelOffThreadModule(
                cx: *mut root::JSContext,
                token: *mut root::JS::OffThreadToken,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18CanDecodeOffThreadEP9JSContextRKNS_22ReadOnlyCompileOptionsEm"]
            pub fn CanDecodeOffThread(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                length: usize,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS21DecodeOffThreadScriptEP9JSContextRKNS_22ReadOnlyCompileOptionsERN7mozilla6VectorIhLm0ENS5_17MallocAllocPolicyEEEmPFvPNS_14OffThreadTokenEPvESC_"]
            pub fn DecodeOffThreadScript(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                buffer: *mut u8,
                cursor: usize,
                callback: root::JS::OffThreadCompileCallback,
                callbackData: *mut ::std::os::raw::c_void,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS21DecodeOffThreadScriptEP9JSContextRKNS_22ReadOnlyCompileOptionsERKN7mozilla5RangeIhEEPFvPNS_14OffThreadTokenEPvESC_"]
            pub fn DecodeOffThreadScript1(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                range: *const root::mozilla::Range<u8>,
                callback: root::JS::OffThreadCompileCallback,
                callbackData: *mut ::std::os::raw::c_void,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS28FinishOffThreadScriptDecoderEP9JSContextPNS_14OffThreadTokenE"]
            pub fn FinishOffThreadScriptDecoder(
                cx: *mut root::JSContext,
                token: *mut root::JS::OffThreadToken,
            ) -> *mut root::JSScript;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS28CancelOffThreadScriptDecoderEP9JSContextPNS_14OffThreadTokenE"]
            pub fn CancelOffThreadScriptDecoder(
                cx: *mut root::JSContext,
                token: *mut root::JS::OffThreadToken,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS27DecodeMultiOffThreadScriptsEP9JSContextRKNS_22ReadOnlyCompileOptionsERN7mozilla6VectorINS_15TranscodeSourceELm0ENS5_17MallocAllocPolicyEEEPFvPNS_14OffThreadTokenEPvESD_"]
            pub fn DecodeMultiOffThreadScripts(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                sources: *mut u8,
                callback: root::JS::OffThreadCompileCallback,
                callbackData: *mut ::std::os::raw::c_void,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS34FinishMultiOffThreadScriptsDecoderEP9JSContextPNS_14OffThreadTokenENS_13MutableHandleINS_8GCVectorIP8JSScriptLm0EN2js15TempAllocPolicyEEEEE"]
            pub fn FinishMultiOffThreadScriptsDecoder(
                cx: *mut root::JSContext,
                token: *mut root::JS::OffThreadToken,
                scripts: u8,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS34CancelMultiOffThreadScriptsDecoderEP9JSContextPNS_14OffThreadTokenE"]
            pub fn CancelMultiOffThreadScriptsDecoder(
                cx: *mut root::JSContext,
                token: *mut root::JS::OffThreadToken,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS24CanDecodeBinASTOffThreadEP9JSContextRKNS_22ReadOnlyCompileOptionsEm"]
            pub fn CanDecodeBinASTOffThread(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                length: usize,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS21DecodeBinASTOffThreadEP9JSContextRKNS_22ReadOnlyCompileOptionsEPKhmNS_12BinASTFormatEPFvPNS_14OffThreadTokenEPvESA_"]
            pub fn DecodeBinASTOffThread(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                buf: *const u8,
                length: usize,
                format: root::JS::BinASTFormat,
                callback: root::JS::OffThreadCompileCallback,
                callbackData: *mut ::std::os::raw::c_void,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS27FinishOffThreadBinASTDecodeEP9JSContextPNS_14OffThreadTokenE"]
            pub fn FinishOffThreadBinASTDecode(
                cx: *mut root::JSContext,
                token: *mut root::JS::OffThreadToken,
            ) -> *mut root::JSScript;
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoHoldPrincipals {
            pub cx_: *mut root::JSContext,
            pub principals_: *mut root::JSPrincipals,
        }
        #[test]
        fn bindgen_test_layout_AutoHoldPrincipals() {
            assert_eq!(
                ::std::mem::size_of::<AutoHoldPrincipals>(),
                16usize,
                concat!("Size of: ", stringify!(AutoHoldPrincipals))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoHoldPrincipals>(),
                8usize,
                concat!("Alignment of ", stringify!(AutoHoldPrincipals))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<AutoHoldPrincipals>())).cx_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoHoldPrincipals),
                    "::",
                    stringify!(cx_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AutoHoldPrincipals>())).principals_ as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoHoldPrincipals),
                    "::",
                    stringify!(principals_)
                )
            );
        }
        #[doc = " A structure that represents a property on an object, or the absence of a"]
        #[doc = " property.  Use {,Mutable}Handle<PropertyDescriptor> to interact with"]
        #[doc = " instances of this structure rather than interacting directly with member"]
        #[doc = " fields."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PropertyDescriptor {
            pub obj: *mut root::JSObject,
            pub attrs: ::std::os::raw::c_uint,
            pub getter: root::JSGetterOp,
            pub setter: root::JSSetterOp,
            pub value: root::JS::Value,
        }
        #[test]
        fn bindgen_test_layout_PropertyDescriptor() {
            assert_eq!(
                ::std::mem::size_of::<PropertyDescriptor>(),
                40usize,
                concat!("Size of: ", stringify!(PropertyDescriptor))
            );
            assert_eq!(
                ::std::mem::align_of::<PropertyDescriptor>(),
                8usize,
                concat!("Alignment of ", stringify!(PropertyDescriptor))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<PropertyDescriptor>())).obj as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PropertyDescriptor),
                    "::",
                    stringify!(obj)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<PropertyDescriptor>())).attrs as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PropertyDescriptor),
                    "::",
                    stringify!(attrs)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<PropertyDescriptor>())).getter as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PropertyDescriptor),
                    "::",
                    stringify!(getter)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<PropertyDescriptor>())).setter as *const _ as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PropertyDescriptor),
                    "::",
                    stringify!(setter)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<PropertyDescriptor>())).value as *const _ as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(PropertyDescriptor),
                    "::",
                    stringify!(value)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS34ObjectToCompletePropertyDescriptorEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEENS_13MutableHandleINS_18PropertyDescriptorEEE"]
            pub fn ObjectToCompletePropertyDescriptor(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                descriptor: root::JS::Handle<root::JS::Value>,
                desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS22FromPropertyDescriptorEP9JSContextNS_6HandleINS_18PropertyDescriptorEEENS_13MutableHandleINS_5ValueEEE"]
            pub fn FromPropertyDescriptor(
                cx: *mut root::JSContext,
                desc: root::JS::Handle<root::JS::PropertyDescriptor>,
                vp: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Create a new Symbol with the given description. This function never returns"]
            #[doc = " a Symbol that is in the Runtime-wide symbol registry."]
            #[doc = ""]
            #[doc = " If description is null, the new Symbol's [[Description]] attribute is"]
            #[doc = " undefined."]
            #[link_name = "\u{1}_ZN2JS9NewSymbolEP9JSContextNS_6HandleIP8JSStringEE"]
            pub fn NewSymbol(
                cx: *mut root::JSContext,
                description: root::JS::Handle<*mut root::JSString>,
            ) -> *mut root::JS::Symbol;
        }
        extern "C" {
            #[doc = " Symbol.for as specified in ES6."]
            #[doc = ""]
            #[doc = " Get a Symbol with the description 'key' from the Runtime-wide symbol"]
            #[doc = " registry. If there is not already a Symbol with that description in the"]
            #[doc = " registry, a new Symbol is created and registered. 'key' must not be null."]
            #[link_name = "\u{1}_ZN2JS12GetSymbolForEP9JSContextNS_6HandleIP8JSStringEE"]
            pub fn GetSymbolFor(
                cx: *mut root::JSContext,
                key: root::JS::Handle<*mut root::JSString>,
            ) -> *mut root::JS::Symbol;
        }
        extern "C" {
            #[doc = " Get the [[Description]] attribute of the given symbol."]
            #[doc = ""]
            #[doc = " This function is infallible. If it returns null, that means the symbol's"]
            #[doc = " [[Description]] is undefined."]
            #[link_name = "\u{1}_ZN2JS20GetSymbolDescriptionENS_6HandleIPNS_6SymbolEEE"]
            pub fn GetSymbolDescription(
                symbol: root::JS::Handle<*mut root::JS::Symbol>,
            ) -> *mut root::JSString;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum SymbolCode {
            isConcatSpreadable = 0,
            iterator = 1,
            match_ = 2,
            replace = 3,
            search = 4,
            species = 5,
            hasInstance = 6,
            split = 7,
            toPrimitive = 8,
            toStringTag = 9,
            unscopables = 10,
            asyncIterator = 11,
            matchAll = 12,
            Limit = 13,
            WellKnownAPILimit = 2147483648,
            InSymbolRegistry = 4294967294,
            UniqueSymbol = 4294967295,
        }
        extern "C" {
            #[doc = " Return the SymbolCode telling what sort of symbol `symbol` is."]
            #[doc = ""]
            #[doc = " A symbol's SymbolCode never changes once it is created."]
            #[link_name = "\u{1}_ZN2JS13GetSymbolCodeENS_6HandleIPNS_6SymbolEEE"]
            pub fn GetSymbolCode(
                symbol: root::JS::Handle<*mut root::JS::Symbol>,
            ) -> root::JS::SymbolCode;
        }
        extern "C" {
            #[doc = " Get one of the well-known symbols defined by ES6. A single set of well-known"]
            #[doc = " symbols is shared by all compartments in a JSRuntime."]
            #[doc = ""]
            #[doc = " `which` must be in the range [0, WellKnownSymbolLimit)."]
            #[link_name = "\u{1}_ZN2JS18GetWellKnownSymbolEP9JSContextNS_10SymbolCodeE"]
            pub fn GetWellKnownSymbol(
                cx: *mut root::JSContext,
                which: root::JS::SymbolCode,
            ) -> *mut root::JS::Symbol;
        }
        #[repr(i32)]
        #[doc = " Specification for which compartment/zone a newly created realm should use."]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum CompartmentSpecifier {
            NewCompartmentInSystemZone = 0,
            NewCompartmentInExistingZone = 1,
            NewCompartmentAndZone = 2,
            ExistingCompartment = 3,
        }
        #[doc = " RealmCreationOptions specifies options relevant to creating a new realm, that"]
        #[doc = " are either immutable characteristics of that realm or that are discarded"]
        #[doc = " after the realm has been created."]
        #[doc = ""]
        #[doc = " Access to these options on an existing realm is read-only: if you need"]
        #[doc = " particular selections, you must make them before you create the realm."]
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct RealmCreationOptions {
            pub traceGlobal_: root::JSTraceOp,
            pub compSpec_: root::JS::CompartmentSpecifier,
            pub __bindgen_anon_1: root::JS::RealmCreationOptions__bindgen_ty_1,
            pub profilerRealmID_: u64,
            pub invisibleToDebugger_: bool,
            pub mergeable_: bool,
            pub preserveJitCode_: bool,
            pub cloneSingletons_: bool,
            pub sharedMemoryAndAtomics_: bool,
            pub coopAndCoep_: bool,
            pub streams_: bool,
            pub readableByteStreams_: bool,
            pub byobStreamReaders_: bool,
            pub writableStreams_: bool,
            pub fields_: bool,
            pub awaitFix_: bool,
            pub weakRefs_: bool,
            pub secureContext_: bool,
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union RealmCreationOptions__bindgen_ty_1 {
            pub comp_: *mut root::JS::Compartment,
            pub zone_: *mut root::JS::Zone,
            _bindgen_union_align: u64,
        }
        #[test]
        fn bindgen_test_layout_RealmCreationOptions__bindgen_ty_1() {
            assert_eq!(
                ::std::mem::size_of::<RealmCreationOptions__bindgen_ty_1>(),
                8usize,
                concat!("Size of: ", stringify!(RealmCreationOptions__bindgen_ty_1))
            );
            assert_eq!(
                ::std::mem::align_of::<RealmCreationOptions__bindgen_ty_1>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(RealmCreationOptions__bindgen_ty_1)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmCreationOptions__bindgen_ty_1>())).comp_ as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions__bindgen_ty_1),
                    "::",
                    stringify!(comp_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmCreationOptions__bindgen_ty_1>())).zone_ as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions__bindgen_ty_1),
                    "::",
                    stringify!(zone_)
                )
            );
        }
        #[test]
        fn bindgen_test_layout_RealmCreationOptions() {
            assert_eq!(
                ::std::mem::size_of::<RealmCreationOptions>(),
                48usize,
                concat!("Size of: ", stringify!(RealmCreationOptions))
            );
            assert_eq!(
                ::std::mem::align_of::<RealmCreationOptions>(),
                8usize,
                concat!("Alignment of ", stringify!(RealmCreationOptions))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmCreationOptions>())).traceGlobal_ as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(traceGlobal_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmCreationOptions>())).compSpec_ as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(compSpec_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmCreationOptions>())).profilerRealmID_ as *const _
                        as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(profilerRealmID_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmCreationOptions>())).invisibleToDebugger_
                        as *const _ as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(invisibleToDebugger_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmCreationOptions>())).mergeable_ as *const _ as usize
                },
                33usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(mergeable_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmCreationOptions>())).preserveJitCode_ as *const _
                        as usize
                },
                34usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(preserveJitCode_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmCreationOptions>())).cloneSingletons_ as *const _
                        as usize
                },
                35usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(cloneSingletons_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmCreationOptions>())).sharedMemoryAndAtomics_
                        as *const _ as usize
                },
                36usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(sharedMemoryAndAtomics_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmCreationOptions>())).coopAndCoep_ as *const _
                        as usize
                },
                37usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(coopAndCoep_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmCreationOptions>())).streams_ as *const _ as usize
                },
                38usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(streams_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmCreationOptions>())).readableByteStreams_
                        as *const _ as usize
                },
                39usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(readableByteStreams_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmCreationOptions>())).byobStreamReaders_ as *const _
                        as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(byobStreamReaders_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmCreationOptions>())).writableStreams_ as *const _
                        as usize
                },
                41usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(writableStreams_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmCreationOptions>())).fields_ as *const _ as usize
                },
                42usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(fields_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmCreationOptions>())).awaitFix_ as *const _ as usize
                },
                43usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(awaitFix_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmCreationOptions>())).weakRefs_ as *const _ as usize
                },
                44usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(weakRefs_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmCreationOptions>())).secureContext_ as *const _
                        as usize
                },
                45usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmCreationOptions),
                    "::",
                    stringify!(secureContext_)
                )
            );
        }
        #[doc = " RealmBehaviors specifies behaviors of a realm that can be changed after the"]
        #[doc = " realm's been created."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RealmBehaviors {
            pub discardSource_: bool,
            pub disableLazyParsing_: bool,
            pub clampAndJitterTime_: bool,
            pub extraWarningsOverride_: root::JS::RealmBehaviors_Override,
            pub singletonsAsTemplates_: bool,
            pub isNonLive_: bool,
            pub deferredParserAlloc_: bool,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RealmBehaviors_Override {
            pub mode_: root::JS::RealmBehaviors_Override_Mode,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum RealmBehaviors_Override_Mode {
            Default = 0,
            ForceTrue = 1,
            ForceFalse = 2,
        }
        #[test]
        fn bindgen_test_layout_RealmBehaviors_Override() {
            assert_eq!(
                ::std::mem::size_of::<RealmBehaviors_Override>(),
                4usize,
                concat!("Size of: ", stringify!(RealmBehaviors_Override))
            );
            assert_eq!(
                ::std::mem::align_of::<RealmBehaviors_Override>(),
                4usize,
                concat!("Alignment of ", stringify!(RealmBehaviors_Override))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmBehaviors_Override>())).mode_ as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmBehaviors_Override),
                    "::",
                    stringify!(mode_)
                )
            );
        }
        #[test]
        fn bindgen_test_layout_RealmBehaviors() {
            assert_eq!(
                ::std::mem::size_of::<RealmBehaviors>(),
                12usize,
                concat!("Size of: ", stringify!(RealmBehaviors))
            );
            assert_eq!(
                ::std::mem::align_of::<RealmBehaviors>(),
                4usize,
                concat!("Alignment of ", stringify!(RealmBehaviors))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmBehaviors>())).discardSource_ as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmBehaviors),
                    "::",
                    stringify!(discardSource_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmBehaviors>())).disableLazyParsing_ as *const _
                        as usize
                },
                1usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmBehaviors),
                    "::",
                    stringify!(disableLazyParsing_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmBehaviors>())).clampAndJitterTime_ as *const _
                        as usize
                },
                2usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmBehaviors),
                    "::",
                    stringify!(clampAndJitterTime_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmBehaviors>())).extraWarningsOverride_ as *const _
                        as usize
                },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmBehaviors),
                    "::",
                    stringify!(extraWarningsOverride_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmBehaviors>())).singletonsAsTemplates_ as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmBehaviors),
                    "::",
                    stringify!(singletonsAsTemplates_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmBehaviors>())).isNonLive_ as *const _ as usize
                },
                9usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmBehaviors),
                    "::",
                    stringify!(isNonLive_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmBehaviors>())).deferredParserAlloc_ as *const _
                        as usize
                },
                10usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmBehaviors),
                    "::",
                    stringify!(deferredParserAlloc_)
                )
            );
        }
        #[doc = " RealmOptions specifies realm characteristics: both those that can't be"]
        #[doc = " changed on a realm once it's been created (RealmCreationOptions), and those"]
        #[doc = " that can be changed on an existing realm (RealmBehaviors)."]
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct RealmOptions {
            pub creationOptions_: root::JS::RealmCreationOptions,
            pub behaviors_: root::JS::RealmBehaviors,
        }
        #[test]
        fn bindgen_test_layout_RealmOptions() {
            assert_eq!(
                ::std::mem::size_of::<RealmOptions>(),
                64usize,
                concat!("Size of: ", stringify!(RealmOptions))
            );
            assert_eq!(
                ::std::mem::align_of::<RealmOptions>(),
                8usize,
                concat!("Alignment of ", stringify!(RealmOptions))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmOptions>())).creationOptions_ as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmOptions),
                    "::",
                    stringify!(creationOptions_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<RealmOptions>())).behaviors_ as *const _ as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmOptions),
                    "::",
                    stringify!(behaviors_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23RealmCreationOptionsRefEPNS_5RealmE"]
            pub fn RealmCreationOptionsRef(
                realm: *mut root::JS::Realm,
            ) -> *const root::JS::RealmCreationOptions;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23RealmCreationOptionsRefEP9JSContext"]
            pub fn RealmCreationOptionsRef1(
                cx: *mut root::JSContext,
            ) -> *const root::JS::RealmCreationOptions;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17RealmBehaviorsRefEPNS_5RealmE"]
            pub fn RealmBehaviorsRef(realm: *mut root::JS::Realm) -> *mut root::JS::RealmBehaviors;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17RealmBehaviorsRefEP9JSContext"]
            pub fn RealmBehaviorsRef1(cx: *mut root::JSContext) -> *mut root::JS::RealmBehaviors;
        }
        pub type ValueVector = u8;
        pub type IdVector = u8;
        pub type ScriptVector = u8;
        pub type StringVector = u8;
        #[repr(C)]
        pub struct CustomAutoRooter__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Custom rooting behavior for internal and external clients."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct CustomAutoRooter {
            pub vtable_: *const CustomAutoRooter__bindgen_vtable,
            pub _base: root::JS::AutoGCRooter,
        }
        #[test]
        fn bindgen_test_layout_CustomAutoRooter() {
            assert_eq!(
                ::std::mem::size_of::<CustomAutoRooter>(),
                32usize,
                concat!("Size of: ", stringify!(CustomAutoRooter))
            );
            assert_eq!(
                ::std::mem::align_of::<CustomAutoRooter>(),
                8usize,
                concat!("Alignment of ", stringify!(CustomAutoRooter))
            );
        }
        #[doc = " A handle to an array of rooted values."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HandleValueArray {
            pub length_: usize,
            pub elements_: *const root::JS::Value,
        }
        #[test]
        fn bindgen_test_layout_HandleValueArray() {
            assert_eq!(
                ::std::mem::size_of::<HandleValueArray>(),
                16usize,
                concat!("Size of: ", stringify!(HandleValueArray))
            );
            assert_eq!(
                ::std::mem::align_of::<HandleValueArray>(),
                8usize,
                concat!("Alignment of ", stringify!(HandleValueArray))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HandleValueArray>())).length_ as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HandleValueArray),
                    "::",
                    stringify!(length_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HandleValueArray>())).elements_ as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HandleValueArray),
                    "::",
                    stringify!(elements_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS21InformalValueTypeNameERKNS_5ValueE"]
            pub fn InformalValueTypeName(
                v: *const root::JS::Value,
            ) -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[doc = " Initialize the runtime's self-hosted code. Embeddings should call this"]
            #[doc = " exactly once per runtime/context, before the first JS_NewGlobalObject"]
            #[doc = " call."]
            #[link_name = "\u{1}_ZN2JS18InitSelfHostedCodeEP9JSContext"]
            pub fn InitSelfHostedCode(cx: *mut root::JSContext) -> bool;
        }
        extern "C" {
            #[doc = " Asserts (in debug and release builds) that `obj` belongs to the current"]
            #[doc = " thread's context."]
            #[link_name = "\u{1}_ZN2JS34AssertObjectBelongsToCurrentThreadEP8JSObject"]
            pub fn AssertObjectBelongsToCurrentThread(obj: *mut root::JSObject);
        }
        #[doc = " Install a process-wide callback to validate script filenames. The JS engine"]
        #[doc = " will invoke this callback for each JS script it parses or XDR decodes."]
        #[doc = ""]
        #[doc = " If the callback returns |false|, an exception is thrown and parsing/decoding"]
        #[doc = " will be aborted."]
        #[doc = ""]
        #[doc = " See also CompileOptions::setSkipFilenameValidation to opt-out of the callback"]
        #[doc = " for specific parse jobs."]
        pub type FilenameValidationCallback = ::std::option::Option<
            unsafe extern "C" fn(
                filename: *const ::std::os::raw::c_char,
                isSystemRealm: bool,
            ) -> bool,
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS29SetFilenameValidationCallbackEPFbPKcbE"]
            pub fn SetFilenameValidationCallback(cb: root::JS::FilenameValidationCallback);
        }
        extern "C" {
            #[doc = " NB: This API is infallible; a nullptr return value does not indicate error."]
            #[doc = ""]
            #[doc = " |target| must not be a cross-compartment wrapper because CCWs are not"]
            #[doc = " associated with a single realm."]
            #[doc = ""]
            #[doc = " Entering a realm roots the realm and its global object until the matching"]
            #[doc = " JS::LeaveRealm() call."]
            #[link_name = "\u{1}_ZN2JS10EnterRealmEP9JSContextP8JSObject"]
            pub fn EnterRealm(
                cx: *mut root::JSContext,
                target: *mut root::JSObject,
            ) -> *mut root::JS::Realm;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS10LeaveRealmEP9JSContextPNS_5RealmE"]
            pub fn LeaveRealm(cx: *mut root::JSContext, oldRealm: *mut root::JS::Realm);
        }
        pub type IterateRealmCallback = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                data: *mut ::std::os::raw::c_void,
                realm: root::JS::Handle<*mut root::JS::Realm>,
            ),
        >;
        extern "C" {
            #[doc = " This function calls |realmCallback| on every realm. Beware that there is no"]
            #[doc = " guarantee that the realm will survive after the callback returns. Also,"]
            #[doc = " barriers are disabled via the TraceSession."]
            #[link_name = "\u{1}_ZN2JS13IterateRealmsEP9JSContextPvPFvS1_S2_NS_6HandleIPNS_5RealmEEEE"]
            pub fn IterateRealms(
                cx: *mut root::JSContext,
                data: *mut ::std::os::raw::c_void,
                realmCallback: root::JS::IterateRealmCallback,
            );
        }
        extern "C" {
            #[doc = " Like IterateRealms, but only call the callback for realms using |principals|."]
            #[link_name = "\u{1}_ZN2JS27IterateRealmsWithPrincipalsEP9JSContextP12JSPrincipalsPvPFvS1_S4_NS_6HandleIPNS_5RealmEEEE"]
            pub fn IterateRealmsWithPrincipals(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                data: *mut ::std::os::raw::c_void,
                realmCallback: root::JS::IterateRealmCallback,
            );
        }
        extern "C" {
            #[doc = " Like IterateRealms, but only iterates realms in |compartment|."]
            #[link_name = "\u{1}_ZN2JS26IterateRealmsInCompartmentEP9JSContextPNS_11CompartmentEPvPFvS1_S4_NS_6HandleIPNS_5RealmEEEE"]
            pub fn IterateRealmsInCompartment(
                cx: *mut root::JSContext,
                compartment: *mut root::JS::Compartment,
                data: *mut ::std::os::raw::c_void,
                realmCallback: root::JS::IterateRealmCallback,
            );
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum CompartmentIterResult {
            KeepGoing = 0,
            Stop = 1,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS24IdentifyStandardInstanceEP8JSObject"]
            pub fn IdentifyStandardInstance(obj: *mut root::JSObject) -> root::JSProtoKey;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS25IdentifyStandardPrototypeEP8JSObject"]
            pub fn IdentifyStandardPrototype(obj: *mut root::JSObject) -> root::JSProtoKey;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS35IdentifyStandardInstanceOrPrototypeEP8JSObject"]
            pub fn IdentifyStandardInstanceOrPrototype(
                obj: *mut root::JSObject,
            ) -> root::JSProtoKey;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS27IdentifyStandardConstructorEP8JSObject"]
            pub fn IdentifyStandardConstructor(obj: *mut root::JSObject) -> root::JSProtoKey;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS12ProtoKeyToIdEP9JSContext10JSProtoKeyNS_13MutableHandleINS_11PropertyKeyEEE"]
            pub fn ProtoKeyToId(
                cx: *mut root::JSContext,
                key: root::JSProtoKey,
                idp: root::JS::MutableHandleId,
            );
        }
        extern "C" {
            #[doc = " Get the current realm's global. Returns nullptr if no realm has been"]
            #[doc = " entered."]
            #[link_name = "\u{1}_ZN2JS19CurrentGlobalOrNullEP9JSContext"]
            pub fn CurrentGlobalOrNull(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Get the global object associated with an object's realm. The object must not"]
            #[doc = " be a cross-compartment wrapper (because CCWs are shared by all realms in the"]
            #[doc = " compartment)."]
            #[link_name = "\u{1}_ZN2JS21GetNonCCWObjectGlobalEP8JSObject"]
            pub fn GetNonCCWObjectGlobal(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Tell JS engine whether Profile Timeline Recording is enabled or not."]
            #[doc = " If Profile Timeline Recording is enabled, data shown there like stack won't"]
            #[doc = " be optimized out."]
            #[doc = " This is global state and not associated with specific runtime or context."]
            #[link_name = "\u{1}_ZN2JS34SetProfileTimelineRecordingEnabledEb"]
            pub fn SetProfileTimelineRecordingEnabled(enabled: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS33IsProfileTimelineRecordingEnabledEv"]
            pub fn IsProfileTimelineRecordingEnabled() -> bool;
        }
        extern "C" {
            #[doc = " Convert obj to a primitive value. On success, store the result in vp and"]
            #[doc = " return true."]
            #[doc = ""]
            #[doc = " The hint argument must be JSTYPE_STRING, JSTYPE_NUMBER, or"]
            #[doc = " JSTYPE_UNDEFINED (no hint)."]
            #[doc = ""]
            #[doc = " Implements: ES6 7.1.1 ToPrimitive(input, [PreferredType])."]
            #[link_name = "\u{1}_ZN2JS11ToPrimitiveEP9JSContextNS_6HandleIP8JSObjectEE6JSTypeNS_13MutableHandleINS_5ValueEEE"]
            pub fn ToPrimitive(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                hint: root::JSType,
                vp: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[doc = " If args.get(0) is one of the strings \"string\", \"number\", or \"default\", set"]
            #[doc = " result to JSTYPE_STRING, JSTYPE_NUMBER, or JSTYPE_UNDEFINED accordingly and"]
            #[doc = " return true. Otherwise, return false with a TypeError pending."]
            #[doc = ""]
            #[doc = " This can be useful in implementing a @@toPrimitive method."]
            #[link_name = "\u{1}_ZN2JS26GetFirstArgumentAsTypeHintEP9JSContextNS_8CallArgsEP6JSType"]
            pub fn GetFirstArgumentAsTypeHint(
                cx: *mut root::JSContext,
                args: root::JS::CallArgs,
                result: *mut root::JSType,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS19OrdinaryHasInstanceEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEEPb"]
            pub fn OrdinaryHasInstance(
                cx: *mut root::JSContext,
                objArg: root::JS::HandleObject,
                v: root::JS::HandleValue,
                bp: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18InstanceofOperatorEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEEPb"]
            pub fn InstanceofOperator(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                v: root::JS::HandleValue,
                bp: *mut bool,
            ) -> bool;
        }
        #[repr(u32)]
        #[doc = " During global creation, we fire notifications to callbacks registered"]
        #[doc = " via the Debugger API. These callbacks are arbitrary script, and can touch"]
        #[doc = " the global in arbitrary ways. When that happens, the global should not be"]
        #[doc = " in a half-baked state. But this creates a problem for consumers that need"]
        #[doc = " to set slots on the global to put it in a consistent state."]
        #[doc = ""]
        #[doc = " This API provides a way for consumers to set slots atomically (immediately"]
        #[doc = " after the global is created), before any debugger hooks are fired. It's"]
        #[doc = " unfortunately on the clunky side, but that's the way the cookie crumbles."]
        #[doc = ""]
        #[doc = " If callers have no additional state on the global to set up, they may pass"]
        #[doc = " |FireOnNewGlobalHook| to JS_NewGlobalObject, which causes that function to"]
        #[doc = " fire the hook as its final act before returning. Otherwise, callers should"]
        #[doc = " pass |DontFireOnNewGlobalHook|, which means that they are responsible for"]
        #[doc = " invoking JS_FireOnNewGlobalObject upon successfully creating the global. If"]
        #[doc = " an error occurs and the operation aborts, callers should skip firing the"]
        #[doc = " hook. But otherwise, callers must take care to fire the hook exactly once"]
        #[doc = " before compiling any script in the global's scope (we have assertions in"]
        #[doc = " place to enforce this). This lets us be sure that debugger clients never miss"]
        #[doc = " breakpoints."]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum OnNewGlobalHookOption {
            FireOnNewGlobalHook = 0,
            DontFireOnNewGlobalHook = 1,
        }
        extern "C" {
            #[doc = " Return true if the given object is callable. In ES6 terms, an object is"]
            #[doc = " callable if it has a [[Call]] internal method."]
            #[doc = ""]
            #[doc = " Implements: ES6 7.2.3 IsCallable(argument)."]
            #[doc = ""]
            #[doc = " Functions are callable. A scripted proxy or wrapper is callable if its"]
            #[doc = " target is callable. Most other objects aren't callable."]
            #[link_name = "\u{1}_ZN2JS10IsCallableEP8JSObject"]
            pub fn IsCallable(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[doc = " Return true if the given object is a constructor. In ES6 terms, an object is"]
            #[doc = " a constructor if it has a [[Construct]] internal method. The expression"]
            #[doc = " `new obj()` throws a TypeError if obj is not a constructor."]
            #[doc = ""]
            #[doc = " Implements: ES6 7.2.4 IsConstructor(argument)."]
            #[doc = ""]
            #[doc = " JS functions and classes are constructors. Arrow functions and most builtin"]
            #[doc = " functions are not. A scripted proxy or wrapper is a constructor if its"]
            #[doc = " target is a constructor."]
            #[link_name = "\u{1}_ZN2JS13IsConstructorEP8JSObject"]
            pub fn IsConstructor(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS4CallEP9JSContextNS_6HandleINS_5ValueEEES4_RKNS_16HandleValueArrayENS_13MutableHandleIS3_EE"]
            pub fn Call(
                cx: *mut root::JSContext,
                thisv: root::JS::HandleValue,
                fun: root::JS::HandleValue,
                args: *const root::JS::HandleValueArray,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Invoke a constructor. This is the C++ equivalent of"]
            #[doc = " `rval = Reflect.construct(fun, args, newTarget)`."]
            #[doc = ""]
            #[doc = " JS::Construct() takes a `newTarget` argument that most callers don't need."]
            #[doc = " Consider using the four-argument Construct signature instead. (But if you're"]
            #[doc = " implementing a subclass or a proxy handler's construct() method, this is the"]
            #[doc = " right function to call.)"]
            #[doc = ""]
            #[doc = " Implements: ES6 7.3.13 Construct(F, [argumentsList], [newTarget])."]
            #[doc = " Use this function to invoke the [[Construct]] internal method."]
            #[link_name = "\u{1}_ZN2JS9ConstructEP9JSContextNS_6HandleINS_5ValueEEENS2_IP8JSObjectEERKNS_16HandleValueArrayENS_13MutableHandleIS6_EE"]
            pub fn Construct(
                cx: *mut root::JSContext,
                fun: root::JS::HandleValue,
                newTarget: root::JS::HandleObject,
                args: *const root::JS::HandleValueArray,
                objp: root::JS::MutableHandleObject,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Invoke a constructor. This is the C++ equivalent of"]
            #[doc = " `rval = new fun(...args)`."]
            #[doc = ""]
            #[doc = " Implements: ES6 7.3.13 Construct(F, [argumentsList], [newTarget]), when"]
            #[doc = " newTarget is omitted."]
            #[link_name = "\u{1}_ZN2JS9ConstructEP9JSContextNS_6HandleINS_5ValueEEERKNS_16HandleValueArrayENS_13MutableHandleIP8JSObjectEE"]
            pub fn Construct1(
                cx: *mut root::JSContext,
                fun: root::JS::HandleValue,
                args: *const root::JS::HandleValueArray,
                objp: root::JS::MutableHandleObject,
            ) -> bool;
        }
        extern "C" {
            #[doc = " On success, returns true, setting |*isMap| to true if |obj| is a Map object"]
            #[doc = " or a wrapper around one, or to false if not.  Returns false on failure."]
            #[doc = ""]
            #[doc = " This method returns true with |*isMap == false| when passed an ES6 proxy"]
            #[doc = " whose target is a Map, or when passed a revoked proxy."]
            #[link_name = "\u{1}_ZN2JS11IsMapObjectEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn IsMapObject(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                isMap: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[doc = " On success, returns true, setting |*isSet| to true if |obj| is a Set object"]
            #[doc = " or a wrapper around one, or to false if not.  Returns false on failure."]
            #[doc = ""]
            #[doc = " This method returns true with |*isSet == false| when passed an ES6 proxy"]
            #[doc = " whose target is a Set, or when passed a revoked proxy."]
            #[link_name = "\u{1}_ZN2JS11IsSetObjectEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn IsSetObject(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                isSet: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS21GetSelfHostedFunctionEP9JSContextPKcNS_6HandleINS_11PropertyKeyEEEj"]
            pub fn GetSelfHostedFunction(
                cx: *mut root::JSContext,
                selfHostedName: *const ::std::os::raw::c_char,
                id: root::JS::HandleId,
                nargs: ::std::os::raw::c_uint,
            ) -> *mut root::JSFunction;
        }
        extern "C" {
            #[doc = " Create a new function based on the given JSFunctionSpec, *fs."]
            #[doc = " id is the result of a successful call to"]
            #[doc = " `PropertySpecNameToId(cx, fs->name, &id)` or"]
            #[doc = "`PropertySpecNameToPermanentId(cx, fs->name, &id)`."]
            #[doc = ""]
            #[doc = " Unlike JS_DefineFunctions, this does not treat fs as an array."]
            #[doc = " *fs must not be JS_FS_END."]
            #[link_name = "\u{1}_ZN2JS19NewFunctionFromSpecEP9JSContextPK14JSFunctionSpecNS_6HandleINS_11PropertyKeyEEE"]
            pub fn NewFunctionFromSpec(
                cx: *mut root::JSContext,
                fs: *const root::JSFunctionSpec,
                id: root::JS::HandleId,
            ) -> *mut root::JSFunction;
        }
        extern "C" {
            #[doc = " Same as above, but without an id arg, for callers who don't have"]
            #[doc = " the id already."]
            #[link_name = "\u{1}_ZN2JS19NewFunctionFromSpecEP9JSContextPK14JSFunctionSpec"]
            pub fn NewFunctionFromSpec1(
                cx: *mut root::JSContext,
                fs: *const root::JSFunctionSpec,
            ) -> *mut root::JSFunction;
        }
        extern "C" {
            #[doc = " Set a private value associated with a script. Note that this value is shared"]
            #[doc = " by all nested scripts compiled from a single source file."]
            #[link_name = "\u{1}_ZN2JS16SetScriptPrivateEP8JSScriptRKNS_5ValueE"]
            pub fn SetScriptPrivate(script: *mut root::JSScript, value: *const root::JS::Value);
        }
        extern "C" {
            #[doc = " Get the private value associated with a script. Note that this value is"]
            #[doc = " shared by all nested scripts compiled from a single source file."]
            #[link_name = "\u{1}_ZN2JS16GetScriptPrivateEP8JSScript"]
            pub fn GetScriptPrivate(script: *mut root::JSScript) -> root::JS::Value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS24GetScriptedCallerPrivateEP9JSContext"]
            pub fn GetScriptedCallerPrivate(cx: *mut root::JSContext) -> root::JS::Value;
        }
        #[doc = " Hooks called when references to a script private value are created or"]
        #[doc = " destroyed. This allows use of a reference counted object as the"]
        #[doc = " script private."]
        pub type ScriptPrivateReferenceHook =
            ::std::option::Option<unsafe extern "C" fn(arg1: *const root::JS::Value)>;
        extern "C" {
            #[doc = " Set the script private finalize hook for the runtime to the given function."]
            #[link_name = "\u{1}_ZN2JS30SetScriptPrivateReferenceHooksEP9JSRuntimePFvRKNS_5ValueEES6_"]
            pub fn SetScriptPrivateReferenceHooks(
                rt: *mut root::JSRuntime,
                addRefHook: root::JS::ScriptPrivateReferenceHook,
                releaseHook: root::JS::ScriptPrivateReferenceHook,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS12DecodeBinASTEP9JSContextRKNS_22ReadOnlyCompileOptionsEP8_IO_FILENS_12BinASTFormatE"]
            pub fn DecodeBinAST(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                file: *mut root::FILE,
                format: root::JS::BinASTFormat,
            ) -> *mut root::JSScript;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS12DecodeBinASTEP9JSContextRKNS_22ReadOnlyCompileOptionsEPKhmNS_12BinASTFormatE"]
            pub fn DecodeBinAST1(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                buf: *const u8,
                length: usize,
                format: root::JS::BinASTFormat,
            ) -> *mut root::JSScript;
        }
        #[doc = " The ConsumeStreamCallback is called from an active JSContext, passing a"]
        #[doc = " StreamConsumer that wishes to consume the given host object as a stream of"]
        #[doc = " bytes with the given MIME type. On failure, the embedding must report the"]
        #[doc = " appropriate error on 'cx'. On success, the embedding must call"]
        #[doc = " consumer->consumeChunk() repeatedly on any thread until exactly one of:"]
        #[doc = "  - consumeChunk() returns false"]
        #[doc = "  - the embedding calls consumer->streamEnd()"]
        #[doc = "  - the embedding calls consumer->streamError()"]
        #[doc = " before JS_DestroyContext(cx) or JS::ShutdownAsyncTasks(cx) is called."]
        #[doc = ""]
        #[doc = " Note: consumeChunk(), streamEnd() and streamError() may be called"]
        #[doc = " synchronously by ConsumeStreamCallback."]
        #[doc = ""]
        #[doc = " When streamEnd() is called, the embedding may optionally pass an"]
        #[doc = " OptimizedEncodingListener*, indicating that there is a cache entry associated"]
        #[doc = " with this stream that can store an optimized encoding of the bytes that were"]
        #[doc = " just streamed at some point in the future by having SpiderMonkey call"]
        #[doc = " storeOptimizedEncoding(). Until the optimized encoding is ready, SpiderMonkey"]
        #[doc = " will hold an outstanding refcount to keep the listener alive."]
        #[doc = ""]
        #[doc = " After storeOptimizedEncoding() is called, on cache hit, the embedding"]
        #[doc = " may call consumeOptimizedEncoding() instead of consumeChunk()/streamEnd()."]
        #[doc = " The embedding must ensure that the GetOptimizedEncodingBuildId() (see"]
        #[doc = " js/BuildId.h) at the time when an optimized encoding is created is the same"]
        #[doc = " as when it is later consumed."]
        pub type OptimizedEncodingBytes = u8;
        pub type UniqueOptimizedEncodingBytes = u8;
        #[repr(C)]
        pub struct OptimizedEncodingListener__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct OptimizedEncodingListener {
            pub vtable_: *const OptimizedEncodingListener__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_OptimizedEncodingListener() {
            assert_eq!(
                ::std::mem::size_of::<OptimizedEncodingListener>(),
                8usize,
                concat!("Size of: ", stringify!(OptimizedEncodingListener))
            );
            assert_eq!(
                ::std::mem::align_of::<OptimizedEncodingListener>(),
                8usize,
                concat!("Alignment of ", stringify!(OptimizedEncodingListener))
            );
        }
        #[repr(C)]
        pub struct StreamConsumer__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct StreamConsumer {
            pub vtable_: *const StreamConsumer__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_StreamConsumer() {
            assert_eq!(
                ::std::mem::size_of::<StreamConsumer>(),
                8usize,
                concat!("Size of: ", stringify!(StreamConsumer))
            );
            assert_eq!(
                ::std::mem::align_of::<StreamConsumer>(),
                8usize,
                concat!("Alignment of ", stringify!(StreamConsumer))
            );
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum MimeType {
            Wasm = 0,
        }
        pub type ConsumeStreamCallback = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                mimeType: root::JS::MimeType,
                consumer: *mut root::JS::StreamConsumer,
            ) -> bool,
        >;
        pub type ReportStreamErrorCallback =
            ::std::option::Option<unsafe extern "C" fn(cx: *mut root::JSContext, errorCode: usize)>;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS25InitConsumeStreamCallbackEP9JSContextPFbS1_NS_6HandleIP8JSObjectEENS_8MimeTypeEPNS_14StreamConsumerEEPFvS1_mE"]
            pub fn InitConsumeStreamCallback(
                cx: *mut root::JSContext,
                consume: root::JS::ConsumeStreamCallback,
                report: root::JS::ReportStreamErrorCallback,
            );
        }
        #[doc = " Supply an alternative stack to incorporate into captured SavedFrame"]
        #[doc = " backtraces as the imputed caller of asynchronous JavaScript calls, like async"]
        #[doc = " function resumptions and DOM callbacks."]
        #[doc = ""]
        #[doc = " When one async function awaits the result of another, it's natural to think"]
        #[doc = " of that as a sort of function call: just as execution resumes from an"]
        #[doc = " ordinary call expression when the callee returns, with the return value"]
        #[doc = " providing the value of the call expression, execution resumes from an 'await'"]
        #[doc = " expression after the awaited asynchronous function call returns, passing the"]
        #[doc = " return value along."]
        #[doc = ""]
        #[doc = " Call the two async functions in such a situation the 'awaiter' and the"]
        #[doc = " 'awaitee'."]
        #[doc = ""]
        #[doc = " As an async function, the awaitee contains 'await' expressions of its own."]
        #[doc = " Whenever it executes after its first 'await', there are never any actual"]
        #[doc = " frames on the JavaScript stack under it; its awaiter is certainly not there."]
        #[doc = " An await expression's continuation is invoked as a promise callback, and"]
        #[doc = " those are always called directly from the event loop in their own microtick."]
        #[doc = " (Ignore unusual cases like nested event loops.)"]
        #[doc = ""]
        #[doc = " But because await expressions bear such a strong resemblance to calls (and"]
        #[doc = " deliberately so!), it would be unhelpful for stacks captured within the"]
        #[doc = " awaitee to be empty; instead, they should present the awaiter as the caller."]
        #[doc = ""]
        #[doc = " The AutoSetAsyncStackForNewCalls RAII class supplies a SavedFrame stack to"]
        #[doc = " treat as the caller of any JavaScript invocations that occur within its"]
        #[doc = " lifetime. Any SavedFrame stack captured during such an invocation uses the"]
        #[doc = " SavedFrame passed to the constructor's 'stack' parameter as the 'asyncParent'"]
        #[doc = " property of the SavedFrame for the invocation's oldest frame. Its 'parent'"]
        #[doc = " property will be null, so stack-walking code can distinguish this"]
        #[doc = " awaiter/awaitee transition from an ordinary caller/callee transition."]
        #[doc = ""]
        #[doc = " The constructor's 'asyncCause' parameter supplies a string explaining what"]
        #[doc = " sort of asynchronous call caused 'stack' to be spliced into the backtrace;"]
        #[doc = " for example, async function resumptions use the string \"async\". This appears"]
        #[doc = " as the 'asyncCause' property of the 'asyncParent' SavedFrame."]
        #[doc = ""]
        #[doc = " Async callers are distinguished in the string form of a SavedFrame chain by"]
        #[doc = " including the 'asyncCause' string in the frame. It appears before the"]
        #[doc = " function name, with the two separated by a '*'."]
        #[doc = ""]
        #[doc = " Note that, as each compartment has its own set of SavedFrames, the"]
        #[doc = " 'asyncParent' may actually point to a copy of 'stack', rather than the exact"]
        #[doc = " SavedFrame object passed."]
        #[doc = ""]
        #[doc = " The youngest frame of 'stack' is not mutated to take the asyncCause string as"]
        #[doc = " its 'asyncCause' property; SavedFrame objects are immutable. Rather, a fresh"]
        #[doc = " clone of the frame is created with the needed 'asyncCause' property."]
        #[doc = ""]
        #[doc = " The 'kind' argument specifies how aggressively 'stack' supplants any"]
        #[doc = " JavaScript frames older than this AutoSetAsyncStackForNewCalls object. If"]
        #[doc = " 'kind' is 'EXPLICIT', then all captured SavedFrame chains take on 'stack' as"]
        #[doc = " their 'asyncParent' where the chain crosses this object's scope. If 'kind' is"]
        #[doc = " 'IMPLICIT', then 'stack' is only included in captured chains if there are no"]
        #[doc = " other JavaScript frames on the stack --- that is, only if the stack would"]
        #[doc = " otherwise end at that point."]
        #[doc = ""]
        #[doc = " AutoSetAsyncStackForNewCalls affects only SavedFrame chains; it does not"]
        #[doc = " affect Debugger.Frame or js::FrameIter. SavedFrame chains are used for"]
        #[doc = " Error.stack, allocation profiling, Promise debugging, and so on."]
        #[doc = ""]
        #[doc = " See also `js/src/doc/SavedFrame/SavedFrame.md` for documentation on async"]
        #[doc = " stack frames."]
        #[repr(C)]
        pub struct AutoSetAsyncStackForNewCalls {
            pub cx: *mut root::JSContext,
            pub oldAsyncStack: root::JS::RootedObject,
            pub oldAsyncCause: *const ::std::os::raw::c_char,
            pub oldAsyncCallIsExplicit: bool,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum AutoSetAsyncStackForNewCalls_AsyncCallKind {
            IMPLICIT = 0,
            EXPLICIT = 1,
        }
        #[test]
        fn bindgen_test_layout_AutoSetAsyncStackForNewCalls() {
            assert_eq!(
                ::std::mem::size_of::<AutoSetAsyncStackForNewCalls>(),
                48usize,
                concat!("Size of: ", stringify!(AutoSetAsyncStackForNewCalls))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoSetAsyncStackForNewCalls>(),
                8usize,
                concat!("Alignment of ", stringify!(AutoSetAsyncStackForNewCalls))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AutoSetAsyncStackForNewCalls>())).cx as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoSetAsyncStackForNewCalls),
                    "::",
                    stringify!(cx)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AutoSetAsyncStackForNewCalls>())).oldAsyncStack
                        as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoSetAsyncStackForNewCalls),
                    "::",
                    stringify!(oldAsyncStack)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AutoSetAsyncStackForNewCalls>())).oldAsyncCause
                        as *const _ as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoSetAsyncStackForNewCalls),
                    "::",
                    stringify!(oldAsyncCause)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AutoSetAsyncStackForNewCalls>())).oldAsyncCallIsExplicit
                        as *const _ as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoSetAsyncStackForNewCalls),
                    "::",
                    stringify!(oldAsyncCallIsExplicit)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS24PropertySpecNameEqualsIdEN14JSPropertySpec4NameENS_6HandleINS_11PropertyKeyEEE"]
            pub fn PropertySpecNameEqualsId(
                name: root::JSPropertySpec_Name,
                id: root::JS::HandleId,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Create a jsid that does not need to be marked for GC."]
            #[doc = ""]
            #[doc = " 'name' is a JSPropertySpec::name or JSFunctionSpec::name value. The"]
            #[doc = " resulting jsid, on success, is either an interned string or a well-known"]
            #[doc = " symbol; either way it is immune to GC so there is no need to visit *idp"]
            #[doc = " during GC marking."]
            #[link_name = "\u{1}_ZN2JS29PropertySpecNameToPermanentIdEP9JSContextN14JSPropertySpec4NameEPNS_11PropertyKeyE"]
            pub fn PropertySpecNameToPermanentId(
                cx: *mut root::JSContext,
                name: root::JSPropertySpec_Name,
                idp: *mut root::jsid,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS11CreateErrorEP9JSContext9JSExnTypeNS_6HandleIP8JSObjectEENS3_IP8JSStringEEjjP13JSErrorReportS9_NS_13MutableHandleINS_5ValueEEE"]
            pub fn CreateError(
                cx: *mut root::JSContext,
                type_: root::JSExnType,
                stack: root::JS::HandleObject,
                fileName: root::JS::HandleString,
                lineNumber: u32,
                columnNumber: u32,
                report: *mut root::JSErrorReport,
                message: root::JS::HandleString,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS16NewWeakMapObjectEP9JSContext"]
            pub fn NewWeakMapObject(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15IsWeakMapObjectEP8JSObject"]
            pub fn IsWeakMapObject(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15GetWeakMapEntryEP9JSContextNS_6HandleIP8JSObjectEES5_NS_13MutableHandleINS_5ValueEEE"]
            pub fn GetWeakMapEntry(
                cx: *mut root::JSContext,
                mapObj: root::JS::HandleObject,
                key: root::JS::HandleObject,
                val: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15SetWeakMapEntryEP9JSContextNS_6HandleIP8JSObjectEES5_NS2_INS_5ValueEEE"]
            pub fn SetWeakMapEntry(
                cx: *mut root::JSContext,
                mapObj: root::JS::HandleObject,
                key: root::JS::HandleObject,
                val: root::JS::HandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS12NewMapObjectEP9JSContext"]
            pub fn NewMapObject(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS7MapSizeEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn MapSize(cx: *mut root::JSContext, obj: root::JS::HandleObject) -> u32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS6MapGetEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEENS_13MutableHandleIS6_EE"]
            pub fn MapGet(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                key: root::JS::HandleValue,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS6MapHasEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEEPb"]
            pub fn MapHas(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                key: root::JS::HandleValue,
                rval: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS6MapSetEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEES7_"]
            pub fn MapSet(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                key: root::JS::HandleValue,
                val: root::JS::HandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9MapDeleteEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEEPb"]
            pub fn MapDelete(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                key: root::JS::HandleValue,
                rval: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS8MapClearEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn MapClear(cx: *mut root::JSContext, obj: root::JS::HandleObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS7MapKeysEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
            pub fn MapKeys(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9MapValuesEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
            pub fn MapValues(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS10MapEntriesEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
            pub fn MapEntries(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS10MapForEachEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEES7_"]
            pub fn MapForEach(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                callbackFn: root::JS::HandleValue,
                thisVal: root::JS::HandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS12NewSetObjectEP9JSContext"]
            pub fn NewSetObject(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS7SetSizeEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn SetSize(cx: *mut root::JSContext, obj: root::JS::HandleObject) -> u32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS6SetHasEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEEPb"]
            pub fn SetHas(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                key: root::JS::HandleValue,
                rval: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9SetDeleteEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEEPb"]
            pub fn SetDelete(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                key: root::JS::HandleValue,
                rval: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS6SetAddEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEE"]
            pub fn SetAdd(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                key: root::JS::HandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS8SetClearEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn SetClear(cx: *mut root::JSContext, obj: root::JS::HandleObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS7SetKeysEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
            pub fn SetKeys(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS9SetValuesEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
            pub fn SetValues(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS10SetEntriesEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
            pub fn SetEntries(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS10SetForEachEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEES7_"]
            pub fn SetForEach(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                callbackFn: root::JS::HandleValue,
                thisVal: root::JS::HandleValue,
            ) -> bool;
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ExceptionStackBehavior {
            DoNotCapture = 0,
            Capture = 1,
        }
        #[doc = " Save and later restore the current exception state of a given JSContext."]
        #[doc = " This is useful for implementing behavior in C++ that's like try/catch"]
        #[doc = " or try/finally in JS."]
        #[doc = ""]
        #[doc = " Typical usage:"]
        #[doc = ""]
        #[doc = "     bool ok = JS::Evaluate(cx, ...);"]
        #[doc = "     AutoSaveExceptionState savedExc(cx);"]
        #[doc = "     ... cleanup that might re-enter JS ..."]
        #[doc = "     return ok;"]
        #[repr(C)]
        pub struct AutoSaveExceptionState {
            pub context: *mut root::JSContext,
            pub wasPropagatingForcedReturn: bool,
            pub wasOverRecursed: bool,
            pub wasThrowing: bool,
            pub exceptionValue: root::JS::RootedValue,
            pub exceptionStack: root::JS::RootedObject,
        }
        #[test]
        fn bindgen_test_layout_AutoSaveExceptionState() {
            assert_eq!(
                ::std::mem::size_of::<AutoSaveExceptionState>(),
                64usize,
                concat!("Size of: ", stringify!(AutoSaveExceptionState))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoSaveExceptionState>(),
                8usize,
                concat!("Alignment of ", stringify!(AutoSaveExceptionState))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AutoSaveExceptionState>())).context as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoSaveExceptionState),
                    "::",
                    stringify!(context)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AutoSaveExceptionState>())).wasPropagatingForcedReturn
                        as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoSaveExceptionState),
                    "::",
                    stringify!(wasPropagatingForcedReturn)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AutoSaveExceptionState>())).wasOverRecursed as *const _
                        as usize
                },
                9usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoSaveExceptionState),
                    "::",
                    stringify!(wasOverRecursed)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AutoSaveExceptionState>())).wasThrowing as *const _
                        as usize
                },
                10usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoSaveExceptionState),
                    "::",
                    stringify!(wasThrowing)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AutoSaveExceptionState>())).exceptionValue as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoSaveExceptionState),
                    "::",
                    stringify!(exceptionValue)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AutoSaveExceptionState>())).exceptionStack as *const _
                        as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoSaveExceptionState),
                    "::",
                    stringify!(exceptionStack)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS27SetPendingExceptionAndStackEP9JSContextNS_6HandleINS_5ValueEEENS2_IP8JSObjectEE"]
            pub fn SetPendingExceptionAndStack(
                cx: *mut root::JSContext,
                value: root::JS::HandleValue,
                stack: root::JS::HandleObject,
            );
        }
        extern "C" {
            #[doc = " Get the SavedFrame stack object captured when the pending exception was set"]
            #[doc = " on the JSContext. This fuzzily correlates with a `throw` statement in JS,"]
            #[doc = " although arbitrary JSAPI consumers or VM code may also set pending exceptions"]
            #[doc = " via `JS_SetPendingException`."]
            #[doc = ""]
            #[doc = " This is not the same stack as `e.stack` when `e` is an `Error` object. (That"]
            #[doc = " would be JS::ExceptionStackOrNull)."]
            #[link_name = "\u{1}_ZN2JS24GetPendingExceptionStackEP9JSContext"]
            pub fn GetPendingExceptionStack(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " If the given object is an exception object (or an unwrappable"]
            #[doc = " cross-compartment wrapper for one), return the stack for that exception, if"]
            #[doc = " any.  Will return null if the given object is not an exception object"]
            #[doc = " (including if it's null or a security wrapper that can't be unwrapped) or if"]
            #[doc = " the exception has no stack."]
            #[link_name = "\u{1}_ZN2JS20ExceptionStackOrNullENS_6HandleIP8JSObjectEE"]
            pub fn ExceptionStackOrNull(obj: root::JS::HandleObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " If this process is recording or replaying and the given value is an"]
            #[doc = " exception object (or an unwrappable cross-compartment wrapper for one),"]
            #[doc = " return the point where this exception was thrown, for time warping later."]
            #[doc = " Returns zero otherwise."]
            #[link_name = "\u{1}_ZN2JS23ExceptionTimeWarpTargetENS_6HandleINS_5ValueEEE"]
            pub fn ExceptionTimeWarpTarget(exn: root::JS::HandleValue) -> u64;
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoFilename {
            pub ss_: *mut root::js::ScriptSource,
            pub filename_: [u64; 2usize],
        }
        #[test]
        fn bindgen_test_layout_AutoFilename() {
            assert_eq!(
                ::std::mem::size_of::<AutoFilename>(),
                24usize,
                concat!("Size of: ", stringify!(AutoFilename))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoFilename>(),
                8usize,
                concat!("Alignment of ", stringify!(AutoFilename))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<AutoFilename>())).ss_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoFilename),
                    "::",
                    stringify!(ss_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<AutoFilename>())).filename_ as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoFilename),
                    "::",
                    stringify!(filename_)
                )
            );
        }
        extern "C" {
            #[doc = " Return the current filename, line number and column number of the most"]
            #[doc = " currently running frame. Returns true if a scripted frame was found, false"]
            #[doc = " otherwise."]
            #[doc = ""]
            #[doc = " If a the embedding has hidden the scripted caller for the topmost activation"]
            #[doc = " record, this will also return false."]
            #[link_name = "\u{1}_ZN2JS22DescribeScriptedCallerEP9JSContextPNS_12AutoFilenameEPjS4_"]
            pub fn DescribeScriptedCaller(
                cx: *mut root::JSContext,
                filename: *mut root::JS::AutoFilename,
                lineno: *mut ::std::os::raw::c_uint,
                column: *mut ::std::os::raw::c_uint,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23GetScriptedCallerGlobalEP9JSContext"]
            pub fn GetScriptedCallerGlobal(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Informs the JS engine that the scripted caller should be hidden. This can be"]
            #[doc = " used by the embedding to maintain an override of the scripted caller in its"]
            #[doc = " calculations, by hiding the scripted caller in the JS engine and pushing data"]
            #[doc = " onto a separate stack, which it inspects when DescribeScriptedCaller returns"]
            #[doc = " null."]
            #[doc = ""]
            #[doc = " We maintain a counter on each activation record. Add() increments the counter"]
            #[doc = " of the topmost activation, and Remove() decrements it. The count may never"]
            #[doc = " drop below zero, and must always be exactly zero when the activation is"]
            #[doc = " popped from the stack."]
            #[link_name = "\u{1}_ZN2JS18HideScriptedCallerEP9JSContext"]
            pub fn HideScriptedCaller(cx: *mut root::JSContext);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20UnhideScriptedCallerEP9JSContext"]
            pub fn UnhideScriptedCaller(cx: *mut root::JSContext);
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoHideScriptedCaller {
            pub mContext: *mut root::JSContext,
        }
        #[test]
        fn bindgen_test_layout_AutoHideScriptedCaller() {
            assert_eq!(
                ::std::mem::size_of::<AutoHideScriptedCaller>(),
                8usize,
                concat!("Size of: ", stringify!(AutoHideScriptedCaller))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoHideScriptedCaller>(),
                8usize,
                concat!("Alignment of ", stringify!(AutoHideScriptedCaller))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AutoHideScriptedCaller>())).mContext as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoHideScriptedCaller),
                    "::",
                    stringify!(mContext)
                )
            );
        }
        #[repr(C)]
        pub struct WasmModule__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " The WasmModule interface allows the embedding to hold a reference to the"]
        #[doc = " underying C++ implementation of a JS WebAssembly.Module object for purposes"]
        #[doc = " of efficient postMessage() and (de)serialization from a random thread."]
        #[doc = ""]
        #[doc = " In particular, this allows postMessage() of a WebAssembly.Module:"]
        #[doc = " GetWasmModule() is called when making a structured clone of a payload"]
        #[doc = " containing a WebAssembly.Module object. The structured clone buffer holds a"]
        #[doc = " refcount of the JS::WasmModule until createObject() is called in the target"]
        #[doc = " agent's JSContext. The new WebAssembly.Module object continues to hold the"]
        #[doc = " JS::WasmModule and thus the final reference of a JS::WasmModule may be"]
        #[doc = " dropped from any thread and so the virtual destructor (and all internal"]
        #[doc = " methods of the C++ module) must be thread-safe."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct WasmModule {
            pub vtable_: *const WasmModule__bindgen_vtable,
            pub _base: root::js::AtomicRefCounted,
        }
        #[test]
        fn bindgen_test_layout_WasmModule() {
            assert_eq!(
                ::std::mem::size_of::<WasmModule>(),
                16usize,
                concat!("Size of: ", stringify!(WasmModule))
            );
            assert_eq!(
                ::std::mem::align_of::<WasmModule>(),
                8usize,
                concat!("Alignment of ", stringify!(WasmModule))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18IsWasmModuleObjectENS_6HandleIP8JSObjectEE"]
            pub fn IsWasmModuleObject(obj: root::JS::HandleObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13GetWasmModuleENS_6HandleIP8JSObjectEE"]
            pub fn GetWasmModule(obj: root::JS::HandleObject)
                -> root::RefPtr<root::JS::WasmModule>;
        }
        extern "C" {
            #[doc = " Attempt to disable Wasm's usage of reserving a large virtual memory"]
            #[doc = " allocation to avoid bounds checking overhead. This must be called before any"]
            #[doc = " Wasm module or memory is created in this process, or else this function will"]
            #[doc = " fail."]
            #[link_name = "\u{1}_ZN2JS21DisableWasmHugeMemoryEv"]
            pub fn DisableWasmHugeMemory() -> bool;
        }
        #[doc = " If a large allocation fails when calling pod_{calloc,realloc}CanGC, the JS"]
        #[doc = " engine may call the large-allocation-failure callback, if set, to allow the"]
        #[doc = " embedding to flush caches, possibly perform shrinking GCs, etc. to make some"]
        #[doc = " room. The allocation will then be retried (and may still fail.) This callback"]
        #[doc = " can be called on any thread and must be set at most once in a process."]
        pub type LargeAllocationFailureCallback = ::std::option::Option<unsafe extern "C" fn()>;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS40SetProcessLargeAllocationFailureCallbackEPFvvE"]
            pub fn SetProcessLargeAllocationFailureCallback(
                afc: root::JS::LargeAllocationFailureCallback,
            );
        }
        #[doc = " Unlike the error reporter, which is only called if the exception for an OOM"]
        #[doc = " bubbles up and is not caught, the OutOfMemoryCallback is called immediately"]
        #[doc = " at the OOM site to allow the embedding to capture the current state of heap"]
        #[doc = " allocation before anything is freed. If the large-allocation-failure callback"]
        #[doc = " is called at all (not all allocation sites call the large-allocation-failure"]
        #[doc = " callback on failure), it is called before the out-of-memory callback; the"]
        #[doc = " out-of-memory callback is only called if the allocation still fails after the"]
        #[doc = " large-allocation-failure callback has returned."]
        pub type OutOfMemoryCallback = ::std::option::Option<
            unsafe extern "C" fn(cx: *mut root::JSContext, data: *mut ::std::os::raw::c_void),
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS22SetOutOfMemoryCallbackEP9JSContextPFvS1_PvES2_"]
            pub fn SetOutOfMemoryCallback(
                cx: *mut root::JSContext,
                cb: root::JS::OutOfMemoryCallback,
                data: *mut ::std::os::raw::c_void,
            );
        }
        #[doc = " Capture all frames."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AllFrames {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_AllFrames() {
            assert_eq!(
                ::std::mem::size_of::<AllFrames>(),
                1usize,
                concat!("Size of: ", stringify!(AllFrames))
            );
            assert_eq!(
                ::std::mem::align_of::<AllFrames>(),
                1usize,
                concat!("Alignment of ", stringify!(AllFrames))
            );
        }
        #[doc = " Capture at most this many frames."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MaxFrames {
            pub maxFrames: u32,
        }
        #[test]
        fn bindgen_test_layout_MaxFrames() {
            assert_eq!(
                ::std::mem::size_of::<MaxFrames>(),
                4usize,
                concat!("Size of: ", stringify!(MaxFrames))
            );
            assert_eq!(
                ::std::mem::align_of::<MaxFrames>(),
                4usize,
                concat!("Alignment of ", stringify!(MaxFrames))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<MaxFrames>())).maxFrames as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(MaxFrames),
                    "::",
                    stringify!(maxFrames)
                )
            );
        }
        #[doc = " Capture the first frame with the given principals. By default, do not"]
        #[doc = " consider self-hosted frames with the given principals as satisfying the stack"]
        #[doc = " capture."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct FirstSubsumedFrame {
            pub cx: *mut root::JSContext,
            pub principals: *mut root::JSPrincipals,
            pub ignoreSelfHosted: bool,
        }
        #[test]
        fn bindgen_test_layout_FirstSubsumedFrame() {
            assert_eq!(
                ::std::mem::size_of::<FirstSubsumedFrame>(),
                24usize,
                concat!("Size of: ", stringify!(FirstSubsumedFrame))
            );
            assert_eq!(
                ::std::mem::align_of::<FirstSubsumedFrame>(),
                8usize,
                concat!("Alignment of ", stringify!(FirstSubsumedFrame))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<FirstSubsumedFrame>())).cx as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(FirstSubsumedFrame),
                    "::",
                    stringify!(cx)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<FirstSubsumedFrame>())).principals as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(FirstSubsumedFrame),
                    "::",
                    stringify!(principals)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<FirstSubsumedFrame>())).ignoreSelfHosted as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(FirstSubsumedFrame),
                    "::",
                    stringify!(ignoreSelfHosted)
                )
            );
        }
        pub type StackCapture = [u64; 4usize];
        extern "C" {
            #[doc = " Capture the current call stack as a chain of SavedFrame JSObjects, and set"]
            #[doc = " |stackp| to the SavedFrame for the youngest stack frame, or nullptr if there"]
            #[doc = " are no JS frames on the stack."]
            #[doc = ""]
            #[doc = " The |capture| parameter describes the portion of the JS stack to capture:"]
            #[doc = ""]
            #[doc = "   * |JS::AllFrames|: Capture all frames on the stack."]
            #[doc = ""]
            #[doc = "   * |JS::MaxFrames|: Capture no more than |JS::MaxFrames::maxFrames| from the"]
            #[doc = "      stack."]
            #[doc = ""]
            #[doc = "   * |JS::FirstSubsumedFrame|: Capture the first frame whose principals are"]
            #[doc = "     subsumed by |JS::FirstSubsumedFrame::principals|. By default, do not"]
            #[doc = "     consider self-hosted frames; this can be controlled via the"]
            #[doc = "     |JS::FirstSubsumedFrame::ignoreSelfHosted| flag. Do not capture any async"]
            #[doc = "     stack."]
            #[link_name = "\u{1}_ZN2JS19CaptureCurrentStackEP9JSContextNS_13MutableHandleIP8JSObjectEEON7mozilla7VariantIJNS_9AllFramesENS_9MaxFramesENS_18FirstSubsumedFrameEEEE"]
            pub fn CaptureCurrentStack(
                cx: *mut root::JSContext,
                stackp: root::JS::MutableHandleObject,
                capture: *mut root::JS::StackCapture,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS14CopyAsyncStackEP9JSContextNS_6HandleIP8JSObjectEENS2_IP8JSStringEENS_13MutableHandleIS4_EERKN7mozilla5MaybeImEE"]
            pub fn CopyAsyncStack(
                cx: *mut root::JSContext,
                asyncStack: root::JS::HandleObject,
                asyncCause: root::JS::HandleString,
                stackp: root::JS::MutableHandleObject,
                maxFrameCount: *const [u64; 2usize],
            ) -> bool;
        }
        extern "C" {
            #[doc = " Given a SavedFrame JSObject stack, stringify it in the same format as"]
            #[doc = " Error.prototype.stack. The stringified stack out parameter is placed in the"]
            #[doc = " cx's compartment. Defaults to the empty string."]
            #[doc = ""]
            #[doc = " The same notes above about SavedFrame accessors applies here as well: cx"]
            #[doc = " doesn't need to be in stack's compartment, and stack can be null, a"]
            #[doc = " SavedFrame object, or a wrapper (CCW or Xray) around a SavedFrame object."]
            #[doc = " SavedFrames not subsumed by |principals| are skipped."]
            #[doc = ""]
            #[doc = " Optional indent parameter specifies the number of white spaces to indent"]
            #[doc = " each line."]
            #[link_name = "\u{1}_ZN2JS16BuildStackStringEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEENS_13MutableHandleIP8JSStringEEmN2js11StackFormatE"]
            pub fn BuildStackString(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                stack: root::JS::HandleObject,
                stringp: root::JS::MutableHandleString,
                indent: usize,
                stackFormat: root::js::StackFormat,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Return true iff the given object is either a SavedFrame object or wrapper"]
            #[doc = " around a SavedFrame object, and it is not the SavedFrame.prototype object."]
            #[link_name = "\u{1}_ZN2JS24IsMaybeWrappedSavedFrameEP8JSObject"]
            pub fn IsMaybeWrappedSavedFrame(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[doc = " Return true iff the given object is a SavedFrame object and not the"]
            #[doc = " SavedFrame.prototype object."]
            #[link_name = "\u{1}_ZN2JS21IsUnwrappedSavedFrameEP8JSObject"]
            pub fn IsUnwrappedSavedFrame(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[doc = " Clean up a finalization group in response to the engine calling the"]
            #[doc = " HostCleanupFinalizationGroup callback."]
            #[link_name = "\u{1}_ZN2JS30CleanupQueuedFinalizationGroupEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn CleanupQueuedFinalizationGroup(
                cx: *mut root::JSContext,
                group: root::JS::HandleObject,
            ) -> bool;
        }
        pub type IsAcceptableThis =
            ::std::option::Option<unsafe extern "C" fn(v: root::JS::HandleValue) -> bool>;
        pub type NativeImpl = ::std::option::Option<
            unsafe extern "C" fn(cx: *mut root::JSContext, args: *const root::JS::CallArgs) -> bool,
        >;
        #[doc = " This class provides safe access to a string's chars across a GC. If we ever"]
        #[doc = " nursery allocate strings' out of line chars, this class will have to make a"]
        #[doc = " copy, so it's best to avoid using this class unless you really need it. It's"]
        #[doc = " usually more efficient to use the latin1Chars/twoByteChars JSString methods"]
        #[doc = " and often the code can be rewritten so that only indexes instead of char"]
        #[doc = " pointers are used in parts of the code that can GC."]
        #[repr(C)]
        pub struct AutoStableStringChars {
            pub s_: root::JS::Rooted<*mut root::JSString>,
            pub __bindgen_anon_1: root::JS::AutoStableStringChars__bindgen_ty_1,
            pub ownChars_: [u64; 8usize],
            pub state_: root::JS::AutoStableStringChars_State,
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union AutoStableStringChars__bindgen_ty_1 {
            pub twoByteChars_: *const u16,
            pub latin1Chars_: *const root::JS::Latin1Char,
            _bindgen_union_align: u64,
        }
        #[test]
        fn bindgen_test_layout_AutoStableStringChars__bindgen_ty_1() {
            assert_eq!(
                ::std::mem::size_of::<AutoStableStringChars__bindgen_ty_1>(),
                8usize,
                concat!("Size of: ", stringify!(AutoStableStringChars__bindgen_ty_1))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoStableStringChars__bindgen_ty_1>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(AutoStableStringChars__bindgen_ty_1)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AutoStableStringChars__bindgen_ty_1>())).twoByteChars_
                        as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoStableStringChars__bindgen_ty_1),
                    "::",
                    stringify!(twoByteChars_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AutoStableStringChars__bindgen_ty_1>())).latin1Chars_
                        as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoStableStringChars__bindgen_ty_1),
                    "::",
                    stringify!(latin1Chars_)
                )
            );
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum AutoStableStringChars_State {
            Uninitialized = 0,
            Latin1 = 1,
            TwoByte = 2,
        }
        pub const AutoStableStringChars_InlineCapacity: usize = 24;
        #[test]
        fn bindgen_test_layout_AutoStableStringChars() {
            assert_eq!(
                ::std::mem::size_of::<AutoStableStringChars>(),
                104usize,
                concat!("Size of: ", stringify!(AutoStableStringChars))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoStableStringChars>(),
                8usize,
                concat!("Alignment of ", stringify!(AutoStableStringChars))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AutoStableStringChars>())).s_ as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoStableStringChars),
                    "::",
                    stringify!(s_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AutoStableStringChars>())).ownChars_ as *const _ as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoStableStringChars),
                    "::",
                    stringify!(ownChars_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AutoStableStringChars>())).state_ as *const _ as usize
                },
                96usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoStableStringChars),
                    "::",
                    stringify!(state_)
                )
            );
        }
        extern "C" {
            #[doc = " Exposed for DumpJSStack"]
            #[link_name = "\u{1}_ZN2JS15FormatStackDumpEP9JSContextbbb"]
            pub fn FormatStackDump(
                cx: *mut root::JSContext,
                showArgs: bool,
                showLocals: bool,
                showThisProps: bool,
            ) -> root::JS::UniqueChars;
        }
        extern "C" {
            #[doc = " Set all of the uninitialized lexicals on an object to undefined. Return"]
            #[doc = " true if any lexicals were initialized and false otherwise."]
            #[link_name = "\u{1}_ZN2JS26ForceLexicalInitializationEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn ForceLexicalInitialization(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Whether we are poisoning unused/released data for error detection. Governed"]
            #[doc = " by the JS_GC_POISONING #ifdef as well as the $JSGC_DISABLE_POISONING"]
            #[doc = " environment variable."]
            #[link_name = "\u{1}_ZN2JS13IsGCPoisoningEv"]
            pub fn IsGCPoisoning() -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18GetRealmPrincipalsEPNS_5RealmE"]
            pub fn GetRealmPrincipals(realm: *mut root::JS::Realm) -> *mut root::JSPrincipals;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18SetRealmPrincipalsEPNS_5RealmEP12JSPrincipals"]
            pub fn SetRealmPrincipals(
                realm: *mut root::JS::Realm,
                principals: *mut root::JSPrincipals,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18GetIsSecureContextEPNS_5RealmE"]
            pub fn GetIsSecureContext(realm: *mut root::JS::Realm) -> bool;
        }
        extern "C" {
            #[doc = " Create a new ArrayBuffer with the given byte length."]
            #[link_name = "\u{1}_ZN2JS14NewArrayBufferEP9JSContextj"]
            pub fn NewArrayBuffer(cx: *mut root::JSContext, nbytes: u32) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Create a new ArrayBuffer with the given |contents|, which may be null only"]
            #[doc = " if |nbytes == 0|.  |contents| must be allocated compatible with deallocation"]
            #[doc = " by |JS_free|."]
            #[doc = ""]
            #[doc = " If and only if an ArrayBuffer is successfully created and returned,"]
            #[doc = " ownership of |contents| is transferred to the new ArrayBuffer."]
            #[link_name = "\u{1}_ZN2JS26NewArrayBufferWithContentsEP9JSContextmPv"]
            pub fn NewArrayBufferWithContents(
                cx: *mut root::JSContext,
                nbytes: usize,
                contents: *mut ::std::os::raw::c_void,
            ) -> *mut root::JSObject;
        }
        pub type BufferContentsFreeFunc = ::std::option::Option<
            unsafe extern "C" fn(
                contents: *mut ::std::os::raw::c_void,
                userData: *mut ::std::os::raw::c_void,
            ),
        >;
        extern "C" {
            #[doc = " Create a new ArrayBuffer with the given contents. The contents must not be"]
            #[doc = " modified by any other code, internal or external."]
            #[doc = ""]
            #[doc = " When the ArrayBuffer is ready to be disposed of, `freeFunc(contents,"]
            #[doc = " freeUserData)` will be called to release the ArrayBuffer's reference on the"]
            #[doc = " contents."]
            #[doc = ""]
            #[doc = " `freeFunc()` must not call any JSAPI functions that could cause a garbage"]
            #[doc = " collection."]
            #[doc = ""]
            #[doc = " The caller must keep the buffer alive until `freeFunc()` is called, or, if"]
            #[doc = " `freeFunc` is null, until the JSRuntime is destroyed."]
            #[doc = ""]
            #[doc = " The caller must not access the buffer on other threads. The JS engine will"]
            #[doc = " not allow the buffer to be transferred to other threads. If you try to"]
            #[doc = " transfer an external ArrayBuffer to another thread, the data is copied to a"]
            #[doc = " new malloc buffer. `freeFunc()` must be threadsafe, and may be called from"]
            #[doc = " any thread."]
            #[doc = ""]
            #[doc = " This allows ArrayBuffers to be used with embedder objects that use reference"]
            #[doc = " counting, for example. In that case the caller is responsible"]
            #[doc = " for incrementing the reference count before passing the contents to this"]
            #[doc = " function. This also allows using non-reference-counted contents that must be"]
            #[doc = " freed with some function other than free()."]
            #[link_name = "\u{1}_ZN2JS22NewExternalArrayBufferEP9JSContextmPvPFvS2_S2_ES2_"]
            pub fn NewExternalArrayBuffer(
                cx: *mut root::JSContext,
                nbytes: usize,
                contents: *mut ::std::os::raw::c_void,
                freeFunc: root::JS::BufferContentsFreeFunc,
                freeUserData: *mut ::std::os::raw::c_void,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Create a new ArrayBuffer with the given non-null |contents|."]
            #[doc = ""]
            #[doc = " Ownership of |contents| remains with the caller: it isn't transferred to the"]
            #[doc = " returned ArrayBuffer.  Callers of this function *must* ensure that they"]
            #[doc = " perform these two steps, in this order, to properly relinquish ownership of"]
            #[doc = " |contents|:"]
            #[doc = ""]
            #[doc = "   1. Call |JS::DetachArrayBuffer| on the buffer returned by this function."]
            #[doc = "      (|JS::DetachArrayBuffer| is generally fallible, but a call under these"]
            #[doc = "      circumstances is guaranteed to succeed.)"]
            #[doc = "   2. |contents| may be deallocated or discarded consistent with the manner"]
            #[doc = "      in which it was allocated."]
            #[doc = ""]
            #[doc = " Do not simply allow the returned buffer to be garbage-collected before"]
            #[doc = " deallocating |contents|, because in general there is no way to know *when*"]
            #[doc = " an object is fully garbage-collected to the point where this would be safe."]
            #[link_name = "\u{1}_ZN2JS35NewArrayBufferWithUserOwnedContentsEP9JSContextmPv"]
            pub fn NewArrayBufferWithUserOwnedContents(
                cx: *mut root::JSContext,
                nbytes: usize,
                contents: *mut ::std::os::raw::c_void,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Create a new mapped ArrayBuffer with the given memory mapped contents. It"]
            #[doc = " must be legal to free the contents pointer by unmapping it. On success,"]
            #[doc = " ownership is transferred to the new mapped ArrayBuffer."]
            #[link_name = "\u{1}_ZN2JS32NewMappedArrayBufferWithContentsEP9JSContextmPv"]
            pub fn NewMappedArrayBufferWithContents(
                cx: *mut root::JSContext,
                nbytes: usize,
                contents: *mut ::std::os::raw::c_void,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Create memory mapped ArrayBuffer contents."]
            #[doc = " Caller must take care of closing fd after calling this function."]
            #[link_name = "\u{1}_ZN2JS31CreateMappedArrayBufferContentsEimm"]
            pub fn CreateMappedArrayBufferContents(
                fd: ::std::os::raw::c_int,
                offset: usize,
                length: usize,
            ) -> *mut ::std::os::raw::c_void;
        }
        extern "C" {
            #[doc = " Release the allocated resource of mapped ArrayBuffer contents before the"]
            #[doc = " object is created."]
            #[doc = " If a new object has been created by JS::NewMappedArrayBufferWithContents()"]
            #[doc = " with this content, then JS::DetachArrayBuffer() should be used instead to"]
            #[doc = " release the resource used by the object."]
            #[link_name = "\u{1}_ZN2JS32ReleaseMappedArrayBufferContentsEPvm"]
            pub fn ReleaseMappedArrayBufferContents(
                contents: *mut ::std::os::raw::c_void,
                length: usize,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS19IsArrayBufferObjectEP8JSObject"]
            pub fn IsArrayBufferObject(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[doc = " Check whether the obj is a detached ArrayBufferObject. Note that this may"]
            #[doc = " return false if a security wrapper is encountered that denies the"]
            #[doc = " unwrapping."]
            #[link_name = "\u{1}_ZN2JS27IsDetachedArrayBufferObjectEP8JSObject"]
            pub fn IsDetachedArrayBufferObject(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[doc = " Check whether the obj is ArrayBufferObject and memory mapped. Note that this"]
            #[doc = " may return false if a security wrapper is encountered that denies the"]
            #[doc = " unwrapping."]
            #[link_name = "\u{1}_ZN2JS25IsMappedArrayBufferObjectEP8JSObject"]
            pub fn IsMappedArrayBufferObject(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[doc = " Return true if the ArrayBuffer |obj| contains any data, i.e. it is not a"]
            #[doc = " detached ArrayBuffer.  (ArrayBuffer.prototype is not an ArrayBuffer.)"]
            #[doc = ""]
            #[doc = " |obj| must have passed a JS::IsArrayBufferObject test, or somehow be known"]
            #[doc = " that it would pass such a test: it is an ArrayBuffer or a wrapper of an"]
            #[doc = " ArrayBuffer, and the unwrapping will succeed."]
            #[link_name = "\u{1}_ZN2JS18ArrayBufferHasDataEP8JSObject"]
            pub fn ArrayBufferHasData(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17UnwrapArrayBufferEP8JSObject"]
            pub fn UnwrapArrayBuffer(obj: *mut root::JSObject) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Attempt to unwrap |obj| as an ArrayBuffer."]
            #[doc = ""]
            #[doc = " If |obj| *is* an ArrayBuffer, return it unwrapped and set |*length| and"]
            #[doc = " |*data| to weakly refer to the ArrayBuffer's contents."]
            #[doc = ""]
            #[doc = " If |obj| isn't an ArrayBuffer, return nullptr and do not modify |*length| or"]
            #[doc = " |*data|."]
            #[link_name = "\u{1}_ZN2JS22GetObjectAsArrayBufferEP8JSObjectPjPPh"]
            pub fn GetObjectAsArrayBuffer(
                obj: *mut root::JSObject,
                length: *mut u32,
                data: *mut *mut u8,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Return the available byte length of an ArrayBuffer."]
            #[doc = ""]
            #[doc = " |obj| must have passed a JS::IsArrayBufferObject test, or somehow be known"]
            #[doc = " that it would pass such a test: it is an ArrayBuffer or a wrapper of an"]
            #[doc = " ArrayBuffer, and the unwrapping will succeed."]
            #[link_name = "\u{1}_ZN2JS24GetArrayBufferByteLengthEP8JSObject"]
            pub fn GetArrayBufferByteLength(obj: *mut root::JSObject) -> u32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS27GetArrayBufferLengthAndDataEP8JSObjectPjPbPPh"]
            pub fn GetArrayBufferLengthAndData(
                obj: *mut root::JSObject,
                length: *mut u32,
                isSharedMemory: *mut bool,
                data: *mut *mut u8,
            );
        }
        extern "C" {
            #[doc = " Return a pointer to the start of the data referenced by a typed array. The"]
            #[doc = " data is still owned by the typed array, and should not be modified on"]
            #[doc = " another thread. Furthermore, the pointer can become invalid on GC (if the"]
            #[doc = " data is small and fits inside the array's GC header), so callers must take"]
            #[doc = " care not to hold on across anything that could GC."]
            #[doc = ""]
            #[doc = " |obj| must have passed a JS::IsArrayBufferObject test, or somehow be known"]
            #[doc = " that it would pass such a test: it is an ArrayBuffer or a wrapper of an"]
            #[doc = " ArrayBuffer, and the unwrapping will succeed."]
            #[doc = ""]
            #[doc = " |*isSharedMemory| is always set to false.  The argument is present to"]
            #[doc = " simplify its use from code that also interacts with SharedArrayBuffer."]
            #[link_name = "\u{1}_ZN2JS18GetArrayBufferDataEP8JSObjectPbRKNS_15AutoRequireNoGCE"]
            pub fn GetArrayBufferData(
                obj: *mut root::JSObject,
                isSharedMemory: *mut bool,
                arg1: *const root::JS::AutoRequireNoGC,
            ) -> *mut u8;
        }
        extern "C" {
            #[doc = " Detach an ArrayBuffer, causing all associated views to no longer refer to"]
            #[doc = " the ArrayBuffer's original attached memory."]
            #[doc = ""]
            #[doc = " This function throws only if it is provided a non-ArrayBuffer object or if"]
            #[doc = " the provided ArrayBuffer is a WASM-backed ArrayBuffer or an ArrayBuffer used"]
            #[doc = " in asm.js code."]
            #[link_name = "\u{1}_ZN2JS17DetachArrayBufferEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn DetachArrayBuffer(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Steal the contents of the given ArrayBuffer. The ArrayBuffer has its length"]
            #[doc = " set to 0 and its contents array cleared. The caller takes ownership of the"]
            #[doc = " return value and must free it or transfer ownership via"]
            #[doc = " JS::NewArrayBufferWithContents when done using it."]
            #[link_name = "\u{1}_ZN2JS24StealArrayBufferContentsEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn StealArrayBufferContents(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut ::std::os::raw::c_void;
        }
        #[doc = " Vector of characters used for holding build ids."]
        pub type BuildIdCharVector = u8;
        #[doc = " Return the buildId (represented as a sequence of characters) associated with"]
        #[doc = " the currently-executing build. If the JS engine is embedded such that a"]
        #[doc = " single cache entry can be observed by different compiled versions of the JS"]
        #[doc = " engine, it is critical that the buildId shall change for each new build of"]
        #[doc = " the JS engine."]
        pub type BuildIdOp = ::std::option::Option<
            unsafe extern "C" fn(buildId: *mut root::JS::BuildIdCharVector) -> bool,
        >;
        extern "C" {
            #[doc = " Embedder hook to set the buildId-generating function."]
            #[link_name = "\u{1}_ZN2JS19SetProcessBuildIdOpEPFbPN7mozilla6VectorIcLm0EN2js17SystemAllocPolicyEEEE"]
            pub fn SetProcessBuildIdOp(buildIdOp: root::JS::BuildIdOp);
        }
        extern "C" {
            #[doc = " Some cached data is, in addition to being build-specific, CPU-specific: the"]
            #[doc = " cached data depends on CPU features like a particular level of SSE support."]
            #[doc = ""]
            #[doc = " This function produces a buildId that includes:"]
            #[doc = ""]
            #[doc = "   * the buildId defined by the embedder-provided BuildIdOp set by"]
            #[doc = "     JS::SetProcessBuildIdOp, and"]
            #[doc = "   * CPU feature information for the current CPU."]
            #[doc = ""]
            #[doc = " Embedders may use this function to tag cached data whose validity depends"]
            #[doc = " on having consistent buildId *and* on the CPU supporting features identical"]
            #[doc = " to those in play when the cached data was computed."]
            #[link_name = "\u{1}_ZN2JS27GetOptimizedEncodingBuildIdEPN7mozilla6VectorIcLm0EN2js17SystemAllocPolicyEEE"]
            pub fn GetOptimizedEncodingBuildId(buildId: *mut root::JS::BuildIdCharVector) -> bool;
        }
        extern "C" {
            #[doc = " Like the above, but handles a cross-compartment script. If the script is"]
            #[doc = " cross-compartment, it is cloned into the current compartment before"]
            #[doc = " executing."]
            #[link_name = "\u{1}_ZN2JS21CloneAndExecuteScriptEP9JSContextNS_6HandleIP8JSScriptEENS_13MutableHandleINS_5ValueEEE"]
            pub fn CloneAndExecuteScript(
                cx: *mut root::JSContext,
                script: root::JS::Handle<*mut root::JSScript>,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Like CloneAndExecuteScript above, but allows executing under a non-syntactic"]
            #[doc = " environment chain."]
            #[link_name = "\u{1}_ZN2JS21CloneAndExecuteScriptEP9JSContextNS_6HandleINS_13StackGCVectorIP8JSObjectN2js15TempAllocPolicyEEEEENS2_IP8JSScriptEENS_13MutableHandleINS_5ValueEEE"]
            pub fn CloneAndExecuteScript1(
                cx: *mut root::JSContext,
                envChain: root::JS::HandleObjectVector,
                script: root::JS::Handle<*mut root::JSScript>,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Evaluate the given source buffer in the scope of the current global of cx,"]
            #[doc = " and return the completion value in |rval|."]
            #[link_name = "\u{1}_ZN2JS8EvaluateEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIDsEENS_13MutableHandleINS_5ValueEEE"]
            pub fn Evaluate(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<u16>,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " As above, but providing an explicit scope chain.  envChain must not include"]
            #[doc = " the global object on it; that's implicit.  It needs to contain the other"]
            #[doc = " objects that should end up on the script's scope chain."]
            #[link_name = "\u{1}_ZN2JS8EvaluateEP9JSContextNS_6HandleINS_13StackGCVectorIP8JSObjectN2js15TempAllocPolicyEEEEERKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIDsEENS_13MutableHandleINS_5ValueEEE"]
            pub fn Evaluate1(
                cx: *mut root::JSContext,
                envChain: root::JS::HandleObjectVector,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<u16>,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Evaluate the provided UTF-8 data in the scope of the current global of |cx|,"]
            #[doc = " and return the completion value in |rval|.  If the data contains invalid"]
            #[doc = " UTF-8, an error is reported."]
            #[link_name = "\u{1}_ZN2JS8EvaluateEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIN7mozilla8Utf8UnitEEENS_13MutableHandleINS_5ValueEEE"]
            pub fn Evaluate2(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<root::mozilla::Utf8Unit>,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Evaluate the provided UTF-8 data in the scope of the current global of |cx|,"]
            #[doc = " and return the completion value in |rval|.  If the data contains invalid"]
            #[doc = " UTF-8, an error is reported."]
            #[doc = ""]
            #[doc = " The \"DontInflate\" suffix and (semantically unobservable) don't-inflate"]
            #[doc = " characteristic are temporary while bugs in UTF-8 compilation are ironed out."]
            #[doc = " In the long term |JS::Evaluate| for UTF-8 will just never inflate, and this"]
            #[doc = " separate function will die."]
            #[doc = ""]
            #[doc = " NOTE: UTF-8 compilation is currently experimental, and it's possible it has"]
            #[doc = "       as-yet-undiscovered bugs that the UTF-16 compilation functions do not"]
            #[doc = "       have.  Use only if you're willing to take a risk!"]
            #[link_name = "\u{1}_ZN2JS19EvaluateDontInflateEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIN7mozilla8Utf8UnitEEENS_13MutableHandleINS_5ValueEEE"]
            pub fn EvaluateDontInflate(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<root::mozilla::Utf8Unit>,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Evaluate the UTF-8 contents of the file at the given path, and return the"]
            #[doc = " completion value in |rval|.  (The path itself is in the system encoding, not"]
            #[doc = " [necessarily] UTF-8.)  If the contents contain any malformed UTF-8, an error"]
            #[doc = " is reported."]
            #[link_name = "\u{1}_ZN2JS16EvaluateUtf8PathEP9JSContextRKNS_22ReadOnlyCompileOptionsEPKcNS_13MutableHandleINS_5ValueEEE"]
            pub fn EvaluateUtf8Path(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                filename: *const ::std::os::raw::c_char,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Evaluate the UTF-8 contents of the file at the given path, and return the"]
            #[doc = " completion value in |rval|.  (The path itself is in the system encoding, not"]
            #[doc = " [necessarily] UTF-8.)  If the contents contain any malformed UTF-8, an error"]
            #[doc = " is reported."]
            #[doc = ""]
            #[doc = " The \"DontInflate\" suffix and (semantically unobservable) don't-inflate"]
            #[doc = " characteristic are temporary while bugs in UTF-8 compilation are ironed out."]
            #[doc = " In the long term |JS::EvaluateUtf8Path| will just never inflate, and this"]
            #[doc = " separate function will die."]
            #[doc = ""]
            #[doc = " NOTE: UTF-8 compilation is currently experimental, and it's possible it has"]
            #[doc = "       as-yet-undiscovered bugs that the UTF-16 compilation functions do not"]
            #[doc = "       have.  Use only if you're willing to take a risk!"]
            #[link_name = "\u{1}_ZN2JS27EvaluateUtf8PathDontInflateEP9JSContextRKNS_22ReadOnlyCompileOptionsEPKcNS_13MutableHandleINS_5ValueEEE"]
            pub fn EvaluateUtf8PathDontInflate(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                filename: *const ::std::os::raw::c_char,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Compile the provided script using the given options.  Return the script on"]
            #[doc = " success, or return null on failure (usually with an error reported)."]
            #[link_name = "\u{1}_ZN2JS7CompileEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIDsEE"]
            pub fn Compile(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<u16>,
            ) -> *mut root::JSScript;
        }
        extern "C" {
            #[doc = " Compile the provided script using the given options.  Return the script on"]
            #[doc = " success, or return null on failure (usually with an error reported)."]
            #[link_name = "\u{1}_ZN2JS7CompileEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIN7mozilla8Utf8UnitEEE"]
            pub fn Compile1(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<root::mozilla::Utf8Unit>,
            ) -> *mut root::JSScript;
        }
        extern "C" {
            #[doc = " Identical to |JS::Compile| for UTF-8, except this function directly parses"]
            #[doc = " its UTF-8 input without inflating it to UTF-16 and parsing that."]
            #[doc = ""]
            #[doc = " The \"DontInflate\" suffix and (semantically unobservable) don't-inflate"]
            #[doc = " characteristic are temporary while bugs in UTF-8 compilation are ironed out."]
            #[doc = " In the long term |JS::Compile| for UTF-8 will just never inflate, and this"]
            #[doc = " separate function will die."]
            #[doc = ""]
            #[doc = " NOTE: UTF-8 compilation is currently experimental, and it's possible it has"]
            #[doc = "       as-yet-undiscovered bugs that the UTF-16 compilation functions do not"]
            #[doc = "       have.  Use only if you're willing to take a risk!"]
            #[link_name = "\u{1}_ZN2JS18CompileDontInflateEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIN7mozilla8Utf8UnitEEE"]
            pub fn CompileDontInflate(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<root::mozilla::Utf8Unit>,
            ) -> *mut root::JSScript;
        }
        extern "C" {
            #[doc = " Compile the UTF-8 contents of the given file into a script.  It is an error"]
            #[doc = " if the file contains invalid UTF-8.  Return the script on success, or return"]
            #[doc = " null on failure (usually with an error reported)."]
            #[link_name = "\u{1}_ZN2JS15CompileUtf8FileEP9JSContextRKNS_22ReadOnlyCompileOptionsEP8_IO_FILE"]
            pub fn CompileUtf8File(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                file: *mut root::FILE,
            ) -> *mut root::JSScript;
        }
        extern "C" {
            #[doc = " Compile the UTF-8 contents of the given file into a script.  It is an error"]
            #[doc = " if the file contains invalid UTF-8.  Return the script on success, or return"]
            #[doc = " null on failure (usually with an error reported)."]
            #[doc = ""]
            #[doc = " NOTE: UTF-8 compilation is currently experimental, and it's possible it has"]
            #[doc = "       as-yet-undiscovered bugs not present in |JS::CompileUtf8File| that"]
            #[doc = "       first inflates to UTF-16.  Use only if you're willing to take a risk!"]
            #[link_name = "\u{1}_ZN2JS26CompileUtf8FileDontInflateEP9JSContextRKNS_22ReadOnlyCompileOptionsEP8_IO_FILE"]
            pub fn CompileUtf8FileDontInflate(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                file: *mut root::FILE,
            ) -> *mut root::JSScript;
        }
        extern "C" {
            #[doc = " Compile the UTF-8 contents of the file at the given path into a script."]
            #[doc = " (The path itself is in the system encoding, not [necessarily] UTF-8.)  It"]
            #[doc = " is an error if the file's contents are invalid UTF-8.  Return the script on"]
            #[doc = " success, or return null on failure (usually with an error reported)."]
            #[link_name = "\u{1}_ZN2JS15CompileUtf8PathEP9JSContextRKNS_22ReadOnlyCompileOptionsEPKc"]
            pub fn CompileUtf8Path(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                filename: *const ::std::os::raw::c_char,
            ) -> *mut root::JSScript;
        }
        extern "C" {
            #[doc = " Compile the UTF-8 contents of the file at the given path into a script."]
            #[doc = " (The path itself is in the system encoding, not [necessarily] UTF-8.)  It"]
            #[doc = " is an error if the file's contents are invalid UTF-8.  Return the script on"]
            #[doc = " success, or return null on failure (usually with an error reported)."]
            #[doc = ""]
            #[doc = " NOTE: UTF-8 compilation is currently experimental, and it's possible it has"]
            #[doc = "       as-yet-undiscovered bugs not present in |JS::CompileUtf8Path| that"]
            #[doc = "       first inflates to UTF-16.  Use only if you're willing to take a risk!"]
            #[link_name = "\u{1}_ZN2JS26CompileUtf8PathDontInflateEP9JSContextRKNS_22ReadOnlyCompileOptionsEPKc"]
            pub fn CompileUtf8PathDontInflate(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                filename: *const ::std::os::raw::c_char,
            ) -> *mut root::JSScript;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS27CompileForNonSyntacticScopeEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIDsEE"]
            pub fn CompileForNonSyntacticScope(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<u16>,
            ) -> *mut root::JSScript;
        }
        extern "C" {
            #[doc = " Compile the provided UTF-8 data into a script in a non-syntactic scope.  It"]
            #[doc = " is an error if the data contains invalid UTF-8.  Return the script on"]
            #[doc = " success, or return null on failure (usually with an error reported)."]
            #[link_name = "\u{1}_ZN2JS27CompileForNonSyntacticScopeEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIN7mozilla8Utf8UnitEEE"]
            pub fn CompileForNonSyntacticScope1(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<root::mozilla::Utf8Unit>,
            ) -> *mut root::JSScript;
        }
        extern "C" {
            #[doc = " Compile the provided UTF-8 data into a script in a non-syntactic scope.  It"]
            #[doc = " is an error if the data contains invalid UTF-8.  Return the script on"]
            #[doc = " success, or return null on failure (usually with an error reported)."]
            #[doc = ""]
            #[doc = " The \"DontInflate\" suffix and (semantically unobservable) don't-inflate"]
            #[doc = " characteristic are temporary while bugs in UTF-8 compilation are ironed out."]
            #[doc = " In the long term |JS::CompileForNonSyntacticScope| for UTF-8 will just never"]
            #[doc = " inflate, and this separate function will die."]
            #[doc = ""]
            #[doc = " NOTE: UTF-8 compilation is currently experimental, and it's possible it has"]
            #[doc = "       as-yet-undiscovered bugs that the UTF-16 compilation functions do not"]
            #[doc = "       have.  Use only if you're willing to take a risk!"]
            #[link_name = "\u{1}_ZN2JS38CompileForNonSyntacticScopeDontInflateEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIN7mozilla8Utf8UnitEEE"]
            pub fn CompileForNonSyntacticScopeDontInflate(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<root::mozilla::Utf8Unit>,
            ) -> *mut root::JSScript;
        }
        extern "C" {
            #[doc = " Compile a function with envChain plus the global as its scope chain."]
            #[doc = " envChain must contain objects in the current compartment of cx.  The actual"]
            #[doc = " scope chain used for the function will consist of With wrappers for those"]
            #[doc = " objects, followed by the current global of the compartment cx is in.  This"]
            #[doc = " global must not be explicitly included in the scope chain."]
            #[link_name = "\u{1}_ZN2JS15CompileFunctionEP9JSContextNS_6HandleINS_13StackGCVectorIP8JSObjectN2js15TempAllocPolicyEEEEERKNS_22ReadOnlyCompileOptionsEPKcjPKSE_RNS_10SourceTextIDsEE"]
            pub fn CompileFunction(
                cx: *mut root::JSContext,
                envChain: root::JS::HandleObjectVector,
                options: *const root::JS::ReadOnlyCompileOptions,
                name: *const ::std::os::raw::c_char,
                nargs: ::std::os::raw::c_uint,
                argnames: *const *const ::std::os::raw::c_char,
                srcBuf: *mut root::JS::SourceText<u16>,
            ) -> *mut root::JSFunction;
        }
        extern "C" {
            #[doc = " Compile a function with envChain plus the global as its scope chain."]
            #[doc = " envChain must contain objects in the current compartment of cx.  The actual"]
            #[doc = " scope chain used for the function will consist of With wrappers for those"]
            #[doc = " objects, followed by the current global of the compartment cx is in.  This"]
            #[doc = " global must not be explicitly included in the scope chain."]
            #[link_name = "\u{1}_ZN2JS15CompileFunctionEP9JSContextNS_6HandleINS_13StackGCVectorIP8JSObjectN2js15TempAllocPolicyEEEEERKNS_22ReadOnlyCompileOptionsEPKcjPKSE_RNS_10SourceTextIN7mozilla8Utf8UnitEEE"]
            pub fn CompileFunction1(
                cx: *mut root::JSContext,
                envChain: root::JS::HandleObjectVector,
                options: *const root::JS::ReadOnlyCompileOptions,
                name: *const ::std::os::raw::c_char,
                nargs: ::std::os::raw::c_uint,
                argnames: *const *const ::std::os::raw::c_char,
                srcBuf: *mut root::JS::SourceText<root::mozilla::Utf8Unit>,
            ) -> *mut root::JSFunction;
        }
        extern "C" {
            #[doc = " Identical to the CompileFunction overload above for UTF-8, but with"]
            #[doc = " Rust-friendly ergonomics."]
            #[link_name = "\u{1}_ZN2JS19CompileFunctionUtf8EP9JSContextNS_6HandleINS_13StackGCVectorIP8JSObjectN2js15TempAllocPolicyEEEEERKNS_22ReadOnlyCompileOptionsEPKcjPKSE_SE_m"]
            pub fn CompileFunctionUtf8(
                cx: *mut root::JSContext,
                envChain: root::JS::HandleObjectVector,
                options: *const root::JS::ReadOnlyCompileOptions,
                name: *const ::std::os::raw::c_char,
                nargs: ::std::os::raw::c_uint,
                argnames: *const *const ::std::os::raw::c_char,
                utf8: *const ::std::os::raw::c_char,
                length: usize,
            ) -> *mut root::JSFunction;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23InitScriptSourceElementEP9JSContextNS_6HandleIP8JSScriptEENS2_IP8JSObjectEENS2_IP8JSStringEE"]
            pub fn InitScriptSourceElement(
                cx: *mut root::JSContext,
                script: root::JS::Handle<*mut root::JSScript>,
                element: root::JS::Handle<*mut root::JSObject>,
                elementAttrName: root::JS::Handle<*mut root::JSString>,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS22ExposeScriptToDebuggerEP9JSContextNS_6HandleIP8JSScriptEE"]
            pub fn ExposeScriptToDebugger(
                cx: *mut root::JSContext,
                script: root::JS::Handle<*mut root::JSScript>,
            );
        }
        #[repr(C, packed)]
        #[derive(Debug, Copy, Clone)]
        pub struct ContextOptions {
            pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 3usize], u8>,
        }
        #[test]
        fn bindgen_test_layout_ContextOptions() {
            assert_eq!(
                ::std::mem::size_of::<ContextOptions>(),
                3usize,
                concat!("Size of: ", stringify!(ContextOptions))
            );
            assert_eq!(
                ::std::mem::align_of::<ContextOptions>(),
                1usize,
                concat!("Alignment of ", stringify!(ContextOptions))
            );
        }
        impl ContextOptions {
            #[inline]
            pub fn asmJS_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_asmJS_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn wasm_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_wasm_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn wasmForTrustedPrinciples_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_wasmForTrustedPrinciples_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn wasmVerbose_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_wasmVerbose_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn wasmBaseline_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_wasmBaseline_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(4usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn wasmIon_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_wasmIon_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(5usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn wasmCranelift_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_wasmCranelift_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn wasmGc_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_wasmGc_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn testWasmAwaitTier2_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_testWasmAwaitTier2_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn throwOnAsmJSValidationFailure_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_throwOnAsmJSValidationFailure_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn asyncStack_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_asyncStack_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn throwOnDebuggeeWouldRun_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_throwOnDebuggeeWouldRun_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn dumpStackOnDebuggeeWouldRun_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_dumpStackOnDebuggeeWouldRun_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn werror_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_werror_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(13usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn strictMode_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_strictMode_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(14usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn extraWarnings_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_extraWarnings_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(15usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn fuzzing_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_fuzzing_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(16usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(
                asmJS_: bool,
                wasm_: bool,
                wasmForTrustedPrinciples_: bool,
                wasmVerbose_: bool,
                wasmBaseline_: bool,
                wasmIon_: bool,
                wasmCranelift_: bool,
                wasmGc_: bool,
                testWasmAwaitTier2_: bool,
                throwOnAsmJSValidationFailure_: bool,
                asyncStack_: bool,
                throwOnDebuggeeWouldRun_: bool,
                dumpStackOnDebuggeeWouldRun_: bool,
                werror_: bool,
                strictMode_: bool,
                extraWarnings_: bool,
                fuzzing_: bool,
            ) -> root::__BindgenBitfieldUnit<[u8; 3usize], u8> {
                let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 3usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8, {
                    let asmJS_: u8 = unsafe { ::std::mem::transmute(asmJS_) };
                    asmJS_ as u64
                });
                __bindgen_bitfield_unit.set(1usize, 1u8, {
                    let wasm_: u8 = unsafe { ::std::mem::transmute(wasm_) };
                    wasm_ as u64
                });
                __bindgen_bitfield_unit.set(2usize, 1u8, {
                    let wasmForTrustedPrinciples_: u8 =
                        unsafe { ::std::mem::transmute(wasmForTrustedPrinciples_) };
                    wasmForTrustedPrinciples_ as u64
                });
                __bindgen_bitfield_unit.set(3usize, 1u8, {
                    let wasmVerbose_: u8 = unsafe { ::std::mem::transmute(wasmVerbose_) };
                    wasmVerbose_ as u64
                });
                __bindgen_bitfield_unit.set(4usize, 1u8, {
                    let wasmBaseline_: u8 = unsafe { ::std::mem::transmute(wasmBaseline_) };
                    wasmBaseline_ as u64
                });
                __bindgen_bitfield_unit.set(5usize, 1u8, {
                    let wasmIon_: u8 = unsafe { ::std::mem::transmute(wasmIon_) };
                    wasmIon_ as u64
                });
                __bindgen_bitfield_unit.set(6usize, 1u8, {
                    let wasmCranelift_: u8 = unsafe { ::std::mem::transmute(wasmCranelift_) };
                    wasmCranelift_ as u64
                });
                __bindgen_bitfield_unit.set(7usize, 1u8, {
                    let wasmGc_: u8 = unsafe { ::std::mem::transmute(wasmGc_) };
                    wasmGc_ as u64
                });
                __bindgen_bitfield_unit.set(8usize, 1u8, {
                    let testWasmAwaitTier2_: u8 =
                        unsafe { ::std::mem::transmute(testWasmAwaitTier2_) };
                    testWasmAwaitTier2_ as u64
                });
                __bindgen_bitfield_unit.set(9usize, 1u8, {
                    let throwOnAsmJSValidationFailure_: u8 =
                        unsafe { ::std::mem::transmute(throwOnAsmJSValidationFailure_) };
                    throwOnAsmJSValidationFailure_ as u64
                });
                __bindgen_bitfield_unit.set(10usize, 1u8, {
                    let asyncStack_: u8 = unsafe { ::std::mem::transmute(asyncStack_) };
                    asyncStack_ as u64
                });
                __bindgen_bitfield_unit.set(11usize, 1u8, {
                    let throwOnDebuggeeWouldRun_: u8 =
                        unsafe { ::std::mem::transmute(throwOnDebuggeeWouldRun_) };
                    throwOnDebuggeeWouldRun_ as u64
                });
                __bindgen_bitfield_unit.set(12usize, 1u8, {
                    let dumpStackOnDebuggeeWouldRun_: u8 =
                        unsafe { ::std::mem::transmute(dumpStackOnDebuggeeWouldRun_) };
                    dumpStackOnDebuggeeWouldRun_ as u64
                });
                __bindgen_bitfield_unit.set(13usize, 1u8, {
                    let werror_: u8 = unsafe { ::std::mem::transmute(werror_) };
                    werror_ as u64
                });
                __bindgen_bitfield_unit.set(14usize, 1u8, {
                    let strictMode_: u8 = unsafe { ::std::mem::transmute(strictMode_) };
                    strictMode_ as u64
                });
                __bindgen_bitfield_unit.set(15usize, 1u8, {
                    let extraWarnings_: u8 = unsafe { ::std::mem::transmute(extraWarnings_) };
                    extraWarnings_ as u64
                });
                __bindgen_bitfield_unit.set(16usize, 1u8, {
                    let fuzzing_: u8 = unsafe { ::std::mem::transmute(fuzzing_) };
                    fuzzing_ as u64
                });
                __bindgen_bitfield_unit
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17ContextOptionsRefEP9JSContext"]
            pub fn ContextOptionsRef(cx: *mut root::JSContext) -> *mut root::JS::ContextOptions;
        }
        extern "C" {
            #[doc = " ES6 draft 20141224, 7.1.1, second algorithm."]
            #[doc = ""]
            #[doc = " Most users shouldn't call this -- use JS::ToBoolean, ToNumber, or ToString"]
            #[doc = " instead.  This will typically only be called from custom convert hooks that"]
            #[doc = " wish to fall back to the ES6 default conversion behavior shared by most"]
            #[doc = " objects in JS, codified as OrdinaryToPrimitive."]
            #[link_name = "\u{1}_ZN2JS19OrdinaryToPrimitiveEP9JSContextNS_6HandleIP8JSObjectEE6JSTypeNS_13MutableHandleINS_5ValueEEE"]
            pub fn OrdinaryToPrimitive(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                type_: root::JSType,
                vp: root::JS::MutableHandleValue,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Store in |out| the null-terminated, base-10 result of |ToString| applied to"]
            #[doc = " |d| per <https://tc39.es/ecma262/#sec-tostring-applied-to-the-number-type>."]
            #[doc = " (This will produce \"NaN\", \"-Infinity\", or \"Infinity\" for non-finite |d|.)"]
            #[link_name = "\u{1}_ZN2JS14NumberToStringEdRA32_c"]
            pub fn NumberToString(d: f64, out: *mut [::std::os::raw::c_char; 32usize]);
        }
        extern "C" {
            #[doc = " Re-query the system to determine the current time zone adjustment from UTC,"]
            #[doc = " including any component due to DST.  If the time zone has changed, this will"]
            #[doc = " cause all Date object non-UTC methods and formatting functions to produce"]
            #[doc = " appropriately adjusted results."]
            #[doc = ""]
            #[doc = " Left to its own devices, SpiderMonkey itself may occasionally try to detect"]
            #[doc = " system time changes.  However, no particular frequency of checking is"]
            #[doc = " guaranteed.  Embedders unable to accept occasional inaccuracies should call"]
            #[doc = " this method in response to system time changes, or immediately before"]
            #[doc = " operations requiring instantaneous correctness, to guarantee correct"]
            #[doc = " behavior."]
            #[link_name = "\u{1}_ZN2JS13ResetTimeZoneEv"]
            pub fn ResetTimeZone();
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ClippedTime {
            pub t: f64,
        }
        #[test]
        fn bindgen_test_layout_ClippedTime() {
            assert_eq!(
                ::std::mem::size_of::<ClippedTime>(),
                8usize,
                concat!("Size of: ", stringify!(ClippedTime))
            );
            assert_eq!(
                ::std::mem::align_of::<ClippedTime>(),
                8usize,
                concat!("Alignment of ", stringify!(ClippedTime))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ClippedTime>())).t as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClippedTime),
                    "::",
                    stringify!(t)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13NewDateObjectEP9JSContextNS_11ClippedTimeE"]
            pub fn NewDateObject(
                cx: *mut root::JSContext,
                time: root::JS::ClippedTime,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Create a new Date object for a year/month/day-of-month/hour/minute/second."]
            #[doc = ""]
            #[doc = " The created date is initialized with the time value"]
            #[doc = ""]
            #[doc = "   TimeClip(UTC(MakeDate(MakeDay(year, mon, mday),"]
            #[doc = "                MakeTime(hour, min, sec, 0.0))))"]
            #[doc = ""]
            #[doc = " where each function/operation is as specified in ECMAScript."]
            #[link_name = "\u{1}_ZN2JS13NewDateObjectEP9JSContextiiiiii"]
            pub fn NewDateObject1(
                cx: *mut root::JSContext,
                year: ::std::os::raw::c_int,
                mon: ::std::os::raw::c_int,
                mday: ::std::os::raw::c_int,
                hour: ::std::os::raw::c_int,
                min: ::std::os::raw::c_int,
                sec: ::std::os::raw::c_int,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " On success, returns true, setting |*isDate| to true if |obj| is a Date"]
            #[doc = " object or a wrapper around one, or to false if not.  Returns false on"]
            #[doc = " failure."]
            #[doc = ""]
            #[doc = " This method returns true with |*isDate == false| when passed an ES6 proxy"]
            #[doc = " whose target is a Date, or when passed a revoked proxy."]
            #[link_name = "\u{1}_ZN2JS12ObjectIsDateEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn ObjectIsDate(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                isDate: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS8MakeDateEdjj"]
            pub fn MakeDate(
                year: f64,
                month: ::std::os::raw::c_uint,
                day: ::std::os::raw::c_uint,
            ) -> f64;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS8MakeDateEdjjd"]
            pub fn MakeDate1(
                year: f64,
                month: ::std::os::raw::c_uint,
                day: ::std::os::raw::c_uint,
                time: f64,
            ) -> f64;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS12YearFromTimeEd"]
            pub fn YearFromTime(time: f64) -> f64;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13MonthFromTimeEd"]
            pub fn MonthFromTime(time: f64) -> f64;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS11DayFromTimeEd"]
            pub fn DayFromTime(time: f64) -> f64;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS11DayFromYearEd"]
            pub fn DayFromYear(year: f64) -> f64;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13DayWithinYearEdd"]
            pub fn DayWithinYear(time: f64, year: f64) -> f64;
        }
        pub type ReduceMicrosecondTimePrecisionCallback =
            ::std::option::Option<unsafe extern "C" fn(arg1: f64) -> f64>;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS41SetReduceMicrosecondTimePrecisionCallbackEPFddE"]
            pub fn SetReduceMicrosecondTimePrecisionCallback(
                callback: root::JS::ReduceMicrosecondTimePrecisionCallback,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS21SetTimeResolutionUsecEjb"]
            pub fn SetTimeResolutionUsec(resolution: u32, jitter: bool);
        }
        extern "C" {
            #[doc = " Store |v1 === v2| to |*equal| -- strict equality, which performs no"]
            #[doc = " conversions on |v1| or |v2| before comparing."]
            #[doc = ""]
            #[doc = " This operation can fail only if an internal error occurs (e.g. OOM while"]
            #[doc = " linearizing a string value)."]
            #[link_name = "\u{1}_ZN2JS13StrictlyEqualEP9JSContextNS_6HandleINS_5ValueEEES4_Pb"]
            pub fn StrictlyEqual(
                cx: *mut root::JSContext,
                v1: root::JS::Handle<root::JS::Value>,
                v2: root::JS::Handle<root::JS::Value>,
                equal: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Store |v1 == v2| to |*equal| -- loose equality, which may perform"]
            #[doc = " user-modifiable conversions on |v1| or |v2|."]
            #[doc = ""]
            #[doc = " This operation can fail if a user-modifiable conversion fails *or* if an"]
            #[doc = " internal error occurs. (e.g. OOM while linearizing a string value)."]
            #[link_name = "\u{1}_ZN2JS12LooselyEqualEP9JSContextNS_6HandleINS_5ValueEEES4_Pb"]
            pub fn LooselyEqual(
                cx: *mut root::JSContext,
                v1: root::JS::Handle<root::JS::Value>,
                v2: root::JS::Handle<root::JS::Value>,
                equal: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Stores |SameValue(v1, v2)| to |*equal| -- using the SameValue operation"]
            #[doc = " defined in ECMAScript, initially exposed to script as |Object.is|.  SameValue"]
            #[doc = " behaves identically to strict equality, except that it equates two NaN values"]
            #[doc = " and does not equate differently-signed zeroes.  It performs no conversions on"]
            #[doc = " |v1| or |v2| before comparing."]
            #[doc = ""]
            #[doc = " This operation can fail only if an internal error occurs (e.g. OOM while"]
            #[doc = " linearizing a string value)."]
            #[link_name = "\u{1}_ZN2JS9SameValueEP9JSContextNS_6HandleINS_5ValueEEES4_Pb"]
            pub fn SameValue(
                cx: *mut root::JSContext,
                v1: root::JS::Handle<root::JS::Value>,
                v2: root::JS::Handle<root::JS::Value>,
                same: *mut bool,
            ) -> bool;
        }
        #[doc = " A convenience class for imitating a JS for-of loop. Typical usage:"]
        #[doc = ""]
        #[doc = "     JS::ForOfIterator it(cx);"]
        #[doc = "     if (!it.init(iterable)) {"]
        #[doc = "       return false;"]
        #[doc = "     }"]
        #[doc = "     JS::Rooted<JS::Value> val(cx);"]
        #[doc = "     while (true) {"]
        #[doc = "       bool done;"]
        #[doc = "       if (!it.next(&val, &done)) {"]
        #[doc = "         return false;"]
        #[doc = "       }"]
        #[doc = "       if (done) {"]
        #[doc = "         break;"]
        #[doc = "       }"]
        #[doc = "       if (!DoStuff(cx, val)) {"]
        #[doc = "         return false;"]
        #[doc = "       }"]
        #[doc = "     }"]
        #[repr(C)]
        pub struct ForOfIterator {
            pub cx_: *mut root::JSContext,
            pub iterator: root::JS::Rooted<*mut root::JSObject>,
            pub nextMethod: root::JS::Rooted<root::JS::Value>,
            pub index: u32,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ForOfIterator_NonIterableBehavior {
            ThrowOnNonIterable = 0,
            AllowNonIterable = 1,
        }
        pub const ForOfIterator_NOT_ARRAY: u32 = 4294967295;
        #[test]
        fn bindgen_test_layout_ForOfIterator() {
            assert_eq!(
                ::std::mem::size_of::<ForOfIterator>(),
                64usize,
                concat!("Size of: ", stringify!(ForOfIterator))
            );
            assert_eq!(
                ::std::mem::align_of::<ForOfIterator>(),
                8usize,
                concat!("Alignment of ", stringify!(ForOfIterator))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ForOfIterator>())).cx_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ForOfIterator),
                    "::",
                    stringify!(cx_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ForOfIterator>())).iterator as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ForOfIterator),
                    "::",
                    stringify!(iterator)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ForOfIterator>())).nextMethod as *const _ as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ForOfIterator),
                    "::",
                    stringify!(nextMethod)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ForOfIterator>())).index as *const _ as usize },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ForOfIterator),
                    "::",
                    stringify!(index)
                )
            );
        }
        extern "C" {
            #[doc = " An API akin to JS_Stringify but with the goal of not having observable"]
            #[doc = " side-effects when the stringification is performed.  This means it does not"]
            #[doc = " allow a replacer or a custom space and has the following constraints on its"]
            #[doc = " input:"]
            #[doc = ""]
            #[doc = " 1) The input must be a plain object or array, not an abitrary value."]
            #[doc = " 2) Every value in the graph reached by the algorithm starting with this"]
            #[doc = "    object must be one of the following: null, undefined, a string (NOT a"]
            #[doc = "    string object!), a boolean, a finite number (i.e. no NaN or Infinity or"]
            #[doc = "    -Infinity), a plain object with no accessor properties, or an Array with"]
            #[doc = "    no holes."]
            #[doc = ""]
            #[doc = " The actual behavior differs from JS_Stringify only in asserting the above and"]
            #[doc = " NOT attempting to get the \"toJSON\" property from things, since that could"]
            #[doc = " clearly have side-effects."]
            #[link_name = "\u{1}_ZN2JS17ToJSONMaybeSafelyEP9JSContextNS_6HandleIP8JSObjectEEPFbPKDsjPvES8_"]
            pub fn ToJSONMaybeSafely(
                cx: *mut root::JSContext,
                input: root::JS::Handle<*mut root::JSObject>,
                callback: root::JSONWriteCallback,
                data: *mut ::std::os::raw::c_void,
            ) -> bool;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TabSizes {
            pub objects_: usize,
            pub strings_: usize,
            pub private_: usize,
            pub other_: usize,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum TabSizes_Kind {
            Objects = 0,
            Strings = 1,
            Private = 2,
            Other = 3,
        }
        #[test]
        fn bindgen_test_layout_TabSizes() {
            assert_eq!(
                ::std::mem::size_of::<TabSizes>(),
                32usize,
                concat!("Size of: ", stringify!(TabSizes))
            );
            assert_eq!(
                ::std::mem::align_of::<TabSizes>(),
                8usize,
                concat!("Alignment of ", stringify!(TabSizes))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TabSizes>())).objects_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TabSizes),
                    "::",
                    stringify!(objects_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TabSizes>())).strings_ as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TabSizes),
                    "::",
                    stringify!(strings_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TabSizes>())).private_ as *const _ as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TabSizes),
                    "::",
                    stringify!(private_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TabSizes>())).other_ as *const _ as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TabSizes),
                    "::",
                    stringify!(other_)
                )
            );
        }
        #[doc = " These are the measurements used by Servo."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ServoSizes {
            pub gcHeapUsed: usize,
            pub gcHeapUnused: usize,
            pub gcHeapAdmin: usize,
            pub gcHeapDecommitted: usize,
            pub mallocHeap: usize,
            pub nonHeap: usize,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ServoSizes_Kind {
            GCHeapUsed = 0,
            GCHeapUnused = 1,
            GCHeapAdmin = 2,
            GCHeapDecommitted = 3,
            MallocHeap = 4,
            NonHeap = 5,
            Ignore = 6,
        }
        #[test]
        fn bindgen_test_layout_ServoSizes() {
            assert_eq!(
                ::std::mem::size_of::<ServoSizes>(),
                48usize,
                concat!("Size of: ", stringify!(ServoSizes))
            );
            assert_eq!(
                ::std::mem::align_of::<ServoSizes>(),
                8usize,
                concat!("Alignment of ", stringify!(ServoSizes))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ServoSizes>())).gcHeapUsed as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ServoSizes),
                    "::",
                    stringify!(gcHeapUsed)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ServoSizes>())).gcHeapUnused as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ServoSizes),
                    "::",
                    stringify!(gcHeapUnused)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ServoSizes>())).gcHeapAdmin as *const _ as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ServoSizes),
                    "::",
                    stringify!(gcHeapAdmin)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ServoSizes>())).gcHeapDecommitted as *const _ as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ServoSizes),
                    "::",
                    stringify!(gcHeapDecommitted)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ServoSizes>())).mallocHeap as *const _ as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ServoSizes),
                    "::",
                    stringify!(mallocHeap)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ServoSizes>())).nonHeap as *const _ as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ServoSizes),
                    "::",
                    stringify!(nonHeap)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ClassInfo {
            pub objectsGCHeap: usize,
            pub objectsMallocHeapSlots: usize,
            pub objectsMallocHeapElementsNormal: usize,
            pub objectsMallocHeapElementsAsmJS: usize,
            pub objectsMallocHeapMisc: usize,
            pub objectsNonHeapElementsNormal: usize,
            pub objectsNonHeapElementsShared: usize,
            pub objectsNonHeapElementsWasm: usize,
            pub objectsNonHeapCodeWasm: usize,
            pub wasmGuardPages: usize,
        }
        #[test]
        fn bindgen_test_layout_ClassInfo() {
            assert_eq!(
                ::std::mem::size_of::<ClassInfo>(),
                80usize,
                concat!("Size of: ", stringify!(ClassInfo))
            );
            assert_eq!(
                ::std::mem::align_of::<ClassInfo>(),
                8usize,
                concat!("Alignment of ", stringify!(ClassInfo))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ClassInfo>())).objectsGCHeap as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassInfo),
                    "::",
                    stringify!(objectsGCHeap)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ClassInfo>())).objectsMallocHeapSlots as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassInfo),
                    "::",
                    stringify!(objectsMallocHeapSlots)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ClassInfo>())).objectsMallocHeapElementsNormal
                        as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassInfo),
                    "::",
                    stringify!(objectsMallocHeapElementsNormal)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ClassInfo>())).objectsMallocHeapElementsAsmJS as *const _
                        as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassInfo),
                    "::",
                    stringify!(objectsMallocHeapElementsAsmJS)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ClassInfo>())).objectsMallocHeapMisc as *const _ as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassInfo),
                    "::",
                    stringify!(objectsMallocHeapMisc)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ClassInfo>())).objectsNonHeapElementsNormal as *const _
                        as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassInfo),
                    "::",
                    stringify!(objectsNonHeapElementsNormal)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ClassInfo>())).objectsNonHeapElementsShared as *const _
                        as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassInfo),
                    "::",
                    stringify!(objectsNonHeapElementsShared)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ClassInfo>())).objectsNonHeapElementsWasm as *const _
                        as usize
                },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassInfo),
                    "::",
                    stringify!(objectsNonHeapElementsWasm)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ClassInfo>())).objectsNonHeapCodeWasm as *const _
                        as usize
                },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassInfo),
                    "::",
                    stringify!(objectsNonHeapCodeWasm)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ClassInfo>())).wasmGuardPages as *const _ as usize
                },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ClassInfo),
                    "::",
                    stringify!(wasmGuardPages)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ShapeInfo {
            pub shapesGCHeapTree: usize,
            pub shapesGCHeapDict: usize,
            pub shapesGCHeapBase: usize,
            pub shapesMallocHeapTreeTables: usize,
            pub shapesMallocHeapDictTables: usize,
            pub shapesMallocHeapTreeChildren: usize,
        }
        #[test]
        fn bindgen_test_layout_ShapeInfo() {
            assert_eq!(
                ::std::mem::size_of::<ShapeInfo>(),
                48usize,
                concat!("Size of: ", stringify!(ShapeInfo))
            );
            assert_eq!(
                ::std::mem::align_of::<ShapeInfo>(),
                8usize,
                concat!("Alignment of ", stringify!(ShapeInfo))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ShapeInfo>())).shapesGCHeapTree as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ShapeInfo),
                    "::",
                    stringify!(shapesGCHeapTree)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ShapeInfo>())).shapesGCHeapDict as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ShapeInfo),
                    "::",
                    stringify!(shapesGCHeapDict)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ShapeInfo>())).shapesGCHeapBase as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ShapeInfo),
                    "::",
                    stringify!(shapesGCHeapBase)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ShapeInfo>())).shapesMallocHeapTreeTables as *const _
                        as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ShapeInfo),
                    "::",
                    stringify!(shapesMallocHeapTreeTables)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ShapeInfo>())).shapesMallocHeapDictTables as *const _
                        as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ShapeInfo),
                    "::",
                    stringify!(shapesMallocHeapDictTables)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ShapeInfo>())).shapesMallocHeapTreeChildren as *const _
                        as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ShapeInfo),
                    "::",
                    stringify!(shapesMallocHeapTreeChildren)
                )
            );
        }
        #[doc = " Holds data about a notable class (one whose combined object and shape"]
        #[doc = " instances use more than a certain amount of memory) so we can report it"]
        #[doc = " individually."]
        #[doc = ""]
        #[doc = " The only difference between this class and ClassInfo is that this class"]
        #[doc = " holds a copy of the filename."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct NotableClassInfo {
            pub _base: root::JS::ClassInfo,
            pub className_: root::JS::UniqueChars,
        }
        #[test]
        fn bindgen_test_layout_NotableClassInfo() {
            assert_eq!(
                ::std::mem::size_of::<NotableClassInfo>(),
                88usize,
                concat!("Size of: ", stringify!(NotableClassInfo))
            );
            assert_eq!(
                ::std::mem::align_of::<NotableClassInfo>(),
                8usize,
                concat!("Alignment of ", stringify!(NotableClassInfo))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<NotableClassInfo>())).className_ as *const _ as usize
                },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(NotableClassInfo),
                    "::",
                    stringify!(className_)
                )
            );
        }
        #[doc = " Data for tracking JIT-code memory usage."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CodeSizes {
            pub ion: usize,
            pub baseline: usize,
            pub regexp: usize,
            pub other: usize,
            pub unused: usize,
        }
        #[test]
        fn bindgen_test_layout_CodeSizes() {
            assert_eq!(
                ::std::mem::size_of::<CodeSizes>(),
                40usize,
                concat!("Size of: ", stringify!(CodeSizes))
            );
            assert_eq!(
                ::std::mem::align_of::<CodeSizes>(),
                8usize,
                concat!("Alignment of ", stringify!(CodeSizes))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<CodeSizes>())).ion as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CodeSizes),
                    "::",
                    stringify!(ion)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<CodeSizes>())).baseline as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CodeSizes),
                    "::",
                    stringify!(baseline)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<CodeSizes>())).regexp as *const _ as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CodeSizes),
                    "::",
                    stringify!(regexp)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<CodeSizes>())).other as *const _ as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CodeSizes),
                    "::",
                    stringify!(other)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<CodeSizes>())).unused as *const _ as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CodeSizes),
                    "::",
                    stringify!(unused)
                )
            );
        }
        #[doc = " Data for tracking GC memory usage."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GCSizes {
            pub marker: usize,
            pub nurseryCommitted: usize,
            pub nurseryMallocedBuffers: usize,
            pub storeBufferVals: usize,
            pub storeBufferCells: usize,
            pub storeBufferSlots: usize,
            pub storeBufferWholeCells: usize,
            pub storeBufferGenerics: usize,
        }
        #[test]
        fn bindgen_test_layout_GCSizes() {
            assert_eq!(
                ::std::mem::size_of::<GCSizes>(),
                64usize,
                concat!("Size of: ", stringify!(GCSizes))
            );
            assert_eq!(
                ::std::mem::align_of::<GCSizes>(),
                8usize,
                concat!("Alignment of ", stringify!(GCSizes))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<GCSizes>())).marker as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GCSizes),
                    "::",
                    stringify!(marker)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GCSizes>())).nurseryCommitted as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GCSizes),
                    "::",
                    stringify!(nurseryCommitted)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GCSizes>())).nurseryMallocedBuffers as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GCSizes),
                    "::",
                    stringify!(nurseryMallocedBuffers)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<GCSizes>())).storeBufferVals as *const _ as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GCSizes),
                    "::",
                    stringify!(storeBufferVals)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GCSizes>())).storeBufferCells as *const _ as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GCSizes),
                    "::",
                    stringify!(storeBufferCells)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GCSizes>())).storeBufferSlots as *const _ as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GCSizes),
                    "::",
                    stringify!(storeBufferSlots)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GCSizes>())).storeBufferWholeCells as *const _ as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GCSizes),
                    "::",
                    stringify!(storeBufferWholeCells)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GCSizes>())).storeBufferGenerics as *const _ as usize
                },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GCSizes),
                    "::",
                    stringify!(storeBufferGenerics)
                )
            );
        }
        #[doc = " This class holds information about the memory taken up by identical copies of"]
        #[doc = " a particular string.  Multiple JSStrings may have their sizes aggregated"]
        #[doc = " together into one StringInfo object.  Note that two strings with identical"]
        #[doc = " chars will not be aggregated together if one is a short string and the other"]
        #[doc = " is not."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct StringInfo {
            pub gcHeapLatin1: usize,
            pub gcHeapTwoByte: usize,
            pub mallocHeapLatin1: usize,
            pub mallocHeapTwoByte: usize,
            pub numCopies: u32,
        }
        #[test]
        fn bindgen_test_layout_StringInfo() {
            assert_eq!(
                ::std::mem::size_of::<StringInfo>(),
                40usize,
                concat!("Size of: ", stringify!(StringInfo))
            );
            assert_eq!(
                ::std::mem::align_of::<StringInfo>(),
                8usize,
                concat!("Alignment of ", stringify!(StringInfo))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<StringInfo>())).gcHeapLatin1 as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StringInfo),
                    "::",
                    stringify!(gcHeapLatin1)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<StringInfo>())).gcHeapTwoByte as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StringInfo),
                    "::",
                    stringify!(gcHeapTwoByte)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<StringInfo>())).mallocHeapLatin1 as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StringInfo),
                    "::",
                    stringify!(mallocHeapLatin1)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<StringInfo>())).mallocHeapTwoByte as *const _ as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StringInfo),
                    "::",
                    stringify!(mallocHeapTwoByte)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<StringInfo>())).numCopies as *const _ as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(StringInfo),
                    "::",
                    stringify!(numCopies)
                )
            );
        }
        #[doc = " Holds data about a notable string (one which, counting all duplicates, uses"]
        #[doc = " more than a certain amount of memory) so we can report it individually."]
        #[doc = ""]
        #[doc = " The only difference between this class and StringInfo is that"]
        #[doc = " NotableStringInfo holds a copy of some or all of the string's chars."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct NotableStringInfo {
            pub _base: root::JS::StringInfo,
            pub buffer: root::JS::UniqueChars,
            pub length: usize,
        }
        pub const NotableStringInfo_MAX_SAVED_CHARS: usize = 1024;
        #[test]
        fn bindgen_test_layout_NotableStringInfo() {
            assert_eq!(
                ::std::mem::size_of::<NotableStringInfo>(),
                56usize,
                concat!("Size of: ", stringify!(NotableStringInfo))
            );
            assert_eq!(
                ::std::mem::align_of::<NotableStringInfo>(),
                8usize,
                concat!("Alignment of ", stringify!(NotableStringInfo))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<NotableStringInfo>())).buffer as *const _ as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(NotableStringInfo),
                    "::",
                    stringify!(buffer)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<NotableStringInfo>())).length as *const _ as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(NotableStringInfo),
                    "::",
                    stringify!(length)
                )
            );
        }
        #[doc = " This class holds information about the memory taken up by script sources"]
        #[doc = " from a particular file."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ScriptSourceInfo {
            pub misc: usize,
            pub numScripts: u32,
        }
        #[test]
        fn bindgen_test_layout_ScriptSourceInfo() {
            assert_eq!(
                ::std::mem::size_of::<ScriptSourceInfo>(),
                16usize,
                concat!("Size of: ", stringify!(ScriptSourceInfo))
            );
            assert_eq!(
                ::std::mem::align_of::<ScriptSourceInfo>(),
                8usize,
                concat!("Alignment of ", stringify!(ScriptSourceInfo))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ScriptSourceInfo>())).misc as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ScriptSourceInfo),
                    "::",
                    stringify!(misc)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ScriptSourceInfo>())).numScripts as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ScriptSourceInfo),
                    "::",
                    stringify!(numScripts)
                )
            );
        }
        #[doc = " Holds data about a notable script source file (one whose combined"]
        #[doc = " script sources use more than a certain amount of memory) so we can report it"]
        #[doc = " individually."]
        #[doc = ""]
        #[doc = " The only difference between this class and ScriptSourceInfo is that this"]
        #[doc = " class holds a copy of the filename."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct NotableScriptSourceInfo {
            pub _base: root::JS::ScriptSourceInfo,
            pub filename_: root::JS::UniqueChars,
        }
        #[test]
        fn bindgen_test_layout_NotableScriptSourceInfo() {
            assert_eq!(
                ::std::mem::size_of::<NotableScriptSourceInfo>(),
                24usize,
                concat!("Size of: ", stringify!(NotableScriptSourceInfo))
            );
            assert_eq!(
                ::std::mem::align_of::<NotableScriptSourceInfo>(),
                8usize,
                concat!("Alignment of ", stringify!(NotableScriptSourceInfo))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<NotableScriptSourceInfo>())).filename_ as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(NotableScriptSourceInfo),
                    "::",
                    stringify!(filename_)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HelperThreadStats {
            pub stateData: usize,
            pub parseTask: usize,
            pub ionBuilder: usize,
            pub wasmCompile: usize,
            pub idleThreadCount: ::std::os::raw::c_uint,
            pub activeThreadCount: ::std::os::raw::c_uint,
        }
        #[test]
        fn bindgen_test_layout_HelperThreadStats() {
            assert_eq!(
                ::std::mem::size_of::<HelperThreadStats>(),
                40usize,
                concat!("Size of: ", stringify!(HelperThreadStats))
            );
            assert_eq!(
                ::std::mem::align_of::<HelperThreadStats>(),
                8usize,
                concat!("Alignment of ", stringify!(HelperThreadStats))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HelperThreadStats>())).stateData as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HelperThreadStats),
                    "::",
                    stringify!(stateData)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HelperThreadStats>())).parseTask as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HelperThreadStats),
                    "::",
                    stringify!(parseTask)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HelperThreadStats>())).ionBuilder as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HelperThreadStats),
                    "::",
                    stringify!(ionBuilder)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HelperThreadStats>())).wasmCompile as *const _ as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HelperThreadStats),
                    "::",
                    stringify!(wasmCompile)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HelperThreadStats>())).idleThreadCount as *const _
                        as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HelperThreadStats),
                    "::",
                    stringify!(idleThreadCount)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<HelperThreadStats>())).activeThreadCount as *const _
                        as usize
                },
                36usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HelperThreadStats),
                    "::",
                    stringify!(activeThreadCount)
                )
            );
        }
        #[doc = " Measurements that not associated with any individual runtime."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GlobalStats {
            pub tracelogger: usize,
            pub helperThread: root::JS::HelperThreadStats,
            pub mallocSizeOf_: root::mozilla::MallocSizeOf,
        }
        #[test]
        fn bindgen_test_layout_GlobalStats() {
            assert_eq!(
                ::std::mem::size_of::<GlobalStats>(),
                56usize,
                concat!("Size of: ", stringify!(GlobalStats))
            );
            assert_eq!(
                ::std::mem::align_of::<GlobalStats>(),
                8usize,
                concat!("Alignment of ", stringify!(GlobalStats))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<GlobalStats>())).tracelogger as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GlobalStats),
                    "::",
                    stringify!(tracelogger)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GlobalStats>())).helperThread as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GlobalStats),
                    "::",
                    stringify!(helperThread)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<GlobalStats>())).mallocSizeOf_ as *const _ as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(GlobalStats),
                    "::",
                    stringify!(mallocSizeOf_)
                )
            );
        }
        #[doc = " These measurements relate directly to the JSRuntime, and not to zones,"]
        #[doc = " compartments, and realms within it."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct RuntimeSizes {
            pub object: usize,
            pub atomsTable: usize,
            pub atomsMarkBitmaps: usize,
            pub contexts: usize,
            pub temporary: usize,
            pub interpreterStack: usize,
            pub sharedImmutableStringsCache: usize,
            pub sharedIntlData: usize,
            pub uncompressedSourceCache: usize,
            pub scriptData: usize,
            pub tracelogger: usize,
            pub wasmRuntime: usize,
            pub jitLazyLink: usize,
            pub scriptSourceInfo: root::JS::ScriptSourceInfo,
            pub gc: root::JS::GCSizes,
            pub allScriptSources: [u64; 4usize],
            pub notableScriptSources: [u64; 3usize],
        }
        pub type RuntimeSizes_ScriptSourcesHashMap = [u64; 3usize];
        #[test]
        fn bindgen_test_layout_RuntimeSizes() {
            assert_eq!(
                ::std::mem::size_of::<RuntimeSizes>(),
                240usize,
                concat!("Size of: ", stringify!(RuntimeSizes))
            );
            assert_eq!(
                ::std::mem::align_of::<RuntimeSizes>(),
                8usize,
                concat!("Alignment of ", stringify!(RuntimeSizes))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<RuntimeSizes>())).object as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(object)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<RuntimeSizes>())).atomsTable as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(atomsTable)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RuntimeSizes>())).atomsMarkBitmaps as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(atomsMarkBitmaps)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<RuntimeSizes>())).contexts as *const _ as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(contexts)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<RuntimeSizes>())).temporary as *const _ as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(temporary)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RuntimeSizes>())).interpreterStack as *const _ as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(interpreterStack)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RuntimeSizes>())).sharedImmutableStringsCache as *const _
                        as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(sharedImmutableStringsCache)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RuntimeSizes>())).sharedIntlData as *const _ as usize
                },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(sharedIntlData)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RuntimeSizes>())).uncompressedSourceCache as *const _
                        as usize
                },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(uncompressedSourceCache)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<RuntimeSizes>())).scriptData as *const _ as usize },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(scriptData)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RuntimeSizes>())).tracelogger as *const _ as usize
                },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(tracelogger)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RuntimeSizes>())).wasmRuntime as *const _ as usize
                },
                88usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(wasmRuntime)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RuntimeSizes>())).jitLazyLink as *const _ as usize
                },
                96usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(jitLazyLink)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RuntimeSizes>())).scriptSourceInfo as *const _ as usize
                },
                104usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(scriptSourceInfo)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<RuntimeSizes>())).gc as *const _ as usize },
                120usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(gc)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RuntimeSizes>())).allScriptSources as *const _ as usize
                },
                184usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(allScriptSources)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RuntimeSizes>())).notableScriptSources as *const _
                        as usize
                },
                216usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeSizes),
                    "::",
                    stringify!(notableScriptSources)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct UnusedGCThingSizes {
            pub object: usize,
            pub script: usize,
            pub lazyScript: usize,
            pub shape: usize,
            pub baseShape: usize,
            pub objectGroup: usize,
            pub string: usize,
            pub symbol: usize,
            pub bigInt: usize,
            pub jitcode: usize,
            pub scope: usize,
            pub regExpShared: usize,
        }
        #[test]
        fn bindgen_test_layout_UnusedGCThingSizes() {
            assert_eq!(
                ::std::mem::size_of::<UnusedGCThingSizes>(),
                96usize,
                concat!("Size of: ", stringify!(UnusedGCThingSizes))
            );
            assert_eq!(
                ::std::mem::align_of::<UnusedGCThingSizes>(),
                8usize,
                concat!("Alignment of ", stringify!(UnusedGCThingSizes))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<UnusedGCThingSizes>())).object as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UnusedGCThingSizes),
                    "::",
                    stringify!(object)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<UnusedGCThingSizes>())).script as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UnusedGCThingSizes),
                    "::",
                    stringify!(script)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<UnusedGCThingSizes>())).lazyScript as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UnusedGCThingSizes),
                    "::",
                    stringify!(lazyScript)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<UnusedGCThingSizes>())).shape as *const _ as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UnusedGCThingSizes),
                    "::",
                    stringify!(shape)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<UnusedGCThingSizes>())).baseShape as *const _ as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UnusedGCThingSizes),
                    "::",
                    stringify!(baseShape)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<UnusedGCThingSizes>())).objectGroup as *const _ as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UnusedGCThingSizes),
                    "::",
                    stringify!(objectGroup)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<UnusedGCThingSizes>())).string as *const _ as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UnusedGCThingSizes),
                    "::",
                    stringify!(string)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<UnusedGCThingSizes>())).symbol as *const _ as usize
                },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UnusedGCThingSizes),
                    "::",
                    stringify!(symbol)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<UnusedGCThingSizes>())).bigInt as *const _ as usize
                },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UnusedGCThingSizes),
                    "::",
                    stringify!(bigInt)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<UnusedGCThingSizes>())).jitcode as *const _ as usize
                },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UnusedGCThingSizes),
                    "::",
                    stringify!(jitcode)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<UnusedGCThingSizes>())).scope as *const _ as usize
                },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UnusedGCThingSizes),
                    "::",
                    stringify!(scope)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<UnusedGCThingSizes>())).regExpShared as *const _ as usize
                },
                88usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UnusedGCThingSizes),
                    "::",
                    stringify!(regExpShared)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ZoneStats {
            pub symbolsGCHeap: usize,
            pub bigIntsGCHeap: usize,
            pub bigIntsMallocHeap: usize,
            pub gcHeapArenaAdmin: usize,
            pub lazyScriptsGCHeap: usize,
            pub lazyScriptsMallocHeap: usize,
            pub jitCodesGCHeap: usize,
            pub objectGroupsGCHeap: usize,
            pub objectGroupsMallocHeap: usize,
            pub scopesGCHeap: usize,
            pub scopesMallocHeap: usize,
            pub regExpSharedsGCHeap: usize,
            pub regExpSharedsMallocHeap: usize,
            pub typePool: usize,
            pub regexpZone: usize,
            pub jitZone: usize,
            pub baselineStubsOptimized: usize,
            pub uniqueIdMap: usize,
            pub shapeTables: usize,
            pub compartmentObjects: usize,
            pub crossCompartmentWrappersTables: usize,
            pub compartmentsPrivateData: usize,
            pub scriptCountsMap: usize,
            pub unusedGCThings: root::JS::UnusedGCThingSizes,
            pub stringInfo: root::JS::StringInfo,
            pub shapeInfo: root::JS::ShapeInfo,
            pub code: root::JS::CodeSizes,
            pub extra: *mut ::std::os::raw::c_void,
            pub allStrings: [u64; 4usize],
            pub notableStrings: [u64; 3usize],
            pub isTotals: bool,
        }
        pub type ZoneStats_StringsHashMap = [u64; 3usize];
        #[test]
        fn bindgen_test_layout_ZoneStats() {
            assert_eq!(
                ::std::mem::size_of::<ZoneStats>(),
                480usize,
                concat!("Size of: ", stringify!(ZoneStats))
            );
            assert_eq!(
                ::std::mem::align_of::<ZoneStats>(),
                8usize,
                concat!("Alignment of ", stringify!(ZoneStats))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ZoneStats>())).symbolsGCHeap as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(symbolsGCHeap)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ZoneStats>())).bigIntsGCHeap as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(bigIntsGCHeap)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ZoneStats>())).bigIntsMallocHeap as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(bigIntsMallocHeap)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ZoneStats>())).gcHeapArenaAdmin as *const _ as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(gcHeapArenaAdmin)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ZoneStats>())).lazyScriptsGCHeap as *const _ as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(lazyScriptsGCHeap)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ZoneStats>())).lazyScriptsMallocHeap as *const _ as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(lazyScriptsMallocHeap)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ZoneStats>())).jitCodesGCHeap as *const _ as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(jitCodesGCHeap)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ZoneStats>())).objectGroupsGCHeap as *const _ as usize
                },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(objectGroupsGCHeap)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ZoneStats>())).objectGroupsMallocHeap as *const _
                        as usize
                },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(objectGroupsMallocHeap)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ZoneStats>())).scopesGCHeap as *const _ as usize },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(scopesGCHeap)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ZoneStats>())).scopesMallocHeap as *const _ as usize
                },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(scopesMallocHeap)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ZoneStats>())).regExpSharedsGCHeap as *const _ as usize
                },
                88usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(regExpSharedsGCHeap)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ZoneStats>())).regExpSharedsMallocHeap as *const _
                        as usize
                },
                96usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(regExpSharedsMallocHeap)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ZoneStats>())).typePool as *const _ as usize },
                104usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(typePool)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ZoneStats>())).regexpZone as *const _ as usize },
                112usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(regexpZone)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ZoneStats>())).jitZone as *const _ as usize },
                120usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(jitZone)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ZoneStats>())).baselineStubsOptimized as *const _
                        as usize
                },
                128usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(baselineStubsOptimized)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ZoneStats>())).uniqueIdMap as *const _ as usize },
                136usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(uniqueIdMap)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ZoneStats>())).shapeTables as *const _ as usize },
                144usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(shapeTables)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ZoneStats>())).compartmentObjects as *const _ as usize
                },
                152usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(compartmentObjects)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ZoneStats>())).crossCompartmentWrappersTables as *const _
                        as usize
                },
                160usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(crossCompartmentWrappersTables)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ZoneStats>())).compartmentsPrivateData as *const _
                        as usize
                },
                168usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(compartmentsPrivateData)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ZoneStats>())).scriptCountsMap as *const _ as usize
                },
                176usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(scriptCountsMap)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ZoneStats>())).unusedGCThings as *const _ as usize
                },
                184usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(unusedGCThings)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ZoneStats>())).stringInfo as *const _ as usize },
                280usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(stringInfo)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ZoneStats>())).shapeInfo as *const _ as usize },
                320usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(shapeInfo)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ZoneStats>())).code as *const _ as usize },
                368usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(code)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ZoneStats>())).extra as *const _ as usize },
                408usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(extra)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ZoneStats>())).allStrings as *const _ as usize },
                416usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(allStrings)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ZoneStats>())).notableStrings as *const _ as usize
                },
                448usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(notableStrings)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ZoneStats>())).isTotals as *const _ as usize },
                472usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ZoneStats),
                    "::",
                    stringify!(isTotals)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct RealmStats {
            pub objectsPrivate: usize,
            pub scriptsGCHeap: usize,
            pub scriptsMallocHeapData: usize,
            pub baselineData: usize,
            pub baselineStubsFallback: usize,
            pub ionData: usize,
            pub jitScripts: usize,
            pub typeInferenceAllocationSiteTables: usize,
            pub typeInferenceArrayTypeTables: usize,
            pub typeInferenceObjectTypeTables: usize,
            pub realmObject: usize,
            pub realmTables: usize,
            pub innerViewsTable: usize,
            pub objectMetadataTable: usize,
            pub savedStacksSet: usize,
            pub varNamesSet: usize,
            pub nonSyntacticLexicalScopesTable: usize,
            pub jitRealm: usize,
            pub classInfo: root::JS::ClassInfo,
            pub extra: *mut ::std::os::raw::c_void,
            pub allClasses: [u64; 4usize],
            pub notableClasses: [u64; 3usize],
            pub isTotals: bool,
        }
        pub type RealmStats_ClassesHashMap = [u64; 3usize];
        #[test]
        fn bindgen_test_layout_RealmStats() {
            assert_eq!(
                ::std::mem::size_of::<RealmStats>(),
                296usize,
                concat!("Size of: ", stringify!(RealmStats))
            );
            assert_eq!(
                ::std::mem::align_of::<RealmStats>(),
                8usize,
                concat!("Alignment of ", stringify!(RealmStats))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmStats>())).objectsPrivate as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(objectsPrivate)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmStats>())).scriptsGCHeap as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(scriptsGCHeap)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmStats>())).scriptsMallocHeapData as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(scriptsMallocHeapData)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<RealmStats>())).baselineData as *const _ as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(baselineData)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmStats>())).baselineStubsFallback as *const _
                        as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(baselineStubsFallback)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<RealmStats>())).ionData as *const _ as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(ionData)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<RealmStats>())).jitScripts as *const _ as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(jitScripts)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmStats>())).typeInferenceAllocationSiteTables
                        as *const _ as usize
                },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(typeInferenceAllocationSiteTables)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmStats>())).typeInferenceArrayTypeTables as *const _
                        as usize
                },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(typeInferenceArrayTypeTables)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmStats>())).typeInferenceObjectTypeTables as *const _
                        as usize
                },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(typeInferenceObjectTypeTables)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<RealmStats>())).realmObject as *const _ as usize },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(realmObject)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<RealmStats>())).realmTables as *const _ as usize },
                88usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(realmTables)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmStats>())).innerViewsTable as *const _ as usize
                },
                96usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(innerViewsTable)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmStats>())).objectMetadataTable as *const _ as usize
                },
                104usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(objectMetadataTable)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmStats>())).savedStacksSet as *const _ as usize
                },
                112usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(savedStacksSet)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<RealmStats>())).varNamesSet as *const _ as usize },
                120usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(varNamesSet)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmStats>())).nonSyntacticLexicalScopesTable
                        as *const _ as usize
                },
                128usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(nonSyntacticLexicalScopesTable)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<RealmStats>())).jitRealm as *const _ as usize },
                136usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(jitRealm)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<RealmStats>())).classInfo as *const _ as usize },
                144usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(classInfo)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<RealmStats>())).extra as *const _ as usize },
                224usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(extra)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<RealmStats>())).allClasses as *const _ as usize },
                232usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(allClasses)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RealmStats>())).notableClasses as *const _ as usize
                },
                264usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(notableClasses)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<RealmStats>())).isTotals as *const _ as usize },
                288usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RealmStats),
                    "::",
                    stringify!(isTotals)
                )
            );
        }
        pub type RealmStatsVector = [u64; 3usize];
        pub type ZoneStatsVector = [u64; 3usize];
        #[repr(C)]
        pub struct RuntimeStats__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct RuntimeStats {
            pub vtable_: *const RuntimeStats__bindgen_vtable,
            pub gcHeapChunkTotal: usize,
            pub gcHeapDecommittedArenas: usize,
            pub gcHeapUnusedChunks: usize,
            pub gcHeapUnusedArenas: usize,
            pub gcHeapChunkAdmin: usize,
            pub gcHeapGCThings: usize,
            pub runtime: root::JS::RuntimeSizes,
            pub realmTotals: root::JS::RealmStats,
            pub zTotals: root::JS::ZoneStats,
            pub realmStatsVector: root::JS::RealmStatsVector,
            pub zoneStatsVector: root::JS::ZoneStatsVector,
            pub currZoneStats: *mut root::JS::ZoneStats,
            pub mallocSizeOf_: root::mozilla::MallocSizeOf,
        }
        #[test]
        fn bindgen_test_layout_RuntimeStats() {
            assert_eq!(
                ::std::mem::size_of::<RuntimeStats>(),
                1136usize,
                concat!("Size of: ", stringify!(RuntimeStats))
            );
            assert_eq!(
                ::std::mem::align_of::<RuntimeStats>(),
                8usize,
                concat!("Alignment of ", stringify!(RuntimeStats))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RuntimeStats>())).gcHeapChunkTotal as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeStats),
                    "::",
                    stringify!(gcHeapChunkTotal)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RuntimeStats>())).gcHeapDecommittedArenas as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeStats),
                    "::",
                    stringify!(gcHeapDecommittedArenas)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RuntimeStats>())).gcHeapUnusedChunks as *const _ as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeStats),
                    "::",
                    stringify!(gcHeapUnusedChunks)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RuntimeStats>())).gcHeapUnusedArenas as *const _ as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeStats),
                    "::",
                    stringify!(gcHeapUnusedArenas)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RuntimeStats>())).gcHeapChunkAdmin as *const _ as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeStats),
                    "::",
                    stringify!(gcHeapChunkAdmin)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RuntimeStats>())).gcHeapGCThings as *const _ as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeStats),
                    "::",
                    stringify!(gcHeapGCThings)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<RuntimeStats>())).runtime as *const _ as usize },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeStats),
                    "::",
                    stringify!(runtime)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RuntimeStats>())).realmTotals as *const _ as usize
                },
                296usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeStats),
                    "::",
                    stringify!(realmTotals)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<RuntimeStats>())).zTotals as *const _ as usize },
                592usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeStats),
                    "::",
                    stringify!(zTotals)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RuntimeStats>())).realmStatsVector as *const _ as usize
                },
                1072usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeStats),
                    "::",
                    stringify!(realmStatsVector)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RuntimeStats>())).zoneStatsVector as *const _ as usize
                },
                1096usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeStats),
                    "::",
                    stringify!(zoneStatsVector)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RuntimeStats>())).currZoneStats as *const _ as usize
                },
                1120usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeStats),
                    "::",
                    stringify!(currZoneStats)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<RuntimeStats>())).mallocSizeOf_ as *const _ as usize
                },
                1128usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RuntimeStats),
                    "::",
                    stringify!(mallocSizeOf_)
                )
            );
        }
        #[repr(C)]
        pub struct ObjectPrivateVisitor__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ObjectPrivateVisitor {
            pub vtable_: *const ObjectPrivateVisitor__bindgen_vtable,
            pub getISupports_: root::JS::ObjectPrivateVisitor_GetISupportsFun,
        }
        pub type ObjectPrivateVisitor_GetISupportsFun = ::std::option::Option<
            unsafe extern "C" fn(
                obj: *mut root::JSObject,
                iface: *mut *mut root::nsISupports,
            ) -> bool,
        >;
        #[test]
        fn bindgen_test_layout_ObjectPrivateVisitor() {
            assert_eq!(
                ::std::mem::size_of::<ObjectPrivateVisitor>(),
                16usize,
                concat!("Size of: ", stringify!(ObjectPrivateVisitor))
            );
            assert_eq!(
                ::std::mem::align_of::<ObjectPrivateVisitor>(),
                8usize,
                concat!("Alignment of ", stringify!(ObjectPrivateVisitor))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ObjectPrivateVisitor>())).getISupports_ as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ObjectPrivateVisitor),
                    "::",
                    stringify!(getISupports_)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18CollectGlobalStatsEPNS_11GlobalStatsE"]
            pub fn CollectGlobalStats(gStats: *mut root::JS::GlobalStats) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS19CollectRuntimeStatsEP9JSContextPNS_12RuntimeStatsEPNS_20ObjectPrivateVisitorEb"]
            pub fn CollectRuntimeStats(
                cx: *mut root::JSContext,
                rtStats: *mut root::JS::RuntimeStats,
                opv: *mut root::JS::ObjectPrivateVisitor,
                anonymize: bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS22SystemCompartmentCountEP9JSContext"]
            pub fn SystemCompartmentCount(cx: *mut root::JSContext) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS20UserCompartmentCountEP9JSContext"]
            pub fn UserCompartmentCount(cx: *mut root::JSContext) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS16SystemRealmCountEP9JSContext"]
            pub fn SystemRealmCount(cx: *mut root::JSContext) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS14UserRealmCountEP9JSContext"]
            pub fn UserRealmCount(cx: *mut root::JSContext) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS19PeakSizeOfTemporaryEPK9JSContext"]
            pub fn PeakSizeOfTemporary(cx: *const root::JSContext) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS12AddSizeOfTabEP9JSContextNS_6HandleIP8JSObjectEEPFmPKvEPNS_20ObjectPrivateVisitorEPNS_8TabSizesE"]
            pub fn AddSizeOfTab(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                mallocSizeOf: root::mozilla::MallocSizeOf,
                opv: *mut root::JS::ObjectPrivateVisitor,
                sizes: *mut root::JS::TabSizes,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS14AddServoSizeOfEP9JSContextPFmPKvEPNS_20ObjectPrivateVisitorEPNS_10ServoSizesE"]
            pub fn AddServoSizeOf(
                cx: *mut root::JSContext,
                mallocSizeOf: root::mozilla::MallocSizeOf,
                opv: *mut root::JS::ObjectPrivateVisitor,
                sizes: *mut root::JS::ServoSizes,
            ) -> bool;
        }
        pub type ModuleResolveHook = ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut root::JSContext,
                arg2: root::JS::Handle<root::JS::Value>,
                arg3: root::JS::Handle<*mut root::JSString>,
            ) -> *mut root::JSObject,
        >;
        extern "C" {
            #[doc = " Get the HostResolveImportedModule hook for the runtime."]
            #[link_name = "\u{1}_ZN2JS20GetModuleResolveHookEP9JSRuntime"]
            pub fn GetModuleResolveHook(rt: *mut root::JSRuntime) -> root::JS::ModuleResolveHook;
        }
        extern "C" {
            #[doc = " Set the HostResolveImportedModule hook for the runtime to the given function."]
            #[link_name = "\u{1}_ZN2JS20SetModuleResolveHookEP9JSRuntimePFP8JSObjectP9JSContextNS_6HandleINS_5ValueEEENS6_IP8JSStringEEE"]
            pub fn SetModuleResolveHook(
                rt: *mut root::JSRuntime,
                func: root::JS::ModuleResolveHook,
            );
        }
        pub type ModuleMetadataHook = ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut root::JSContext,
                arg2: root::JS::Handle<root::JS::Value>,
                arg3: root::JS::Handle<*mut root::JSObject>,
            ) -> bool,
        >;
        extern "C" {
            #[doc = " Get the hook for populating the import.meta metadata object."]
            #[link_name = "\u{1}_ZN2JS21GetModuleMetadataHookEP9JSRuntime"]
            pub fn GetModuleMetadataHook(rt: *mut root::JSRuntime) -> root::JS::ModuleMetadataHook;
        }
        extern "C" {
            #[doc = " Set the hook for populating the import.meta metadata object to the given"]
            #[doc = " function."]
            #[link_name = "\u{1}_ZN2JS21SetModuleMetadataHookEP9JSRuntimePFbP9JSContextNS_6HandleINS_5ValueEEENS4_IP8JSObjectEEE"]
            pub fn SetModuleMetadataHook(
                rt: *mut root::JSRuntime,
                func: root::JS::ModuleMetadataHook,
            );
        }
        pub type ModuleDynamicImportHook = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                referencingPrivate: root::JS::Handle<root::JS::Value>,
                specifier: root::JS::Handle<*mut root::JSString>,
                promise: root::JS::Handle<*mut root::JSObject>,
            ) -> bool,
        >;
        extern "C" {
            #[doc = " Get the HostImportModuleDynamically hook for the runtime."]
            #[link_name = "\u{1}_ZN2JS26GetModuleDynamicImportHookEP9JSRuntime"]
            pub fn GetModuleDynamicImportHook(
                rt: *mut root::JSRuntime,
            ) -> root::JS::ModuleDynamicImportHook;
        }
        extern "C" {
            #[doc = " Set the HostImportModuleDynamically hook for the runtime to the given"]
            #[doc = " function."]
            #[doc = ""]
            #[doc = " If this hook is not set (or set to nullptr) then the JS engine will throw an"]
            #[doc = " exception if dynamic module import is attempted."]
            #[link_name = "\u{1}_ZN2JS26SetModuleDynamicImportHookEP9JSRuntimePFbP9JSContextNS_6HandleINS_5ValueEEENS4_IP8JSStringEENS4_IP8JSObjectEEE"]
            pub fn SetModuleDynamicImportHook(
                rt: *mut root::JSRuntime,
                func: root::JS::ModuleDynamicImportHook,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS25FinishDynamicModuleImportEP9JSContextNS_6HandleINS_5ValueEEENS2_IP8JSStringEENS2_IP8JSObjectEE"]
            pub fn FinishDynamicModuleImport(
                cx: *mut root::JSContext,
                referencingPrivate: root::JS::Handle<root::JS::Value>,
                specifier: root::JS::Handle<*mut root::JSString>,
                promise: root::JS::Handle<*mut root::JSObject>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Parse the given source buffer as a module in the scope of the current global"]
            #[doc = " of cx and return a source text module record."]
            #[link_name = "\u{1}_ZN2JS13CompileModuleEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIDsEE"]
            pub fn CompileModule(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<u16>,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Parse the given source buffer as a module in the scope of the current global"]
            #[doc = " of cx and return a source text module record."]
            #[doc = ""]
            #[doc = " The \"DontInflate\" suffix and (semantically unobservable) don't-inflate"]
            #[doc = " characteristic are temporary while bugs in UTF-8 compilation are ironed out."]
            #[doc = " In the long term this function will be renamed |JS::CompileModule| and will"]
            #[doc = " just never inflate."]
            #[doc = ""]
            #[doc = " NOTE: UTF-8 compilation is currently experimental, and it's possible it has"]
            #[doc = "       as-yet-undiscovered bugs that the UTF-16 compilation functions do not"]
            #[doc = "       have.  Use only if you're willing to take a risk!"]
            #[link_name = "\u{1}_ZN2JS24CompileModuleDontInflateEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIN7mozilla8Utf8UnitEEE"]
            pub fn CompileModuleDontInflate(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<root::mozilla::Utf8Unit>,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Set a private value associated with a source text module record."]
            #[link_name = "\u{1}_ZN2JS16SetModulePrivateEP8JSObjectRKNS_5ValueE"]
            pub fn SetModulePrivate(module: *mut root::JSObject, value: *const root::JS::Value);
        }
        extern "C" {
            #[doc = " Get the private value associated with a source text module record."]
            #[link_name = "\u{1}_ZN2JS16GetModulePrivateEP8JSObject"]
            pub fn GetModulePrivate(module: *mut root::JSObject) -> root::JS::Value;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS17ModuleInstantiateEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn ModuleInstantiate(
                cx: *mut root::JSContext,
                moduleRecord: root::JS::Handle<*mut root::JSObject>,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS14ModuleEvaluateEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn ModuleEvaluate(
                cx: *mut root::JSContext,
                moduleRecord: root::JS::Handle<*mut root::JSObject>,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS19GetRequestedModulesEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn GetRequestedModules(
                cx: *mut root::JSContext,
                moduleRecord: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS27GetRequestedModuleSpecifierEP9JSContextNS_6HandleINS_5ValueEEE"]
            pub fn GetRequestedModuleSpecifier(
                cx: *mut root::JSContext,
                requestedModuleObject: root::JS::Handle<root::JS::Value>,
            ) -> *mut root::JSString;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS27GetRequestedModuleSourcePosEP9JSContextNS_6HandleINS_5ValueEEEPjS5_"]
            pub fn GetRequestedModuleSourcePos(
                cx: *mut root::JSContext,
                requestedModuleObject: root::JS::Handle<root::JS::Value>,
                lineNumber: *mut u32,
                columnNumber: *mut u32,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS15GetModuleScriptENS_6HandleIP8JSObjectEE"]
            pub fn GetModuleScript(
                moduleRecord: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut root::JSScript;
        }
        #[repr(C)]
        pub struct JobQueue__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Abstract base class for an ECMAScript Job Queue:"]
        #[doc = " https://www.ecma-international.org/ecma-262/9.0/index.html#sec-jobs-and-job-queues"]
        #[doc = ""]
        #[doc = " SpiderMonkey doesn't schedule Promise resolution jobs itself; instead, the"]
        #[doc = " embedding can provide an instance of this class SpiderMonkey can use to do"]
        #[doc = " that scheduling."]
        #[doc = ""]
        #[doc = " The JavaScript shell includes a simple implementation adequate for running"]
        #[doc = " tests. Browsers need to augment job handling to meet their own additional"]
        #[doc = " requirements, so they can provide their own implementation."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct JobQueue {
            pub vtable_: *const JobQueue__bindgen_vtable,
        }
        #[repr(C)]
        pub struct JobQueue_SavedJobQueue__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " A saved job queue, represented however the JobQueue implementation pleases."]
        #[doc = " Use AutoDebuggerJobQueueInterruption rather than trying to construct one of"]
        #[doc = " these directly; see documentation there."]
        #[doc = ""]
        #[doc = " Destructing an instance of this class should assert that the current queue"]
        #[doc = " is empty, and then restore the queue the instance captured."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct JobQueue_SavedJobQueue {
            pub vtable_: *const JobQueue_SavedJobQueue__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_JobQueue_SavedJobQueue() {
            assert_eq!(
                ::std::mem::size_of::<JobQueue_SavedJobQueue>(),
                8usize,
                concat!("Size of: ", stringify!(JobQueue_SavedJobQueue))
            );
            assert_eq!(
                ::std::mem::align_of::<JobQueue_SavedJobQueue>(),
                8usize,
                concat!("Alignment of ", stringify!(JobQueue_SavedJobQueue))
            );
        }
        #[test]
        fn bindgen_test_layout_JobQueue() {
            assert_eq!(
                ::std::mem::size_of::<JobQueue>(),
                8usize,
                concat!("Size of: ", stringify!(JobQueue))
            );
            assert_eq!(
                ::std::mem::align_of::<JobQueue>(),
                8usize,
                concat!("Alignment of ", stringify!(JobQueue))
            );
        }
        extern "C" {
            #[doc = " Tell SpiderMonkey to use `queue` to schedule promise reactions."]
            #[doc = ""]
            #[doc = " SpiderMonkey does not take ownership of the queue; it is the embedding's"]
            #[doc = " responsibility to clean it up after the runtime is destroyed."]
            #[link_name = "\u{1}_ZN2JS11SetJobQueueEP9JSContextPNS_8JobQueueE"]
            pub fn SetJobQueue(cx: *mut root::JSContext, queue: *mut root::JS::JobQueue);
        }
        #[doc = " [SMDOC] Protecting the debuggee's job/microtask queue from debugger activity."]
        #[doc = ""]
        #[doc = " When the JavaScript debugger interrupts the execution of some debuggee code"]
        #[doc = " (for a breakpoint, for example), the debuggee's execution must be paused"]
        #[doc = " while the developer takes time to look at it. During this interruption, other"]
        #[doc = " tabs should remain active and usable. If the debuggee shares a main thread"]
        #[doc = " with non-debuggee tabs, that means that the thread will have to process"]
        #[doc = " non-debuggee HTML tasks and microtasks as usual, even as the debuggee's are"]
        #[doc = " on hold until the debugger lets it continue execution. (Letting debuggee"]
        #[doc = " microtasks run during the interruption would mean that, from the debuggee's"]
        #[doc = " point of view, their side effects would take place wherever the breakpoint"]
        #[doc = " was set - in general, not a place other code should ever run, and a violation"]
        #[doc = " of the run-to-completion rule.)"]
        #[doc = ""]
        #[doc = " This means that, even though the timing and ordering of microtasks is"]
        #[doc = " carefully specified by the standard - and important to preserve for"]
        #[doc = " compatibility and predictability - debugger use may, correctly, have the"]
        #[doc = " effect of reordering microtasks. During the interruption, microtasks enqueued"]
        #[doc = " by non-debuggee tabs must run immediately alongside their HTML tasks as"]
        #[doc = " usual, whereas any debuggee microtasks that were in the queue when the"]
        #[doc = " interruption began must wait for the debuggee to be continued - and thus run"]
        #[doc = " after microtasks enqueued after they were."]
        #[doc = ""]
        #[doc = " Fortunately, this reordering is visible olny at the global level: when"]
        #[doc = " implemented correctly, it is not detectable by an individual debuggee. Note"]
        #[doc = " that a debuggee should generally be a complete unit of similar-origin related"]
        #[doc = " browsing contexts. Since non-debuggee activity falls outside that unit, it"]
        #[doc = " should never be visible to the debuggee (except via mechanisms that are"]
        #[doc = " already asynchronous, like events), so the debuggee should be unable to"]
        #[doc = " detect non-debuggee microtasks running when they normally would not. As long"]
        #[doc = " as behavior *visible to the debuggee* is unaffected by the interruption, we"]
        #[doc = " have respected the spirit of the rule."]
        #[doc = ""]
        #[doc = " Of course, even as we accept the general principle that interrupting the"]
        #[doc = " debuggee should have as little detectable effect as possible, we still permit"]
        #[doc = " the developer to do things like evaluate expressions at the console that have"]
        #[doc = " arbitrary effects on the debuggee's stateeffects that could never occur"]
        #[doc = " naturally at that point in the program. But since these are explicitly"]
        #[doc = " requested by the developer, who presumably knows what they're doing, we"]
        #[doc = " support this as best we can. If the developer evaluates an expression in the"]
        #[doc = " console that resolves a promise, it seems most natural for the promise's"]
        #[doc = " reaction microtasks to run immediately, within the interruption. This is an"]
        #[doc = " 'unnatural' time for the microtasks to run, but no more unnatural than the"]
        #[doc = " evaluation that triggered them."]
        #[doc = ""]
        #[doc = " So the overall behavior we need is as follows:"]
        #[doc = ""]
        #[doc = " - When the debugger interrupts a debuggee, the debuggee's microtask queue"]
        #[doc = "   must be saved."]
        #[doc = ""]
        #[doc = " - When debuggee execution resumes, the debuggee's microtask queue must be"]
        #[doc = "   restored exactly as it was when the interruption occurred."]
        #[doc = ""]
        #[doc = " - Non-debuggee task and microtask execution must take place normally during"]
        #[doc = "   the interruption."]
        #[doc = ""]
        #[doc = " Since each HTML task begins with an empty microtask queue, and it should not"]
        #[doc = " be possible for a task to mix debuggee and non-debuggee code, interrupting a"]
        #[doc = " debuggee should always find a microtask queue containing exclusively debuggee"]
        #[doc = " microtasks, if any. So saving and restoring the microtask queue should affect"]
        #[doc = " only the debuggee, not any non-debuggee content."]
        #[doc = ""]
        #[doc = " AutoDebuggerJobQueueInterruption"]
        #[doc = " --------------------------------"]
        #[doc = ""]
        #[doc = " AutoDebuggerJobQueueInterruption is an RAII class, meant for use by the"]
        #[doc = " Debugger API implementation, that takes care of saving and restoring the"]
        #[doc = " queue."]
        #[doc = ""]
        #[doc = " Constructing and initializing an instance of AutoDebuggerJobQueueInterruption"]
        #[doc = " sets aside the given JSContext's job queue, leaving the JSContext's queue"]
        #[doc = " empty. When the AutoDebuggerJobQueueInterruption instance is destroyed, it"]
        #[doc = " asserts that the JSContext's current job queue (holding jobs enqueued while"]
        #[doc = " the AutoDebuggerJobQueueInterruption was alive) is empty, and restores the"]
        #[doc = " saved queue to the JSContext."]
        #[doc = ""]
        #[doc = " Since the Debugger API's behavior is up to us, we can specify that Debugger"]
        #[doc = " hooks begin execution with an empty job queue, and that we drain the queue"]
        #[doc = " after each hook function has run. This drain will be visible to debugger"]
        #[doc = " hooks, and makes hook calls resemble HTML tasks, with their own automatic"]
        #[doc = " microtask checkpoint. But, the drain will be invisible to the debuggee, as"]
        #[doc = " its queue is preserved across the hook invocation."]
        #[doc = ""]
        #[doc = " To protect the debuggee's job queue, Debugger takes care to invoke callback"]
        #[doc = " functions only within the scope of an AutoDebuggerJobQueueInterruption"]
        #[doc = " instance."]
        #[doc = ""]
        #[doc = " Why not let the hook functions themselves take care of this?"]
        #[doc = " ------------------------------------------------------------"]
        #[doc = ""]
        #[doc = " Certainly, we could leave responsibility for saving and restoring the job"]
        #[doc = " queue to the Debugger hook functions themselves."]
        #[doc = ""]
        #[doc = " In fact, early versions of this change tried making the devtools server save"]
        #[doc = " and restore the queue explicitly, but because hooks are set and changed in"]
        #[doc = " numerous places, it was hard to be confident that every case had been"]
        #[doc = " covered, and it seemed that future changes could easily introduce new holes."]
        #[doc = ""]
        #[doc = " Later versions of this change modified the accessor properties on the"]
        #[doc = " Debugger objects' prototypes to automatically protect the job queue when"]
        #[doc = " calling hooks, but the effect was essentially a monkeypatch applied to an API"]
        #[doc = " we defined and control, which doesn't make sense."]
        #[doc = ""]
        #[doc = " In the end, since promises have become such a pervasive part of JavaScript"]
        #[doc = " programming, almost any imaginable use of Debugger would need to provide some"]
        #[doc = " kind of protection for the debuggee's job queue, so it makes sense to simply"]
        #[doc = " handle it once, carefully, in the implementation of Debugger itself."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoDebuggerJobQueueInterruption {
            pub cx: *mut root::JSContext,
            pub saved: u64,
        }
        #[test]
        fn bindgen_test_layout_AutoDebuggerJobQueueInterruption() {
            assert_eq!(
                ::std::mem::size_of::<AutoDebuggerJobQueueInterruption>(),
                16usize,
                concat!("Size of: ", stringify!(AutoDebuggerJobQueueInterruption))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoDebuggerJobQueueInterruption>(),
                8usize,
                concat!(
                    "Alignment of ",
                    stringify!(AutoDebuggerJobQueueInterruption)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AutoDebuggerJobQueueInterruption>())).cx as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoDebuggerJobQueueInterruption),
                    "::",
                    stringify!(cx)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AutoDebuggerJobQueueInterruption>())).saved as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoDebuggerJobQueueInterruption),
                    "::",
                    stringify!(saved)
                )
            );
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum PromiseRejectionHandlingState {
            Unhandled = 0,
            Handled = 1,
        }
        pub type PromiseRejectionTrackerCallback = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                mutedErrors: bool,
                promise: root::JS::HandleObject,
                state: root::JS::PromiseRejectionHandlingState,
                data: *mut ::std::os::raw::c_void,
            ),
        >;
        extern "C" {
            #[doc = " Sets the callback that's invoked whenever a Promise is rejected without"]
            #[doc = " a rejection handler, and when a Promise that was previously rejected"]
            #[doc = " without a handler gets a handler attached."]
            #[link_name = "\u{1}_ZN2JS34SetPromiseRejectionTrackerCallbackEP9JSContextPFvS1_bNS_6HandleIP8JSObjectEENS_29PromiseRejectionHandlingStateEPvES7_"]
            pub fn SetPromiseRejectionTrackerCallback(
                cx: *mut root::JSContext,
                callback: root::JS::PromiseRejectionTrackerCallback,
                data: *mut ::std::os::raw::c_void,
            );
        }
        extern "C" {
            #[doc = " Inform the runtime that the job queue is empty and the embedding is going to"]
            #[doc = " execute its last promise job. The runtime may now choose to skip creating"]
            #[doc = " promise jobs for asynchronous execution and instead continue execution"]
            #[doc = " synchronously. More specifically, this optimization is used to skip the"]
            #[doc = " standard job queuing behavior for `await` operations in async functions."]
            #[doc = ""]
            #[doc = " This function may be called before executing the last job in the job queue."]
            #[doc = " When it was called, JobQueueMayNotBeEmpty must be called in order to restore"]
            #[doc = " the default job queuing behavior before the embedding enqueues its next job"]
            #[doc = " into the job queue."]
            #[link_name = "\u{1}_ZN2JS15JobQueueIsEmptyEP9JSContext"]
            pub fn JobQueueIsEmpty(cx: *mut root::JSContext);
        }
        extern "C" {
            #[doc = " Inform the runtime that job queue is no longer empty. The runtime can now no"]
            #[doc = " longer skip creating promise jobs for asynchronous execution, because"]
            #[doc = " pending jobs in the job queue must be executed first to preserve the FIFO"]
            #[doc = " (first in - first out) property of the queue. This effectively undoes"]
            #[doc = " JobQueueIsEmpty and re-enables the standard job queuing behavior."]
            #[doc = ""]
            #[doc = " This function must be called whenever enqueuing a job to the job queue when"]
            #[doc = " JobQueueIsEmpty was called previously."]
            #[link_name = "\u{1}_ZN2JS21JobQueueMayNotBeEmptyEP9JSContext"]
            pub fn JobQueueMayNotBeEmpty(cx: *mut root::JSContext);
        }
        extern "C" {
            #[doc = " Returns a new instance of the Promise builtin class in the current"]
            #[doc = " compartment, with the right slot layout."]
            #[doc = ""]
            #[doc = " The `executor` can be a `nullptr`. In that case, the only way to resolve or"]
            #[doc = " reject the returned promise is via the `JS::ResolvePromise` and"]
            #[doc = " `JS::RejectPromise` JSAPI functions."]
            #[link_name = "\u{1}_ZN2JS16NewPromiseObjectEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn NewPromiseObject(
                cx: *mut root::JSContext,
                executor: root::JS::HandleObject,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Returns true if the given object is an unwrapped PromiseObject, false"]
            #[doc = " otherwise."]
            #[link_name = "\u{1}_ZN2JS15IsPromiseObjectENS_6HandleIP8JSObjectEE"]
            pub fn IsPromiseObject(obj: root::JS::HandleObject) -> bool;
        }
        extern "C" {
            #[doc = " Returns the current compartment's original Promise constructor."]
            #[link_name = "\u{1}_ZN2JS21GetPromiseConstructorEP9JSContext"]
            pub fn GetPromiseConstructor(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Returns the current compartment's original Promise.prototype."]
            #[link_name = "\u{1}_ZN2JS19GetPromisePrototypeEP9JSContext"]
            pub fn GetPromisePrototype(cx: *mut root::JSContext) -> *mut root::JSObject;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum PromiseState {
            Pending = 0,
            Fulfilled = 1,
            Rejected = 2,
        }
        extern "C" {
            #[doc = " Returns the given Promise's state as a JS::PromiseState enum value."]
            #[doc = ""]
            #[doc = " Returns JS::PromiseState::Pending if the given object is a wrapper that"]
            #[doc = " can't safely be unwrapped."]
            #[link_name = "\u{1}_ZN2JS15GetPromiseStateENS_6HandleIP8JSObjectEE"]
            pub fn GetPromiseState(promise: root::JS::HandleObject) -> root::JS::PromiseState;
        }
        extern "C" {
            #[doc = " Returns the given Promise's process-unique ID."]
            #[link_name = "\u{1}_ZN2JS12GetPromiseIDENS_6HandleIP8JSObjectEE"]
            pub fn GetPromiseID(promise: root::JS::HandleObject) -> u64;
        }
        extern "C" {
            #[doc = " Returns the given Promise's result: either the resolution value for"]
            #[doc = " fulfilled promises, or the rejection reason for rejected ones."]
            #[link_name = "\u{1}_ZN2JS16GetPromiseResultENS_6HandleIP8JSObjectEE"]
            pub fn GetPromiseResult(promise: root::JS::HandleObject) -> root::JS::Value;
        }
        extern "C" {
            #[doc = " Returns whether the given promise's rejection is already handled or not."]
            #[doc = ""]
            #[doc = " The caller must check the given promise is rejected before checking it's"]
            #[doc = " handled or not."]
            #[link_name = "\u{1}_ZN2JS19GetPromiseIsHandledENS_6HandleIP8JSObjectEE"]
            pub fn GetPromiseIsHandled(promise: root::JS::HandleObject) -> bool;
        }
        extern "C" {
            #[doc = " Returns a js::SavedFrame linked list of the stack that lead to the given"]
            #[doc = " Promise's allocation."]
            #[link_name = "\u{1}_ZN2JS24GetPromiseAllocationSiteENS_6HandleIP8JSObjectEE"]
            pub fn GetPromiseAllocationSite(promise: root::JS::HandleObject)
                -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS24GetPromiseResolutionSiteENS_6HandleIP8JSObjectEE"]
            pub fn GetPromiseResolutionSite(promise: root::JS::HandleObject)
                -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Calls the current compartment's original Promise.resolve on the original"]
            #[doc = " Promise constructor, with `resolutionValue` passed as an argument."]
            #[link_name = "\u{1}_ZN2JS26CallOriginalPromiseResolveEP9JSContextNS_6HandleINS_5ValueEEE"]
            pub fn CallOriginalPromiseResolve(
                cx: *mut root::JSContext,
                resolutionValue: root::JS::HandleValue,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Calls the current compartment's original Promise.reject on the original"]
            #[doc = " Promise constructor, with `resolutionValue` passed as an argument."]
            #[link_name = "\u{1}_ZN2JS25CallOriginalPromiseRejectEP9JSContextNS_6HandleINS_5ValueEEE"]
            pub fn CallOriginalPromiseReject(
                cx: *mut root::JSContext,
                rejectionValue: root::JS::HandleValue,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Resolves the given Promise with the given `resolutionValue`."]
            #[doc = ""]
            #[doc = " Calls the `resolve` function that was passed to the executor function when"]
            #[doc = " the Promise was created."]
            #[link_name = "\u{1}_ZN2JS14ResolvePromiseEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEE"]
            pub fn ResolvePromise(
                cx: *mut root::JSContext,
                promiseObj: root::JS::HandleObject,
                resolutionValue: root::JS::HandleValue,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Rejects the given `promise` with the given `rejectionValue`."]
            #[doc = ""]
            #[doc = " Calls the `reject` function that was passed to the executor function when"]
            #[doc = " the Promise was created."]
            #[link_name = "\u{1}_ZN2JS13RejectPromiseEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEE"]
            pub fn RejectPromise(
                cx: *mut root::JSContext,
                promiseObj: root::JS::HandleObject,
                rejectionValue: root::JS::HandleValue,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Calls the current compartment's original Promise.prototype.then on the"]
            #[doc = " given `promise`, with `onResolve` and `onReject` passed as arguments."]
            #[doc = ""]
            #[doc = " Throws a TypeError if `promise` isn't a Promise (or possibly a different"]
            #[doc = " error if it's a security wrapper or dead object proxy)."]
            #[doc = ""]
            #[doc = " Asserts that `onFulfilled` and `onRejected` are each either callable or"]
            #[doc = " null."]
            #[link_name = "\u{1}_ZN2JS23CallOriginalPromiseThenEP9JSContextNS_6HandleIP8JSObjectEES5_S5_"]
            pub fn CallOriginalPromiseThen(
                cx: *mut root::JSContext,
                promise: root::JS::HandleObject,
                onFulfilled: root::JS::HandleObject,
                onRejected: root::JS::HandleObject,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Unforgeable, optimized version of the JS builtin Promise.prototype.then."]
            #[doc = ""]
            #[doc = " Takes a Promise instance and `onResolve`, `onReject` callables to enqueue"]
            #[doc = " as reactions for that promise. In difference to Promise.prototype.then,"]
            #[doc = " this doesn't create and return a new Promise instance."]
            #[doc = ""]
            #[doc = " Throws a TypeError if `promise` isn't a Promise (or possibly a different"]
            #[doc = " error if it's a security wrapper or dead object proxy)."]
            #[doc = ""]
            #[doc = " Asserts that `onFulfilled` and `onRejected` are each either callable or"]
            #[doc = " null."]
            #[link_name = "\u{1}_ZN2JS19AddPromiseReactionsEP9JSContextNS_6HandleIP8JSObjectEES5_S5_"]
            pub fn AddPromiseReactions(
                cx: *mut root::JSContext,
                promise: root::JS::HandleObject,
                onFulfilled: root::JS::HandleObject,
                onRejected: root::JS::HandleObject,
            ) -> bool;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum PromiseUserInputEventHandlingState {
            DontCare = 0,
            HadUserInteractionAtCreation = 1,
            DidntHaveUserInteractionAtCreation = 2,
        }
        extern "C" {
            #[doc = " Returns the given Promise's activation behavior state flag per above as a"]
            #[doc = " JS::PromiseUserInputEventHandlingState value.  All promises are created with"]
            #[doc = " the DontCare state by default."]
            #[doc = ""]
            #[doc = " Returns JS::PromiseUserInputEventHandlingState::DontCare if the given object"]
            #[doc = " is a wrapper that can't safely be unwrapped."]
            #[link_name = "\u{1}_ZN2JS37GetPromiseUserInputEventHandlingStateENS_6HandleIP8JSObjectEE"]
            pub fn GetPromiseUserInputEventHandlingState(
                promise: root::JS::HandleObject,
            ) -> root::JS::PromiseUserInputEventHandlingState;
        }
        extern "C" {
            #[doc = " Sets the given Promise's activation behavior state flag per above as a"]
            #[doc = " JS::PromiseUserInputEventHandlingState value."]
            #[doc = ""]
            #[doc = " Returns false if the given object is a wrapper that can't safely be"]
            #[doc = " unwrapped."]
            #[link_name = "\u{1}_ZN2JS37SetPromiseUserInputEventHandlingStateENS_6HandleIP8JSObjectEENS_34PromiseUserInputEventHandlingStateE"]
            pub fn SetPromiseUserInputEventHandlingState(
                promise: root::JS::HandleObject,
                state: root::JS::PromiseUserInputEventHandlingState,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Unforgeable version of the JS builtin Promise.all."]
            #[doc = ""]
            #[doc = " Takes a HandleObjectVector of Promise objects and returns a promise that's"]
            #[doc = " resolved with an array of resolution values when all those promises have"]
            #[doc = " been resolved, or rejected with the rejection value of the first rejected"]
            #[doc = " promise."]
            #[doc = ""]
            #[doc = " Asserts that all objects in the `promises` vector are, maybe wrapped,"]
            #[doc = " instances of `Promise` or a subclass of `Promise`."]
            #[link_name = "\u{1}_ZN2JS20GetWaitForAllPromiseEP9JSContextNS_6HandleINS_13StackGCVectorIP8JSObjectN2js15TempAllocPolicyEEEEE"]
            pub fn GetWaitForAllPromise(
                cx: *mut root::JSContext,
                promises: root::JS::HandleObjectVector,
            ) -> *mut root::JSObject;
        }
        #[repr(C)]
        pub struct Dispatchable__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " The Dispatchable interface allows the embedding to call SpiderMonkey"]
        #[doc = " on a JSContext thread when requested via DispatchToEventLoopCallback."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct Dispatchable {
            pub vtable_: *const Dispatchable__bindgen_vtable,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum Dispatchable_MaybeShuttingDown {
            NotShuttingDown = 0,
            ShuttingDown = 1,
        }
        #[test]
        fn bindgen_test_layout_Dispatchable() {
            assert_eq!(
                ::std::mem::size_of::<Dispatchable>(),
                8usize,
                concat!("Size of: ", stringify!(Dispatchable))
            );
            assert_eq!(
                ::std::mem::align_of::<Dispatchable>(),
                8usize,
                concat!("Alignment of ", stringify!(Dispatchable))
            );
        }
        #[doc = " Callback to dispatch a JS::Dispatchable to a JSContext's thread's event loop."]
        #[doc = ""]
        #[doc = " The DispatchToEventLoopCallback set on a particular JSContext must accept"]
        #[doc = " JS::Dispatchable instances and arrange for their `run` methods to be called"]
        #[doc = " eventually on the JSContext's thread. This is used for cross-thread dispatch,"]
        #[doc = " so the callback itself must be safe to call from any thread."]
        #[doc = ""]
        #[doc = " If the callback returns `true`, it must eventually run the given"]
        #[doc = " Dispatchable; otherwise, SpiderMonkey may leak memory or hang."]
        #[doc = ""]
        #[doc = " The callback may return `false` to indicate that the JSContext's thread is"]
        #[doc = " shutting down and is no longer accepting runnables. Shutting down is a"]
        #[doc = " one-way transition: once the callback has rejected a runnable, it must reject"]
        #[doc = " all subsequently submitted runnables as well."]
        #[doc = ""]
        #[doc = " To establish a DispatchToEventLoopCallback, the embedding may either call"]
        #[doc = " InitDispatchToEventLoop to provide its own, or call js::UseInternalJobQueues"]
        #[doc = " to select a default implementation built into SpiderMonkey. This latter"]
        #[doc = " depends on the embedding to call js::RunJobs on the JavaScript thread to"]
        #[doc = " process queued Dispatchables at appropriate times."]
        pub type DispatchToEventLoopCallback = ::std::option::Option<
            unsafe extern "C" fn(
                closure: *mut ::std::os::raw::c_void,
                dispatchable: *mut root::JS::Dispatchable,
            ) -> bool,
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS23InitDispatchToEventLoopEP9JSContextPFbPvPNS_12DispatchableEES2_"]
            pub fn InitDispatchToEventLoop(
                cx: *mut root::JSContext,
                callback: root::JS::DispatchToEventLoopCallback,
                closure: *mut ::std::os::raw::c_void,
            );
        }
        extern "C" {
            #[doc = " When a JSRuntime is destroyed it implicitly cancels all async tasks in"]
            #[doc = " progress, releasing any roots held by the task. However, this is not soon"]
            #[doc = " enough for cycle collection, which needs to have roots dropped earlier so"]
            #[doc = " that the cycle collector can transitively remove roots for a future GC. For"]
            #[doc = " these and other cases, the set of pending async tasks can be canceled"]
            #[doc = " with this call earlier than JSRuntime destruction."]
            #[link_name = "\u{1}_ZN2JS18ShutdownAsyncTasksEP9JSContext"]
            pub fn ShutdownAsyncTasks(cx: *mut root::JSContext);
        }
        #[doc = " Regular expression flag values, suitable for initializing a collection of"]
        #[doc = " regular expression flags as defined below in |RegExpFlags|.  Flags are listed"]
        #[doc = " in alphabetical order by syntax -- /g, /i, /m, /u, /y."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RegExpFlag {
            pub _address: u8,
        }
        pub const RegExpFlag_Global: u8 = 2;
        pub const RegExpFlag_IgnoreCase: u8 = 1;
        pub const RegExpFlag_Multiline: u8 = 4;
        pub const RegExpFlag_Unicode: u8 = 16;
        pub const RegExpFlag_Sticky: u8 = 8;
        pub const RegExpFlag_NoFlags: u8 = 0;
        pub const RegExpFlag_AllFlags: u8 = 31;
        #[test]
        fn bindgen_test_layout_RegExpFlag() {
            assert_eq!(
                ::std::mem::size_of::<RegExpFlag>(),
                1usize,
                concat!("Size of: ", stringify!(RegExpFlag))
            );
            assert_eq!(
                ::std::mem::align_of::<RegExpFlag>(),
                1usize,
                concat!("Alignment of ", stringify!(RegExpFlag))
            );
        }
        #[doc = " A collection of regular expression flags.  Individual flag values may be"]
        #[doc = " combined into a collection using bitwise operators."]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RegExpFlags {
            pub flags_: root::JS::RegExpFlags_Flag,
        }
        pub type RegExpFlags_Flag = u8;
        #[test]
        fn bindgen_test_layout_RegExpFlags() {
            assert_eq!(
                ::std::mem::size_of::<RegExpFlags>(),
                1usize,
                concat!("Size of: ", stringify!(RegExpFlags))
            );
            assert_eq!(
                ::std::mem::align_of::<RegExpFlags>(),
                1usize,
                concat!("Alignment of ", stringify!(RegExpFlags))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<RegExpFlags>())).flags_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RegExpFlags),
                    "::",
                    stringify!(flags_)
                )
            );
        }
        extern "C" {
            #[doc = " Create a new RegExp for the given Latin-1-encoded bytes and flags."]
            #[link_name = "\u{1}_ZN2JS15NewRegExpObjectEP9JSContextPKcmNS_11RegExpFlagsE"]
            pub fn NewRegExpObject(
                cx: *mut root::JSContext,
                bytes: *const ::std::os::raw::c_char,
                length: usize,
                flags: root::JS::RegExpFlags,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Create a new RegExp for the given source and flags."]
            #[link_name = "\u{1}_ZN2JS17NewUCRegExpObjectEP9JSContextPKDsmNS_11RegExpFlagsE"]
            pub fn NewUCRegExpObject(
                cx: *mut root::JSContext,
                chars: *const u16,
                length: usize,
                flags: root::JS::RegExpFlags,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS14SetRegExpInputEP9JSContextNS_6HandleIP8JSObjectEENS2_IP8JSStringEE"]
            pub fn SetRegExpInput(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                input: root::JS::Handle<*mut root::JSString>,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18ClearRegExpStaticsEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn ClearRegExpStatics(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS13ExecuteRegExpEP9JSContextNS_6HandleIP8JSObjectEES5_PDsmPmbNS_13MutableHandleINS_5ValueEEE"]
            pub fn ExecuteRegExp(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                reobj: root::JS::Handle<*mut root::JSObject>,
                chars: *mut u16,
                length: usize,
                indexp: *mut usize,
                test: bool,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS22ExecuteRegExpNoStaticsEP9JSContextNS_6HandleIP8JSObjectEEPKDsmPmbNS_13MutableHandleINS_5ValueEEE"]
            pub fn ExecuteRegExpNoStatics(
                cx: *mut root::JSContext,
                reobj: root::JS::Handle<*mut root::JSObject>,
                chars: *const u16,
                length: usize,
                indexp: *mut usize,
                test: bool,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
        }
        extern "C" {
            #[doc = " On success, returns true, setting |*isRegExp| to true if |obj| is a RegExp"]
            #[doc = " object or a wrapper around one, or to false if not.  Returns false on"]
            #[doc = " failure."]
            #[doc = ""]
            #[doc = " This method returns true with |*isRegExp == false| when passed an ES6 proxy"]
            #[doc = " whose target is a RegExp, or when passed a revoked proxy."]
            #[link_name = "\u{1}_ZN2JS14ObjectIsRegExpEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn ObjectIsRegExp(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                isRegExp: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Given a RegExp object (or a wrapper around one), return the set of all"]
            #[doc = " JS::RegExpFlag::* for it."]
            #[link_name = "\u{1}_ZN2JS14GetRegExpFlagsEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn GetRegExpFlags(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
            ) -> root::JS::RegExpFlags;
        }
        extern "C" {
            #[doc = " Return the source text for a RegExp object (or a wrapper around one), or null"]
            #[doc = " on failure."]
            #[link_name = "\u{1}_ZN2JS15GetRegExpSourceEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn GetRegExpSource(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut root::JSString;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum SavedFrameResult {
            Ok = 0,
            AccessDenied = 1,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum SavedFrameSelfHosted {
            Include = 0,
            Exclude = 1,
        }
        extern "C" {
            #[doc = " Given a SavedFrame JSObject, get its source property. Defaults to the empty"]
            #[doc = " string."]
            #[link_name = "\u{1}_ZN2JS19GetSavedFrameSourceEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEENS_13MutableHandleIP8JSStringEENS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameSource(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                sourcep: root::JS::MutableHandle<*mut root::JSString>,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
        }
        extern "C" {
            #[doc = " Given a SavedFrame JSObject, get an ID identifying its ScriptSource."]
            #[doc = " Defaults to 0."]
            #[link_name = "\u{1}_ZN2JS21GetSavedFrameSourceIdEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEEPjNS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameSourceId(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                sourceIdp: *mut u32,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
        }
        extern "C" {
            #[doc = " Given a SavedFrame JSObject, get its line property. Defaults to 0."]
            #[link_name = "\u{1}_ZN2JS17GetSavedFrameLineEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEEPjNS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameLine(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                linep: *mut u32,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
        }
        extern "C" {
            #[doc = " Given a SavedFrame JSObject, get its column property. Defaults to 0."]
            #[link_name = "\u{1}_ZN2JS19GetSavedFrameColumnEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEEPjNS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameColumn(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                columnp: *mut u32,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
        }
        extern "C" {
            #[doc = " Given a SavedFrame JSObject, get its functionDisplayName string, or nullptr"]
            #[doc = " if SpiderMonkey was unable to infer a name for the captured frame's"]
            #[doc = " function. Defaults to nullptr."]
            #[link_name = "\u{1}_ZN2JS32GetSavedFrameFunctionDisplayNameEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEENS_13MutableHandleIP8JSStringEENS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameFunctionDisplayName(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                namep: root::JS::MutableHandle<*mut root::JSString>,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
        }
        extern "C" {
            #[doc = " Given a SavedFrame JSObject, get its asyncCause string. Defaults to nullptr."]
            #[link_name = "\u{1}_ZN2JS23GetSavedFrameAsyncCauseEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEENS_13MutableHandleIP8JSStringEENS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameAsyncCause(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                asyncCausep: root::JS::MutableHandle<*mut root::JSString>,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
        }
        extern "C" {
            #[doc = " Given a SavedFrame JSObject, get its asyncParent SavedFrame object or nullptr"]
            #[doc = " if there is no asyncParent. The `asyncParentp` out parameter is _NOT_"]
            #[doc = " guaranteed to be in the cx's compartment. Defaults to nullptr."]
            #[link_name = "\u{1}_ZN2JS24GetSavedFrameAsyncParentEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEENS_13MutableHandleIS6_EENS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameAsyncParent(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                asyncParentp: root::JS::MutableHandle<*mut root::JSObject>,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
        }
        extern "C" {
            #[doc = " Given a SavedFrame JSObject, get its parent SavedFrame object or nullptr if"]
            #[doc = " it is the oldest frame in the stack. The `parentp` out parameter is _NOT_"]
            #[doc = " guaranteed to be in the cx's compartment. Defaults to nullptr."]
            #[link_name = "\u{1}_ZN2JS19GetSavedFrameParentEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEENS_13MutableHandleIS6_EENS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameParent(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                parentp: root::JS::MutableHandle<*mut root::JSObject>,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
        }
        extern "C" {
            #[doc = " Given a SavedFrame object, convert it and its transitive parents to plain"]
            #[doc = " objects. Because SavedFrame objects store their properties on the prototype,"]
            #[doc = " they cannot be usefully stringified to JSON. Assigning their properties to"]
            #[doc = " plain objects allow those objects to be stringified and the saved frame stack"]
            #[doc = " can be encoded as a string."]
            #[link_name = "\u{1}_ZN2JS30ConvertSavedFrameToPlainObjectEP9JSContextNS_6HandleIP8JSObjectEENS_20SavedFrameSelfHostedE"]
            pub fn ConvertSavedFrameToPlainObject(
                cx: *mut root::JSContext,
                savedFrame: root::JS::HandleObject,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> *mut root::JSObject;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum SourceOwnership {
            Borrowed = 0,
            TakeOwnership = 1,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct SourceText<Unit> {
            #[doc = " |char16_t| or |Utf8Unit| source units of uncertain validity."]
            pub units_: *const Unit,
            #[doc = " The length in code units of |units_|."]
            pub length_: u32,
            #[doc = " Whether this owns |units_| or merely observes source units owned by some"]
            #[doc = " other object."]
            pub ownsUnits_: bool,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Unit>>,
        }
        pub type SourceText_CharT = u8;
        #[repr(C)]
        pub struct ReadableStreamUnderlyingSource__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Abstract base class for external underlying sources."]
        #[doc = ""]
        #[doc = " The term \"underlying source\" is defined in the Streams spec:"]
        #[doc = "   https://streams.spec.whatwg.org/#underlying-source"]
        #[doc = ""]
        #[doc = " A `ReadableStreamUnderlyingSource` is an underlying source that is"]
        #[doc = " implemented in C++ rather than JS. It can be passed to"]
        #[doc = " `JS::NewReadableExternalSourceStreamObject` to create a custom,"]
        #[doc = " embedding-defined ReadableStream."]
        #[doc = ""]
        #[doc = " There are several API difference between this class and the standard API for"]
        #[doc = " underlying sources implemented in JS:"]
        #[doc = ""]
        #[doc = " -   JS underlying sources can be either byte sources or non-byte sources."]
        #[doc = "     External underlying source are always byte sources."]
        #[doc = ""]
        #[doc = " -   The C++ API does not bother with controller objects. Instead of using"]
        #[doc = "     controller methods, the underlying source directly calls API functions"]
        #[doc = "     like JS::ReadableStream{UpdateDataAvailableFromSource,Close,Error}."]
        #[doc = ""]
        #[doc = " -   External readable streams are optimized to allow the embedding to"]
        #[doc = "     interact with them with a minimum of overhead: chunks aren't enqueued as"]
        #[doc = "     individual typed arrays; instead, the embedding only updates the amount"]
        #[doc = "     of data available using"]
        #[doc = "     JS::ReadableStreamUpdateDataAvailableFromSource. When JS requests data"]
        #[doc = "     from a reader, writeIntoReadRequestBuffer is invoked, asking the"]
        #[doc = "     embedding to write data directly into the buffer we're about to hand to"]
        #[doc = "     JS."]
        #[doc = ""]
        #[doc = " -   The C++ API provides extra callbacks onClosed() and onErrored()."]
        #[doc = ""]
        #[doc = " -   This class has a `finalize()` method, because C++ cares about lifetimes."]
        #[doc = ""]
        #[doc = " Additionally, ReadableStreamGetExternalUnderlyingSource can be used to get"]
        #[doc = " the pointer to the underlying source. This locks the stream until it is"]
        #[doc = " released again using JS::ReadableStreamReleaseExternalUnderlyingSource."]
        #[doc = ""]
        #[doc = " Embeddings can use this to optimize away the JS `ReadableStream` overhead"]
        #[doc = " when an embedding-defined C++ stream is passed to an embedding-defined C++"]
        #[doc = " consumer. For example, consider a ServiceWorker piping a `fetch` Response"]
        #[doc = " body to a TextDecoder. Instead of copying chunks of data into JS typed array"]
        #[doc = " buffers and creating a Promise per chunk, only to immediately resolve the"]
        #[doc = " Promises and read the data out again, the embedding can directly feed the"]
        #[doc = " incoming data to the TextDecoder."]
        #[doc = ""]
        #[doc = " Compartment safety: All methods (except `finalize`) receive `cx` and"]
        #[doc = " `stream` arguments. SpiderMonkey enters the realm of the stream object"]
        #[doc = " before invoking these methods, so `stream` is never a wrapper. Other"]
        #[doc = " arguments may be wrappers."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct ReadableStreamUnderlyingSource {
            pub vtable_: *const ReadableStreamUnderlyingSource__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_ReadableStreamUnderlyingSource() {
            assert_eq!(
                ::std::mem::size_of::<ReadableStreamUnderlyingSource>(),
                8usize,
                concat!("Size of: ", stringify!(ReadableStreamUnderlyingSource))
            );
            assert_eq!(
                ::std::mem::align_of::<ReadableStreamUnderlyingSource>(),
                8usize,
                concat!("Alignment of ", stringify!(ReadableStreamUnderlyingSource))
            );
        }
        extern "C" {
            #[doc = " Returns a new instance of the ReadableStream builtin class in the current"]
            #[doc = " compartment, configured as a default stream."]
            #[doc = " If a |proto| is passed, that gets set as the instance's [[Prototype]]"]
            #[doc = " instead of the original value of |ReadableStream.prototype|."]
            #[link_name = "\u{1}_ZN2JS30NewReadableDefaultStreamObjectEP9JSContextNS_6HandleIP8JSObjectEENS2_IP10JSFunctionEEdS5_"]
            pub fn NewReadableDefaultStreamObject(
                cx: *mut root::JSContext,
                underlyingSource: root::JS::HandleObject,
                size: root::JS::HandleFunction,
                highWaterMark: f64,
                proto: root::JS::HandleObject,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Returns a new instance of the ReadableStream builtin class in the current"]
            #[doc = " compartment."]
            #[doc = ""]
            #[doc = " The instance is a byte stream backed by an embedding-provided underlying"]
            #[doc = " source, using the virtual methods of `underlyingSource` as callbacks. The"]
            #[doc = " embedding must ensure that `*underlyingSource` lives as long as the new"]
            #[doc = " stream object. The JS engine will call the finalize() method when the stream"]
            #[doc = " object is destroyed."]
            #[doc = ""]
            #[doc = " `nsISupportsObject_alreadyAddreffed` is an optional pointer that can be used"]
            #[doc = " to make the new stream participate in Gecko's cycle collection. Here are the"]
            #[doc = " rules for using this parameter properly:"]
            #[doc = ""]
            #[doc = " -   `*underlyingSource` must not be a cycle-collected object. (It would lead"]
            #[doc = "     to memory leaks as the cycle collector would not be able to collect"]
            #[doc = "     cycles containing that object.)"]
            #[doc = ""]
            #[doc = " -   `*underlyingSource` must not contain nsCOMPtrs that point to cycle-"]
            #[doc = "     collected objects. (Same reason.)"]
            #[doc = ""]
            #[doc = " -   `*underlyingSource` may contain a pointer to a single cycle-collected"]
            #[doc = "     object."]
            #[doc = ""]
            #[doc = " -   The pointer may be stored in `*underlyingSource` as a raw pointer."]
            #[doc = ""]
            #[doc = " -   The pointer to the nsISupports interface of the same object must be"]
            #[doc = "     passed as the `nsISupportsObject_alreadyAddreffed` parameter to this"]
            #[doc = "     function. (This is how the cycle collector knows about it, so omitting"]
            #[doc = "     this would again cause leaks.)"]
            #[doc = ""]
            #[doc = " If `proto` is non-null, it is used as the instance's [[Prototype]] instead"]
            #[doc = " of the original value of `ReadableStream.prototype`."]
            #[link_name = "\u{1}_ZN2JS37NewReadableExternalSourceStreamObjectEP9JSContextPNS_30ReadableStreamUnderlyingSourceEPvNS_6HandleIP8JSObjectEE"]
            pub fn NewReadableExternalSourceStreamObject(
                cx: *mut root::JSContext,
                underlyingSource: *mut root::JS::ReadableStreamUnderlyingSource,
                nsISupportsObject_alreadyAddreffed: *mut ::std::os::raw::c_void,
                proto: root::JS::HandleObject,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Returns the embedding-provided underlying source of the given |stream|."]
            #[doc = ""]
            #[doc = " Can be used to optimize operations if both the underlying source and the"]
            #[doc = " intended sink are embedding-provided. In that case it might be"]
            #[doc = " preferrable to pipe data directly from source to sink without interacting"]
            #[doc = " with the stream at all."]
            #[doc = ""]
            #[doc = " Locks the stream until ReadableStreamReleaseExternalUnderlyingSource is"]
            #[doc = " called."]
            #[doc = ""]
            #[doc = " Throws an exception if the stream is locked, i.e. if a reader has been"]
            #[doc = " acquired for the stream, or if ReadableStreamGetExternalUnderlyingSource"]
            #[doc = " has been used previously without releasing the external source again."]
            #[doc = ""]
            #[doc = " Throws an exception if the stream isn't readable, i.e if it is errored or"]
            #[doc = " closed. This is different from ReadableStreamGetReader because we don't"]
            #[doc = " have a Promise to resolve/reject, which a reader provides."]
            #[doc = ""]
            #[doc = " Asserts that |stream| is a ReadableStream object or an unwrappable wrapper"]
            #[doc = " for one."]
            #[doc = ""]
            #[doc = " Asserts that the stream has an embedding-provided underlying source."]
            #[link_name = "\u{1}_ZN2JS41ReadableStreamGetExternalUnderlyingSourceEP9JSContextNS_6HandleIP8JSObjectEEPPNS_30ReadableStreamUnderlyingSourceE"]
            pub fn ReadableStreamGetExternalUnderlyingSource(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                source: *mut *mut root::JS::ReadableStreamUnderlyingSource,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Releases the embedding-provided underlying source of the given |stream|,"]
            #[doc = " returning the stream into an unlocked state."]
            #[doc = ""]
            #[doc = " Asserts that the stream was locked through"]
            #[doc = " ReadableStreamGetExternalUnderlyingSource."]
            #[doc = ""]
            #[doc = " Asserts that |stream| is a ReadableStream object or an unwrappable wrapper"]
            #[doc = " for one."]
            #[doc = ""]
            #[doc = " Asserts that the stream has an embedding-provided underlying source."]
            #[link_name = "\u{1}_ZN2JS45ReadableStreamReleaseExternalUnderlyingSourceEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn ReadableStreamReleaseExternalUnderlyingSource(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Update the amount of data available at the underlying source of the given"]
            #[doc = " |stream|."]
            #[doc = ""]
            #[doc = " Can only be used for streams with an embedding-provided underlying source."]
            #[doc = " The JS engine will use the given value to satisfy read requests for the"]
            #[doc = " stream by invoking the writeIntoReadRequestBuffer method."]
            #[doc = ""]
            #[doc = " Asserts that |stream| is a ReadableStream object or an unwrappable wrapper"]
            #[doc = " for one."]
            #[link_name = "\u{1}_ZN2JS43ReadableStreamUpdateDataAvailableFromSourceEP9JSContextNS_6HandleIP8JSObjectEEj"]
            pub fn ReadableStreamUpdateDataAvailableFromSource(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                availableData: u32,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Break the cycle between this object and the"]
            #[doc = " nsISupportsObject_alreadyAddreffed passed in"]
            #[doc = " NewReadableExternalSourceStreamObject()."]
            #[link_name = "\u{1}_ZN2JS29ReadableStreamReleaseCCObjectEP8JSObject"]
            pub fn ReadableStreamReleaseCCObject(stream: *mut root::JSObject);
        }
        extern "C" {
            #[doc = " Returns true if the given object is a ReadableStream object or an"]
            #[doc = " unwrappable wrapper for one, false otherwise."]
            #[link_name = "\u{1}_ZN2JS16IsReadableStreamEP8JSObject"]
            pub fn IsReadableStream(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[doc = " Returns true if the given object is a ReadableStreamDefaultReader or"]
            #[doc = " ReadableStreamBYOBReader object or an unwrappable wrapper for one, false"]
            #[doc = " otherwise."]
            #[link_name = "\u{1}_ZN2JS22IsReadableStreamReaderEP8JSObject"]
            pub fn IsReadableStreamReader(obj: *mut root::JSObject) -> bool;
        }
        extern "C" {
            #[doc = " Returns true if the given object is a ReadableStreamDefaultReader object"]
            #[doc = " or an unwrappable wrapper for one, false otherwise."]
            #[link_name = "\u{1}_ZN2JS29IsReadableStreamDefaultReaderEP8JSObject"]
            pub fn IsReadableStreamDefaultReader(obj: *mut root::JSObject) -> bool;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ReadableStreamMode {
            Default = 0,
            Byte = 1,
            ExternalSource = 2,
        }
        extern "C" {
            #[doc = " Returns the stream's ReadableStreamMode. If the mode is |Byte| or"]
            #[doc = " |ExternalSource|, it's possible to acquire a BYOB reader for more optimized"]
            #[doc = " operations."]
            #[doc = ""]
            #[doc = " Asserts that |stream| is a ReadableStream object or an unwrappable wrapper"]
            #[doc = " for one."]
            #[link_name = "\u{1}_ZN2JS21ReadableStreamGetModeEP9JSContextNS_6HandleIP8JSObjectEEPNS_18ReadableStreamModeE"]
            pub fn ReadableStreamGetMode(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                mode: *mut root::JS::ReadableStreamMode,
            ) -> bool;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum ReadableStreamReaderMode {
            Default = 0,
        }
        extern "C" {
            #[doc = " Returns true if the given ReadableStream is readable, false if not."]
            #[doc = ""]
            #[doc = " Asserts that |stream| is a ReadableStream object or an unwrappable wrapper"]
            #[doc = " for one."]
            #[link_name = "\u{1}_ZN2JS24ReadableStreamIsReadableEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn ReadableStreamIsReadable(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                result: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Returns true if the given ReadableStream is locked, false if not."]
            #[doc = ""]
            #[doc = " Asserts that |stream| is a ReadableStream object or an unwrappable wrapper"]
            #[doc = " for one."]
            #[link_name = "\u{1}_ZN2JS22ReadableStreamIsLockedEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn ReadableStreamIsLocked(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                result: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Returns true if the given ReadableStream is disturbed, false if not."]
            #[doc = ""]
            #[doc = " Asserts that |stream| is a ReadableStream object or an unwrappable wrapper"]
            #[doc = " for one."]
            #[link_name = "\u{1}_ZN2JS25ReadableStreamIsDisturbedEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn ReadableStreamIsDisturbed(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                result: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Cancels the given ReadableStream with the given reason and returns a"]
            #[doc = " Promise resolved according to the result."]
            #[doc = ""]
            #[doc = " Asserts that |stream| is a ReadableStream object or an unwrappable wrapper"]
            #[doc = " for one."]
            #[link_name = "\u{1}_ZN2JS20ReadableStreamCancelEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEE"]
            pub fn ReadableStreamCancel(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                reason: root::JS::HandleValue,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Creates a reader of the type specified by the mode option and locks the"]
            #[doc = " stream to the new reader."]
            #[doc = ""]
            #[doc = " Asserts that |stream| is a ReadableStream object or an unwrappable wrapper"]
            #[doc = " for one. The returned object will always be created in the"]
            #[doc = " current cx compartment."]
            #[link_name = "\u{1}_ZN2JS23ReadableStreamGetReaderEP9JSContextNS_6HandleIP8JSObjectEENS_24ReadableStreamReaderModeE"]
            pub fn ReadableStreamGetReader(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                mode: root::JS::ReadableStreamReaderMode,
            ) -> *mut root::JSObject;
        }
        extern "C" {
            #[doc = " Tees the given ReadableStream and stores the two resulting streams in"]
            #[doc = " outparams. Returns false if the operation fails, e.g. because the stream is"]
            #[doc = " locked."]
            #[doc = ""]
            #[doc = " Asserts that |stream| is a ReadableStream object or an unwrappable wrapper"]
            #[doc = " for one."]
            #[link_name = "\u{1}_ZN2JS17ReadableStreamTeeEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleIS4_EES7_"]
            pub fn ReadableStreamTee(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                branch1Stream: root::JS::MutableHandleObject,
                branch2Stream: root::JS::MutableHandleObject,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Retrieves the desired combined size of additional chunks to fill the given"]
            #[doc = " ReadableStream's queue. Stores the result in |value| and sets |hasValue| to"]
            #[doc = " true on success, returns false on failure."]
            #[doc = ""]
            #[doc = " If the stream is errored, the call will succeed but no value will be stored"]
            #[doc = " in |value| and |hasValue| will be set to false."]
            #[doc = ""]
            #[doc = " Note: This is semantically equivalent to the |desiredSize| getter on"]
            #[doc = " the stream controller's prototype in JS. We expose it with the stream"]
            #[doc = " itself as a target for simplicity."]
            #[doc = ""]
            #[doc = " Asserts that |stream| is a ReadableStream object or an unwrappable wrapper"]
            #[doc = " for one."]
            #[link_name = "\u{1}_ZN2JS28ReadableStreamGetDesiredSizeEP9JSContextP8JSObjectPbPd"]
            pub fn ReadableStreamGetDesiredSize(
                cx: *mut root::JSContext,
                stream: *mut root::JSObject,
                hasValue: *mut bool,
                value: *mut f64,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Close the given ReadableStream. This is equivalent to `controller.close()`"]
            #[doc = " in JS."]
            #[doc = ""]
            #[doc = " This can fail with or without an exception pending under a variety of"]
            #[doc = " circumstances. On failure, the stream may or may not be closed, and"]
            #[doc = " downstream consumers may or may not have been notified."]
            #[doc = ""]
            #[doc = " Asserts that |stream| is a ReadableStream object or an unwrappable wrapper"]
            #[doc = " for one."]
            #[link_name = "\u{1}_ZN2JS19ReadableStreamCloseEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn ReadableStreamClose(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Returns true if the given ReadableStream reader is locked, false otherwise."]
            #[doc = ""]
            #[doc = " Asserts that |reader| is a ReadableStreamDefaultReader or"]
            #[doc = " ReadableStreamBYOBReader object or an unwrappable wrapper for one."]
            #[link_name = "\u{1}_ZN2JS28ReadableStreamReaderIsClosedEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn ReadableStreamReaderIsClosed(
                cx: *mut root::JSContext,
                reader: root::JS::HandleObject,
                result: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Enqueues the given chunk in the given ReadableStream."]
            #[doc = ""]
            #[doc = " Throws a TypeError and returns false if the enqueing operation fails."]
            #[doc = ""]
            #[doc = " Note: This is semantically equivalent to the |enqueue| method on"]
            #[doc = " the stream controller's prototype in JS. We expose it with the stream"]
            #[doc = " itself as a target for simplicity."]
            #[doc = ""]
            #[doc = " If the ReadableStream has an underlying byte source, the given chunk must"]
            #[doc = " be a typed array or a DataView. Consider using"]
            #[doc = " ReadableByteStreamEnqueueBuffer."]
            #[doc = ""]
            #[doc = " Asserts that |stream| is a ReadableStream object or an unwrappable wrapper"]
            #[doc = " for one."]
            #[link_name = "\u{1}_ZN2JS21ReadableStreamEnqueueEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEE"]
            pub fn ReadableStreamEnqueue(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                chunk: root::JS::HandleValue,
            ) -> bool;
        }
        extern "C" {
            #[doc = " Errors the given ReadableStream, causing all future interactions to fail"]
            #[doc = " with the given error value."]
            #[doc = ""]
            #[doc = " Throws a TypeError and returns false if the erroring operation fails."]
            #[doc = ""]
            #[doc = " Note: This is semantically equivalent to the |error| method on"]
            #[doc = " the stream controller's prototype in JS. We expose it with the stream"]
            #[doc = " itself as a target for simplicity."]
            #[doc = ""]
            #[doc = " Asserts that |stream| is a ReadableStream object or an unwrappable wrapper"]
            #[doc = " for one."]
            #[link_name = "\u{1}_ZN2JS19ReadableStreamErrorEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEE"]
            pub fn ReadableStreamError(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                error: root::JS::HandleValue,
            ) -> bool;
        }
        extern "C" {
            #[doc = " C++ equivalent of `reader.cancel(reason)`"]
            #[doc = " (both <https://streams.spec.whatwg.org/#default-reader-cancel> and"]
            #[doc = " <https://streams.spec.whatwg.org/#byob-reader-cancel>)."]
            #[doc = ""]
            #[doc = " `reader` must be a stream reader created using `JS::ReadableStreamGetReader`"]
            #[doc = " or an unwrappable wrapper for one. (This function is meant to support using"]
            #[doc = " C++ to read from streams. It's not meant to allow C++ code to operate on"]
            #[doc = " readers created by scripts.)"]
            #[link_name = "\u{1}_ZN2JS26ReadableStreamReaderCancelEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEE"]
            pub fn ReadableStreamReaderCancel(
                cx: *mut root::JSContext,
                reader: root::JS::HandleObject,
                reason: root::JS::HandleValue,
            ) -> bool;
        }
        extern "C" {
            #[doc = " C++ equivalent of `reader.releaseLock()`"]
            #[doc = " (both <https://streams.spec.whatwg.org/#default-reader-release-lock> and"]
            #[doc = " <https://streams.spec.whatwg.org/#byob-reader-release-lock>)."]
            #[doc = ""]
            #[doc = " `reader` must be a stream reader created using `JS::ReadableStreamGetReader`"]
            #[doc = " or an unwrappable wrapper for one."]
            #[link_name = "\u{1}_ZN2JS31ReadableStreamReaderReleaseLockEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn ReadableStreamReaderReleaseLock(
                cx: *mut root::JSContext,
                reader: root::JS::HandleObject,
            ) -> bool;
        }
        extern "C" {
            #[doc = " C++ equivalent of the `reader.read()` method on default readers"]
            #[doc = " (<https://streams.spec.whatwg.org/#default-reader-read>)."]
            #[doc = ""]
            #[doc = " The result is a new Promise object, or null on OOM."]
            #[doc = ""]
            #[doc = " `reader` must be the result of calling `JS::ReadableStreamGetReader` with"]
            #[doc = " `ReadableStreamReaderMode::Default` mode, or an unwrappable wrapper for such"]
            #[doc = " a reader."]
            #[link_name = "\u{1}_ZN2JS31ReadableStreamDefaultReaderReadEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn ReadableStreamDefaultReaderRead(
                cx: *mut root::JSContext,
                reader: root::JS::HandleObject,
            ) -> *mut root::JSObject;
        }
        #[repr(C)]
        pub struct WritableStreamUnderlyingSink__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct WritableStreamUnderlyingSink {
            pub vtable_: *const WritableStreamUnderlyingSink__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_WritableStreamUnderlyingSink() {
            assert_eq!(
                ::std::mem::size_of::<WritableStreamUnderlyingSink>(),
                8usize,
                concat!("Size of: ", stringify!(WritableStreamUnderlyingSink))
            );
            assert_eq!(
                ::std::mem::align_of::<WritableStreamUnderlyingSink>(),
                8usize,
                concat!("Alignment of ", stringify!(WritableStreamUnderlyingSink))
            );
        }
        #[repr(u32)]
        #[doc = " Indicates the \"scope of validity\" of serialized data."]
        #[doc = ""]
        #[doc = " Writing plain JS data produces an array of bytes that can be copied and"]
        #[doc = " read in another process or whatever. The serialized data is Plain Old Data."]
        #[doc = " However, HTML also supports `Transferable` objects, which, when cloned, can"]
        #[doc = " be moved from the source object into the clone, like when you take a"]
        #[doc = " photograph of someone and it steals their soul."]
        #[doc = " See <https://developer.mozilla.org/en-US/docs/Web/API/Transferable>."]
        #[doc = " We support cloning and transferring objects of many types."]
        #[doc = ""]
        #[doc = " For example, when we transfer an ArrayBuffer (within a process), we \"detach\""]
        #[doc = " the ArrayBuffer, embed the raw buffer pointer in the serialized data, and"]
        #[doc = " later install it in a new ArrayBuffer in the destination realm. Ownership"]
        #[doc = " of that buffer memory is transferred from the original ArrayBuffer to the"]
        #[doc = " serialized data and then to the clone."]
        #[doc = ""]
        #[doc = " This only makes sense within a single address space. When we transfer an"]
        #[doc = " ArrayBuffer to another process, the contents of the buffer must be copied"]
        #[doc = " into the serialized data. (The original ArrayBuffer is still detached,"]
        #[doc = " though, for consistency; in some cases the caller shouldn't know or care if"]
        #[doc = " the recipient is in the same process.)"]
        #[doc = ""]
        #[doc = " ArrayBuffers are actually a lucky case; some objects (like MessagePorts)"]
        #[doc = " can't reasonably be stored by value in serialized data -- it's pointers or"]
        #[doc = " nothing."]
        #[doc = ""]
        #[doc = " So there is a tradeoff between scope of validity -- how far away the"]
        #[doc = " serialized data may be sent and still make sense -- and efficiency or"]
        #[doc = " features. The read and write algorithms therefore take an argument of this"]
        #[doc = " type, allowing the user to control those trade-offs."]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum StructuredCloneScope {
            #[doc = " The most restrictive scope, with greatest efficiency and features."]
            #[doc = ""]
            #[doc = " When writing, this means we're writing for an audience in the same"]
            #[doc = " process and same thread. The caller promises that the serialized data"]
            #[doc = " will **not** be shipped off to a different thread/process or stored in a"]
            #[doc = " database. It's OK to produce serialized data that contains pointers.  In"]
            #[doc = " Rust terms, the serialized data will be treated as `!Send`."]
            #[doc = ""]
            #[doc = " When reading, this means: Accept transferred objects and buffers"]
            #[doc = " (pointers). The caller promises that the serialized data was written"]
            #[doc = " using this API (otherwise, the serialized data may contain bogus"]
            #[doc = " pointers, leading to undefined behavior)."]
            SameProcessSameThread = 0,
            #[doc = " When writing, this means: The caller promises that the serialized data"]
            #[doc = " will **not** be shipped off to a different process or stored in a"]
            #[doc = " database. However, it may be shipped to another thread. It's OK to"]
            #[doc = " produce serialized data that contains pointers to data that is safe to"]
            #[doc = " send across threads, such as array buffers. In Rust terms, the"]
            #[doc = " serialized data will be treated as `Send` but not `Copy`."]
            #[doc = ""]
            #[doc = " When reading, this means the same thing as SameProcessSameThread;"]
            #[doc = " the distinction only matters when writing."]
            SameProcessDifferentThread = 1,
            #[doc = " When writing, this means we're writing for an audience in a different"]
            #[doc = " process. Produce serialized data that can be sent to other processes,"]
            #[doc = " bitwise copied, or even stored as bytes in a database and read by later"]
            #[doc = " versions of Firefox years from now. The HTML5 spec refers to this as"]
            #[doc = " \"ForStorage\" as in StructuredSerializeForStorage, though we use"]
            #[doc = " DifferentProcess for IPC as well as storage."]
            #[doc = ""]
            #[doc = " Transferable objects are limited to ArrayBuffers, whose contents are"]
            #[doc = " copied into the serialized data (rather than just writing a pointer)."]
            #[doc = ""]
            #[doc = " When reading, this means: Do not accept pointers."]
            DifferentProcess = 2,
            #[doc = " Handle a backwards-compatibility case with IndexedDB (bug 1434308): when"]
            #[doc = " reading, this means to treat legacy SameProcessSameThread data as if it"]
            #[doc = " were DifferentProcess."]
            #[doc = ""]
            #[doc = " Do not use this for writing; use DifferentProcess instead."]
            DifferentProcessForIndexedDB = 3,
            #[doc = " Existing code wants to be able to create an uninitialized"]
            #[doc = " JSStructuredCloneData without knowing the scope, then populate it with"]
            #[doc = " data (at which point the scope *is* known.)"]
            Unassigned = 4,
        }
        impl root::JS::TransferableOwnership {
            pub const SCTAG_TMO_ALLOC_DATA: root::JS::TransferableOwnership =
                TransferableOwnership::SCTAG_TMO_FIRST_OWNED;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
        pub enum TransferableOwnership {
            #[doc = " Transferable data has not been filled in yet"]
            SCTAG_TMO_UNFILLED = 0,
            #[doc = " Structured clone buffer does not yet own the data"]
            SCTAG_TMO_UNOWNED = 1,
            #[doc = " All values at least this large are owned by the clone buffer"]
            SCTAG_TMO_FIRST_OWNED = 2,
            #[doc = " Data is a memory mapped pointer"]
            SCTAG_TMO_MAPPED_DATA = 3,
            #[doc = " Data is embedding-specific. The engine can free it by calling the"]
            #[doc = " freeTransfer op. The embedding can also use SCTAG_TMO_USER_MIN and"]
            #[doc = " greater, up to 32 bits, to distinguish specific ownership variants."]
            SCTAG_TMO_CUSTOM = 4,
            #[doc = " Data is embedding-specific. The engine can free it by calling the"]
            #[doc = " freeTransfer op. The embedding can also use SCTAG_TMO_USER_MIN and"]
            #[doc = " greater, up to 32 bits, to distinguish specific ownership variants."]
            SCTAG_TMO_USER_MIN = 5,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CloneDataPolicy {
            pub sharedArrayBuffer_: bool,
        }
        #[test]
        fn bindgen_test_layout_CloneDataPolicy() {
            assert_eq!(
                ::std::mem::size_of::<CloneDataPolicy>(),
                1usize,
                concat!("Size of: ", stringify!(CloneDataPolicy))
            );
            assert_eq!(
                ::std::mem::align_of::<CloneDataPolicy>(),
                1usize,
                concat!("Alignment of ", stringify!(CloneDataPolicy))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<CloneDataPolicy>())).sharedArrayBuffer_ as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CloneDataPolicy),
                    "::",
                    stringify!(sharedArrayBuffer_)
                )
            );
        }
        extern "C" {
            #[doc = " Report a warning represented by the sprintf-like conversion of ASCII format"]
            #[doc = " filled from trailing ASCII arguments."]
            #[doc = ""]
            #[doc = " Return true iff the warning was successfully reported without reporting an"]
            #[doc = " error (or being upgraded into one)."]
            #[link_name = "\u{1}_ZN2JS9WarnASCIIEP9JSContextPKcz"]
            pub fn WarnASCII(
                cx: *mut root::JSContext,
                format: *const ::std::os::raw::c_char,
                ...
            ) -> bool;
        }
        extern "C" {
            #[doc = " Report a warning represented by the sprintf-like conversion of Latin-1 format"]
            #[doc = " filled from trailing Latin-1 arguments."]
            #[doc = ""]
            #[doc = " Return true iff the warning was successfully reported without reporting an"]
            #[doc = " error (or being upgraded into one)."]
            #[link_name = "\u{1}_ZN2JS10WarnLatin1EP9JSContextPKcz"]
            pub fn WarnLatin1(
                cx: *mut root::JSContext,
                format: *const ::std::os::raw::c_char,
                ...
            ) -> bool;
        }
        extern "C" {
            #[doc = " Report a warning represented by the sprintf-like conversion of UTF-8 format"]
            #[doc = " filled from trailing UTF-8 arguments."]
            #[doc = ""]
            #[doc = " Return true iff the warning was successfully reported without reporting an"]
            #[doc = " error (or being upgraded into one)."]
            #[link_name = "\u{1}_ZN2JS8WarnUTF8EP9JSContextPKcz"]
            pub fn WarnUTF8(
                cx: *mut root::JSContext,
                format: *const ::std::os::raw::c_char,
                ...
            ) -> bool;
        }
        pub type WarningReporter = ::std::option::Option<
            unsafe extern "C" fn(cx: *mut root::JSContext, report: *mut root::JSErrorReport),
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18GetWarningReporterEP9JSContext"]
            pub fn GetWarningReporter(cx: *mut root::JSContext) -> root::JS::WarningReporter;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2JS18SetWarningReporterEP9JSContextPFvS1_P13JSErrorReportE"]
            pub fn SetWarningReporter(
                cx: *mut root::JSContext,
                reporter: root::JS::WarningReporter,
            ) -> root::JS::WarningReporter;
        }
        #[doc = " A simple RAII class that clears the registered warning reporter on"]
        #[doc = " construction and restores it on destruction."]
        #[doc = ""]
        #[doc = " A fresh warning reporter *may* be set while an instance of this class is"]
        #[doc = " live, but it must be unset in LIFO fashion by the time that instance is"]
        #[doc = " destroyed."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct AutoSuppressWarningReporter {
            pub context_: *mut root::JSContext,
            pub prevReporter_: root::JS::WarningReporter,
        }
        #[test]
        fn bindgen_test_layout_AutoSuppressWarningReporter() {
            assert_eq!(
                ::std::mem::size_of::<AutoSuppressWarningReporter>(),
                16usize,
                concat!("Size of: ", stringify!(AutoSuppressWarningReporter))
            );
            assert_eq!(
                ::std::mem::align_of::<AutoSuppressWarningReporter>(),
                8usize,
                concat!("Alignment of ", stringify!(AutoSuppressWarningReporter))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AutoSuppressWarningReporter>())).context_ as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoSuppressWarningReporter),
                    "::",
                    stringify!(context_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<AutoSuppressWarningReporter>())).prevReporter_
                        as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(AutoSuppressWarningReporter),
                    "::",
                    stringify!(prevReporter_)
                )
            );
        }
        #[doc = " <div rustbindgen replaces=\"JS::CallArgs\"></div>"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CallArgs {
            pub argv_: *mut root::JS::Value,
            pub argc_: ::std::os::raw::c_uint,
            pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 1usize], u8>,
            pub __bindgen_padding_0: [u8; 3usize],
        }
        #[test]
        fn bindgen_test_layout_CallArgs() {
            assert_eq!(
                ::std::mem::size_of::<CallArgs>(),
                16usize,
                concat!("Size of: ", stringify!(CallArgs))
            );
            assert_eq!(
                ::std::mem::align_of::<CallArgs>(),
                8usize,
                concat!("Alignment of ", stringify!(CallArgs))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<CallArgs>())).argv_ as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CallArgs),
                    "::",
                    stringify!(argv_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<CallArgs>())).argc_ as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(CallArgs),
                    "::",
                    stringify!(argc_)
                )
            );
        }
        impl CallArgs {
            #[inline]
            pub fn constructing_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_constructing_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignoresReturnValue_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_ignoresReturnValue_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(
                constructing_: bool,
                ignoresReturnValue_: bool,
            ) -> root::__BindgenBitfieldUnit<[u8; 1usize], u8> {
                let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 1usize], u8> =
                    Default::default();
                __bindgen_bitfield_unit.set(0usize, 1u8, {
                    let constructing_: u8 = unsafe { ::std::mem::transmute(constructing_) };
                    constructing_ as u64
                });
                __bindgen_bitfield_unit.set(1usize, 1u8, {
                    let ignoresReturnValue_: u8 =
                        unsafe { ::std::mem::transmute(ignoresReturnValue_) };
                    ignoresReturnValue_ as u64
                });
                __bindgen_bitfield_unit
            }
        }
        #[doc = " <div rustbindgen replaces=\"JS::MutableHandleIdVector\" />"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MutableHandleIdVector {
            pub ptr: *mut ::std::os::raw::c_void,
        }
        #[test]
        fn bindgen_test_layout_MutableHandleIdVector() {
            assert_eq!(
                ::std::mem::size_of::<MutableHandleIdVector>(),
                8usize,
                concat!("Size of: ", stringify!(MutableHandleIdVector))
            );
            assert_eq!(
                ::std::mem::align_of::<MutableHandleIdVector>(),
                8usize,
                concat!("Alignment of ", stringify!(MutableHandleIdVector))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<MutableHandleIdVector>())).ptr as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(MutableHandleIdVector),
                    "::",
                    stringify!(ptr)
                )
            );
        }
        #[doc = " <div rustbindgen replaces=\"JS::HandleObjectVector\" />"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HandleObjectVector {
            pub ptr: *mut ::std::os::raw::c_void,
        }
        #[test]
        fn bindgen_test_layout_HandleObjectVector() {
            assert_eq!(
                ::std::mem::size_of::<HandleObjectVector>(),
                8usize,
                concat!("Size of: ", stringify!(HandleObjectVector))
            );
            assert_eq!(
                ::std::mem::align_of::<HandleObjectVector>(),
                8usize,
                concat!("Alignment of ", stringify!(HandleObjectVector))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<HandleObjectVector>())).ptr as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(HandleObjectVector),
                    "::",
                    stringify!(ptr)
                )
            );
        }
        #[doc = " <div rustbindgen replaces=\"JS::MutableHandleObjectVector\" />"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct MutableHandleObjectVector {
            pub ptr: *mut ::std::os::raw::c_void,
        }
        #[test]
        fn bindgen_test_layout_MutableHandleObjectVector() {
            assert_eq!(
                ::std::mem::size_of::<MutableHandleObjectVector>(),
                8usize,
                concat!("Size of: ", stringify!(MutableHandleObjectVector))
            );
            assert_eq!(
                ::std::mem::align_of::<MutableHandleObjectVector>(),
                8usize,
                concat!("Alignment of ", stringify!(MutableHandleObjectVector))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<MutableHandleObjectVector>())).ptr as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(MutableHandleObjectVector),
                    "::",
                    stringify!(ptr)
                )
            );
        }
        #[test]
        fn __bindgen_test_layout_GCPolicy_open0_ptr_Realm_close0_instantiation_1() {
            assert_eq!(
                ::std::mem::size_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Size of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
            assert_eq!(
                ::std::mem::align_of::<root::JS::GCPolicy>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::JS::GCPolicy)
                )
            );
        }
    }
    pub type jsbytecode = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSAtom {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSContext {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSFunction {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSFreeOp {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSObject {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSRuntime {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSScript {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSString {
        _unused: [u8; 0],
    }
    pub type jsid = root::JS::PropertyKey;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum JSType {
        JSTYPE_UNDEFINED = 0,
        JSTYPE_OBJECT = 1,
        JSTYPE_FUNCTION = 2,
        JSTYPE_STRING = 3,
        JSTYPE_NUMBER = 4,
        JSTYPE_BOOLEAN = 5,
        JSTYPE_NULL = 6,
        JSTYPE_SYMBOL = 7,
        JSTYPE_BIGINT = 8,
        JSTYPE_LIMIT = 9,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum JSProtoKey {
        JSProto_Null = 0,
        JSProto_Object = 1,
        JSProto_Function = 2,
        JSProto_Array = 3,
        JSProto_Boolean = 4,
        JSProto_JSON = 5,
        JSProto_Date = 6,
        JSProto_Math = 7,
        JSProto_Number = 8,
        JSProto_String = 9,
        JSProto_RegExp = 10,
        JSProto_Error = 11,
        JSProto_InternalError = 12,
        JSProto_AggregateError = 13,
        JSProto_EvalError = 14,
        JSProto_RangeError = 15,
        JSProto_ReferenceError = 16,
        JSProto_SyntaxError = 17,
        JSProto_TypeError = 18,
        JSProto_URIError = 19,
        JSProto_DebuggeeWouldRun = 20,
        JSProto_CompileError = 21,
        JSProto_LinkError = 22,
        JSProto_RuntimeError = 23,
        JSProto_ArrayBuffer = 24,
        JSProto_Int8Array = 25,
        JSProto_Uint8Array = 26,
        JSProto_Int16Array = 27,
        JSProto_Uint16Array = 28,
        JSProto_Int32Array = 29,
        JSProto_Uint32Array = 30,
        JSProto_Float32Array = 31,
        JSProto_Float64Array = 32,
        JSProto_Uint8ClampedArray = 33,
        JSProto_BigInt64Array = 34,
        JSProto_BigUint64Array = 35,
        JSProto_BigInt = 36,
        JSProto_Proxy = 37,
        JSProto_WeakMap = 38,
        JSProto_Map = 39,
        JSProto_Set = 40,
        JSProto_DataView = 41,
        JSProto_Symbol = 42,
        JSProto_SharedArrayBuffer = 43,
        JSProto_Intl = 44,
        JSProto_Collator = 45,
        JSProto_DateTimeFormat = 46,
        JSProto_ListFormat = 47,
        JSProto_Locale = 48,
        JSProto_NumberFormat = 49,
        JSProto_PluralRules = 50,
        JSProto_RelativeTimeFormat = 51,
        JSProto_TypedObject = 52,
        JSProto_Reflect = 53,
        JSProto_WeakSet = 54,
        JSProto_TypedArray = 55,
        JSProto_Atomics = 56,
        JSProto_SavedFrame = 57,
        JSProto_Promise = 58,
        JSProto_AsyncFunction = 59,
        JSProto_GeneratorFunction = 60,
        JSProto_AsyncGeneratorFunction = 61,
        JSProto_ReadableStream = 62,
        JSProto_ReadableStreamDefaultReader = 63,
        JSProto_ReadableStreamDefaultController = 64,
        JSProto_ReadableByteStreamController = 65,
        JSProto_WritableStream = 66,
        JSProto_WritableStreamDefaultController = 67,
        JSProto_WritableStreamDefaultWriter = 68,
        JSProto_ByteLengthQueuingStrategy = 69,
        JSProto_CountQueuingStrategy = 70,
        JSProto_WebAssembly = 71,
        JSProto_WasmModule = 72,
        JSProto_WasmInstance = 73,
        JSProto_WasmMemory = 74,
        JSProto_WasmTable = 75,
        JSProto_WasmGlobal = 76,
        JSProto_FinalizationGroup = 77,
        JSProto_LIMIT = 78,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSExceptionState {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSStructuredCloneReader {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSStructuredCloneWriter {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSLinearString {
        _unused: [u8; 0],
    }
    pub type JSConstDoubleSpec = root::JSConstScalarSpec<f64>;
    pub type JSConstIntegerSpec = root::JSConstScalarSpec<i32>;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct PLDHashTableOps {
        _unused: [u8; 0],
    }
    pub type arena_id_t = usize;
    extern "C" {
        #[link_name = "\u{1}_Z9JS_AssertPKcS0_i"]
        pub fn JS_Assert(
            s: *const ::std::os::raw::c_char,
            file: *const ::std::os::raw::c_char,
            ln: ::std::os::raw::c_int,
        );
    }
    extern "C" {
        #[doc = " Complain when out of memory."]
        #[link_name = "\u{1}_Z20JS_ReportOutOfMemoryP9JSContext"]
        pub fn JS_ReportOutOfMemory(cx: *mut root::JSContext);
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum WeakMapTraceKind {
        #[doc = " Do not trace into weak map keys or values during traversal. Users must"]
        #[doc = " handle weak maps manually."]
        DoNotTraceWeakMaps = 0,
        #[doc = " Do true ephemeron marking with a weak key lookup marking phase. This is"]
        #[doc = " the default for GCMarker."]
        ExpandWeakMaps = 1,
        #[doc = " Trace through to all values, irrespective of whether the keys are live"]
        #[doc = " or not. Used for non-marking tracers."]
        TraceWeakMapValues = 2,
        #[doc = " Trace through to all keys and values, irrespective of whether the keys"]
        #[doc = " are live or not. Used for non-marking tracers."]
        TraceWeakMapKeysValues = 3,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSTracer {
        pub runtime_: *mut root::JSRuntime,
        pub weakMapAction_: root::WeakMapTraceKind,
        pub tag_: root::JSTracer_TracerKindTag,
        pub traceWeakEdges_: bool,
        pub canSkipJsids_: bool,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum JSTracer_TracerKindTag {
        Marking = 0,
        Tenuring = 1,
        Callback = 2,
    }
    #[test]
    fn bindgen_test_layout_JSTracer() {
        assert_eq!(
            ::std::mem::size_of::<JSTracer>(),
            24usize,
            concat!("Size of: ", stringify!(JSTracer))
        );
        assert_eq!(
            ::std::mem::align_of::<JSTracer>(),
            8usize,
            concat!("Alignment of ", stringify!(JSTracer))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSTracer>())).runtime_ as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSTracer),
                "::",
                stringify!(runtime_)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSTracer>())).weakMapAction_ as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSTracer),
                "::",
                stringify!(weakMapAction_)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSTracer>())).tag_ as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(JSTracer),
                "::",
                stringify!(tag_)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSTracer>())).traceWeakEdges_ as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(JSTracer),
                "::",
                stringify!(traceWeakEdges_)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSTracer>())).canSkipJsids_ as *const _ as usize },
            17usize,
            concat!(
                "Offset of field: ",
                stringify!(JSTracer),
                "::",
                stringify!(canSkipJsids_)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_GetTraceThingInfoPcmP8JSTracerPvN2JS9TraceKindEb"]
        pub fn JS_GetTraceThingInfo(
            buf: *mut ::std::os::raw::c_char,
            bufsize: usize,
            trc: *mut root::JSTracer,
            thing: *mut ::std::os::raw::c_void,
            kind: root::JS::TraceKind,
            includeDetails: bool,
        );
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct ProfilingStack {
        pub capacity: u32,
        pub frames: u64,
        pub stackPointer: u32,
    }
    #[test]
    fn bindgen_test_layout_ProfilingStack() {
        assert_eq!(
            ::std::mem::size_of::<ProfilingStack>(),
            24usize,
            concat!("Size of: ", stringify!(ProfilingStack))
        );
        assert_eq!(
            ::std::mem::align_of::<ProfilingStack>(),
            8usize,
            concat!("Alignment of ", stringify!(ProfilingStack))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<ProfilingStack>())).capacity as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ProfilingStack),
                "::",
                stringify!(capacity)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<ProfilingStack>())).frames as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ProfilingStack),
                "::",
                stringify!(frames)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<ProfilingStack>())).stackPointer as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ProfilingStack),
                "::",
                stringify!(stackPointer)
            )
        );
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum JSGCMode {
        #[doc = " Perform only global GCs."]
        JSGC_MODE_GLOBAL = 0,
        #[doc = " Perform per-zone GCs until too much garbage has accumulated."]
        JSGC_MODE_ZONE = 1,
        #[doc = " Collect in short time slices rather than all at once."]
        JSGC_MODE_INCREMENTAL = 2,
        #[doc = " Both of the above."]
        JSGC_MODE_ZONE_INCREMENTAL = 3,
    }
    #[repr(u32)]
    #[doc = " Kinds of js_GC invocation."]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum JSGCInvocationKind {
        GC_NORMAL = 0,
        GC_SHRINK = 1,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum JSGCParamKey {
        #[doc = " Maximum nominal heap before last ditch GC."]
        #[doc = ""]
        #[doc = " Soft limit on the number of bytes we are allowed to allocate in the GC"]
        #[doc = " heap. Attempts to allocate gcthings over this limit will return null and"]
        #[doc = " subsequently invoke the standard OOM machinery, independent of available"]
        #[doc = " physical memory."]
        #[doc = ""]
        #[doc = " Pref: javascript.options.mem.max"]
        #[doc = " Default: 0xffffffff"]
        JSGC_MAX_BYTES = 0,
        #[doc = " Maximum size of the generational GC nurseries."]
        #[doc = ""]
        #[doc = " This will be rounded to the nearest gc::ChunkSize."]
        #[doc = ""]
        #[doc = " Pref: javascript.options.mem.nursery.max_kb"]
        #[doc = " Default: JS::DefaultNurseryMaxBytes"]
        JSGC_MAX_NURSERY_BYTES = 2,
        #[doc = " Amount of bytes allocated by the GC."]
        JSGC_BYTES = 3,
        #[doc = " Number of times GC has been invoked. Includes both major and minor GC."]
        JSGC_NUMBER = 4,
        #[doc = " Select GC mode."]
        #[doc = ""]
        #[doc = " See: JSGCMode in GCAPI.h"]
        #[doc = " prefs: javascript.options.mem.gc_per_zone and"]
        #[doc = "   javascript.options.mem.gc_incremental."]
        #[doc = " Default: JSGC_MODE_ZONE_INCREMENTAL"]
        JSGC_MODE = 6,
        #[doc = " Number of cached empty GC chunks."]
        JSGC_UNUSED_CHUNKS = 7,
        #[doc = " Total number of allocated GC chunks."]
        JSGC_TOTAL_CHUNKS = 8,
        #[doc = " Max milliseconds to spend in an incremental GC slice."]
        #[doc = ""]
        #[doc = " Pref: javascript.options.mem.gc_incremental_slice_ms"]
        #[doc = " Default: DefaultTimeBudgetMS."]
        JSGC_SLICE_TIME_BUDGET_MS = 9,
        #[doc = " Maximum size the GC mark stack can grow to."]
        #[doc = ""]
        #[doc = " Pref: none"]
        #[doc = " Default: MarkStack::DefaultCapacity"]
        JSGC_MARK_STACK_LIMIT = 10,
        #[doc = " GCs less than this far apart in milliseconds will be considered"]
        #[doc = " 'high-frequency GCs'."]
        #[doc = ""]
        #[doc = " Pref: javascript.options.mem.gc_high_frequency_time_limit_ms"]
        #[doc = " Default: HighFrequencyThreshold"]
        JSGC_HIGH_FREQUENCY_TIME_LIMIT = 11,
        #[doc = " Start of dynamic heap growth (MB)."]
        #[doc = ""]
        #[doc = " Pref: javascript.options.mem.gc_high_frequency_low_limit_mb"]
        #[doc = " Default: HighFrequencyLowLimitBytes"]
        JSGC_HIGH_FREQUENCY_LOW_LIMIT = 12,
        #[doc = " End of dynamic heap growth (MB)."]
        #[doc = ""]
        #[doc = " Pref: javascript.options.mem.gc_high_frequency_high_limit_mb"]
        #[doc = " Default: HighFrequencyHighLimitBytes"]
        JSGC_HIGH_FREQUENCY_HIGH_LIMIT = 13,
        #[doc = " Upper bound of heap growth percentage."]
        #[doc = ""]
        #[doc = " Pref: javascript.options.mem.gc_high_frequency_heap_growth_max"]
        #[doc = " Default: HighFrequencyHeapGrowthMax"]
        JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MAX = 14,
        #[doc = " Lower bound of heap growth percentage."]
        #[doc = ""]
        #[doc = " Pref: javascript.options.mem.gc_high_frequency_heap_growth_min"]
        #[doc = " Default: HighFrequencyHeapGrowthMin"]
        JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MIN = 15,
        #[doc = " Heap growth percentage for low frequency GCs."]
        #[doc = ""]
        #[doc = " Pref: javascript.options.mem.gc_low_frequency_heap_growth"]
        #[doc = " Default: LowFrequencyHeapGrowth"]
        JSGC_LOW_FREQUENCY_HEAP_GROWTH = 16,
        #[doc = " If false, the heap growth factor is fixed at 3. If true, it is determined"]
        #[doc = " based on whether GCs are high- or low- frequency."]
        #[doc = ""]
        #[doc = " Pref: javascript.options.mem.gc_dynamic_heap_growth"]
        #[doc = " Default: DynamicHeapGrowthEnabled"]
        JSGC_DYNAMIC_HEAP_GROWTH = 17,
        #[doc = " If true, high-frequency GCs will use a longer mark slice."]
        #[doc = ""]
        #[doc = " Pref: javascript.options.mem.gc_dynamic_mark_slice"]
        #[doc = " Default: DynamicMarkSliceEnabled"]
        JSGC_DYNAMIC_MARK_SLICE = 18,
        #[doc = " Lower limit for collecting a zone."]
        #[doc = ""]
        #[doc = " Zones smaller than this size will not normally be collected."]
        #[doc = ""]
        #[doc = " Pref: javascript.options.mem.gc_allocation_threshold_mb"]
        #[doc = " Default GCZoneAllocThresholdBase"]
        JSGC_ALLOCATION_THRESHOLD = 19,
        #[doc = " We try to keep at least this many unused chunks in the free chunk pool at"]
        #[doc = " all times, even after a shrinking GC."]
        #[doc = ""]
        #[doc = " Pref: javascript.options.mem.gc_min_empty_chunk_count"]
        #[doc = " Default: MinEmptyChunkCount"]
        JSGC_MIN_EMPTY_CHUNK_COUNT = 21,
        #[doc = " We never keep more than this many unused chunks in the free chunk"]
        #[doc = " pool."]
        #[doc = ""]
        #[doc = " Pref: javascript.options.mem.gc_min_empty_chunk_count"]
        #[doc = " Default: MinEmptyChunkCount"]
        JSGC_MAX_EMPTY_CHUNK_COUNT = 22,
        #[doc = " Whether compacting GC is enabled."]
        #[doc = ""]
        #[doc = " Pref: javascript.options.mem.gc_compacting"]
        #[doc = " Default: CompactingEnabled"]
        JSGC_COMPACTING_ENABLED = 23,
        #[doc = " Percentage for how far over a trigger threshold we go before triggering a"]
        #[doc = " non-incremental GC."]
        #[doc = ""]
        #[doc = " We trigger an incremental GC when a trigger threshold is reached but the"]
        #[doc = " collection may not be fast enough to keep up with the mutator. At some"]
        #[doc = " point we finish the collection non-incrementally."]
        #[doc = ""]
        #[doc = " Default: NonIncrementalFactor"]
        #[doc = " Pref: None"]
        JSGC_NON_INCREMENTAL_FACTOR = 25,
        #[doc = " Percentage for how far over a trigger threshold we go before triggering an"]
        #[doc = " incremental collection that would reset an in-progress collection."]
        #[doc = ""]
        #[doc = " Default: AvoidInterruptFactor"]
        #[doc = " Pref: None"]
        JSGC_AVOID_INTERRUPT_FACTOR = 26,
        #[doc = " Attempt to run a minor GC in the idle time if the free space falls"]
        #[doc = " below this number of bytes."]
        #[doc = ""]
        #[doc = " Default: NurseryChunkUsableSize / 4"]
        #[doc = " Pref: None"]
        JSGC_NURSERY_FREE_THRESHOLD_FOR_IDLE_COLLECTION = 27,
        #[doc = " If this percentage of the nursery is tenured and the nursery is at least"]
        #[doc = " 4MB, then proceed to examine which groups we should pretenure."]
        #[doc = ""]
        #[doc = " Default: PretenureThreshold"]
        #[doc = " Pref: None"]
        JSGC_PRETENURE_THRESHOLD = 28,
        #[doc = " If the above condition is met, then any object group that tenures more than"]
        #[doc = " this number of objects will be pretenured (if it can be)."]
        #[doc = ""]
        #[doc = " Default: PretenureGroupThreshold"]
        #[doc = " Pref: None"]
        JSGC_PRETENURE_GROUP_THRESHOLD = 29,
        #[doc = " Attempt to run a minor GC in the idle time if the free space falls"]
        #[doc = " below this percentage (from 0 to 99)."]
        #[doc = ""]
        #[doc = " Default: 25"]
        #[doc = " Pref: None"]
        JSGC_NURSERY_FREE_THRESHOLD_FOR_IDLE_COLLECTION_PERCENT = 30,
        #[doc = " Minimum size of the generational GC nurseries."]
        #[doc = ""]
        #[doc = " This value will be rounded to the nearest Nursery::SubChunkStep if below"]
        #[doc = " gc::ChunkSize, otherwise it'll be rounded to the nearest gc::ChunkSize."]
        #[doc = ""]
        #[doc = " Default: Nursery::SubChunkLimit"]
        #[doc = " Pref: javascript.options.mem.nursery.min_kb"]
        JSGC_MIN_NURSERY_BYTES = 31,
        #[doc = " The minimum time to allow between triggering last ditch GCs in seconds."]
        #[doc = ""]
        #[doc = " Default: 60 seconds"]
        #[doc = " Pref: None"]
        JSGC_MIN_LAST_DITCH_GC_PERIOD = 32,
        #[doc = " The delay (in heapsize kilobytes) between slices of an incremental GC."]
        #[doc = ""]
        #[doc = " Default: ZoneAllocDelayBytes"]
        JSGC_ZONE_ALLOC_DELAY_KB = 33,
        #[doc = " The delay (in heapsize kilobytes) between slices of an incremental GC."]
        #[doc = ""]
        #[doc = " Default: ZoneAllocDelayBytes"]
        JSGC_NURSERY_BYTES = 34,
        #[doc = " Retained size base value for calculating malloc heap threshold."]
        #[doc = ""]
        #[doc = " Default: MallocThresholdBase"]
        JSGC_MALLOC_THRESHOLD_BASE = 35,
        #[doc = " Growth factor for calculating malloc heap threshold."]
        #[doc = ""]
        #[doc = " Default: MallocGrowthFactor"]
        JSGC_MALLOC_GROWTH_FACTOR = 36,
    }
    pub type JSTraceDataOp = ::std::option::Option<
        unsafe extern "C" fn(trc: *mut root::JSTracer, data: *mut ::std::os::raw::c_void),
    >;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum JSGCStatus {
        JSGC_BEGIN = 0,
        JSGC_END = 1,
    }
    pub type JSGCCallback = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            status: root::JSGCStatus,
            data: *mut ::std::os::raw::c_void,
        ),
    >;
    pub type JSObjectsTenuredCallback = ::std::option::Option<
        unsafe extern "C" fn(cx: *mut root::JSContext, data: *mut ::std::os::raw::c_void),
    >;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum JSFinalizeStatus {
        #[doc = " Called when preparing to sweep a group of zones, before anything has been"]
        #[doc = " swept.  The collector will not yield to the mutator before calling the"]
        #[doc = " callback with JSFINALIZE_GROUP_START status."]
        JSFINALIZE_GROUP_PREPARE = 0,
        #[doc = " Called after preparing to sweep a group of zones. Weak references to"]
        #[doc = " unmarked things have been removed at this point, but no GC things have"]
        #[doc = " been swept. The collector may yield to the mutator after this point."]
        JSFINALIZE_GROUP_START = 1,
        #[doc = " Called after sweeping a group of zones. All dead GC things have been"]
        #[doc = " swept at this point."]
        JSFINALIZE_GROUP_END = 2,
        #[doc = " Called at the end of collection when everything has been swept."]
        JSFINALIZE_COLLECTION_END = 3,
    }
    pub type JSFinalizeCallback = ::std::option::Option<
        unsafe extern "C" fn(
            fop: *mut root::JSFreeOp,
            status: root::JSFinalizeStatus,
            data: *mut ::std::os::raw::c_void,
        ),
    >;
    pub type JSWeakPointerZonesCallback = ::std::option::Option<
        unsafe extern "C" fn(cx: *mut root::JSContext, data: *mut ::std::os::raw::c_void),
    >;
    pub type JSWeakPointerCompartmentCallback = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            comp: *mut root::JS::Compartment,
            data: *mut ::std::os::raw::c_void,
        ),
    >;
    pub type JSHostCleanupFinalizationGroupCallback = ::std::option::Option<
        unsafe extern "C" fn(group: *mut root::JSObject, data: *mut ::std::os::raw::c_void),
    >;
    #[repr(C)]
    pub struct JSExternalStringCallbacks__bindgen_vtable(::std::os::raw::c_void);
    #[doc = " Each external string has a pointer to JSExternalStringCallbacks. Embedders"]
    #[doc = " can use this to implement custom finalization or memory reporting behavior."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSExternalStringCallbacks {
        pub vtable_: *const JSExternalStringCallbacks__bindgen_vtable,
    }
    #[test]
    fn bindgen_test_layout_JSExternalStringCallbacks() {
        assert_eq!(
            ::std::mem::size_of::<JSExternalStringCallbacks>(),
            8usize,
            concat!("Size of: ", stringify!(JSExternalStringCallbacks))
        );
        assert_eq!(
            ::std::mem::align_of::<JSExternalStringCallbacks>(),
            8usize,
            concat!("Alignment of ", stringify!(JSExternalStringCallbacks))
        );
    }
    extern "C" {
        #[doc = " Register externally maintained GC roots."]
        #[doc = ""]
        #[doc = " traceOp: the trace operation. For each root the implementation should call"]
        #[doc = "          JS::TraceEdge whenever the root contains a traceable thing."]
        #[doc = " data:    the data argument to pass to each invocation of traceOp."]
        #[link_name = "\u{1}_Z24JS_AddExtraGCRootsTracerP9JSContextPFvP8JSTracerPvES3_"]
        pub fn JS_AddExtraGCRootsTracer(
            cx: *mut root::JSContext,
            traceOp: root::JSTraceDataOp,
            data: *mut ::std::os::raw::c_void,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Undo a call to JS_AddExtraGCRootsTracer."]
        #[link_name = "\u{1}_Z27JS_RemoveExtraGCRootsTracerP9JSContextPFvP8JSTracerPvES3_"]
        pub fn JS_RemoveExtraGCRootsTracer(
            cx: *mut root::JSContext,
            traceOp: root::JSTraceDataOp,
            data: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z5JS_GCP9JSContextN2JS8GCReasonE"]
        pub fn JS_GC(cx: *mut root::JSContext, reason: root::JS::GCReason);
    }
    extern "C" {
        #[link_name = "\u{1}_Z10JS_MaybeGCP9JSContext"]
        pub fn JS_MaybeGC(cx: *mut root::JSContext);
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_SetGCCallbackP9JSContextPFvS0_10JSGCStatusPvES2_"]
        pub fn JS_SetGCCallback(
            cx: *mut root::JSContext,
            cb: root::JSGCCallback,
            data: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z28JS_SetObjectsTenuredCallbackP9JSContextPFvS0_PvES1_"]
        pub fn JS_SetObjectsTenuredCallback(
            cx: *mut root::JSContext,
            cb: root::JSObjectsTenuredCallback,
            data: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_AddFinalizeCallbackP9JSContextPFvP8JSFreeOp16JSFinalizeStatusPvES4_"]
        pub fn JS_AddFinalizeCallback(
            cx: *mut root::JSContext,
            cb: root::JSFinalizeCallback,
            data: *mut ::std::os::raw::c_void,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_RemoveFinalizeCallbackP9JSContextPFvP8JSFreeOp16JSFinalizeStatusPvE"]
        pub fn JS_RemoveFinalizeCallback(cx: *mut root::JSContext, cb: root::JSFinalizeCallback);
    }
    extern "C" {
        #[link_name = "\u{1}_Z30JS_AddWeakPointerZonesCallbackP9JSContextPFvS0_PvES1_"]
        pub fn JS_AddWeakPointerZonesCallback(
            cx: *mut root::JSContext,
            cb: root::JSWeakPointerZonesCallback,
            data: *mut ::std::os::raw::c_void,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z33JS_RemoveWeakPointerZonesCallbackP9JSContextPFvS0_PvE"]
        pub fn JS_RemoveWeakPointerZonesCallback(
            cx: *mut root::JSContext,
            cb: root::JSWeakPointerZonesCallback,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z36JS_AddWeakPointerCompartmentCallbackP9JSContextPFvS0_PN2JS11CompartmentEPvES4_"]
        pub fn JS_AddWeakPointerCompartmentCallback(
            cx: *mut root::JSContext,
            cb: root::JSWeakPointerCompartmentCallback,
            data: *mut ::std::os::raw::c_void,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z39JS_RemoveWeakPointerCompartmentCallbackP9JSContextPFvS0_PN2JS11CompartmentEPvE"]
        pub fn JS_RemoveWeakPointerCompartmentCallback(
            cx: *mut root::JSContext,
            cb: root::JSWeakPointerCompartmentCallback,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_UpdateWeakPointerAfterGCPN2JS4HeapIP8JSObjectEE"]
        pub fn JS_UpdateWeakPointerAfterGC(objp: *mut root::JS::Heap<*mut root::JSObject>);
    }
    extern "C" {
        #[link_name = "\u{1}_Z38JS_UpdateWeakPointerAfterGCUnbarrieredPP8JSObject"]
        pub fn JS_UpdateWeakPointerAfterGCUnbarriered(objp: *mut *mut root::JSObject);
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_SetGCParameterP9JSContext12JSGCParamKeyj"]
        pub fn JS_SetGCParameter(cx: *mut root::JSContext, key: root::JSGCParamKey, value: u32);
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_ResetGCParameterP9JSContext12JSGCParamKey"]
        pub fn JS_ResetGCParameter(cx: *mut root::JSContext, key: root::JSGCParamKey);
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_GetGCParameterP9JSContext12JSGCParamKey"]
        pub fn JS_GetGCParameter(cx: *mut root::JSContext, key: root::JSGCParamKey) -> u32;
    }
    extern "C" {
        #[link_name = "\u{1}_Z40JS_SetGCParametersBasedOnAvailableMemoryP9JSContextj"]
        pub fn JS_SetGCParametersBasedOnAvailableMemory(cx: *mut root::JSContext, availMem: u32);
    }
    extern "C" {
        #[doc = " Create a new JSString whose chars member refers to external memory, i.e.,"]
        #[doc = " memory requiring application-specific finalization."]
        #[link_name = "\u{1}_Z20JS_NewExternalStringP9JSContextPKDsmPK25JSExternalStringCallbacks"]
        pub fn JS_NewExternalString(
            cx: *mut root::JSContext,
            chars: *const u16,
            length: usize,
            callbacks: *const root::JSExternalStringCallbacks,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[doc = " Create a new JSString whose chars member may refer to external memory."]
        #[doc = " If a new external string is allocated, |*allocatedExternal| is set to true."]
        #[doc = " Otherwise the returned string is either not an external string or an"]
        #[doc = " external string allocated by a previous call and |*allocatedExternal| is set"]
        #[doc = " to false. If |*allocatedExternal| is false, |fin| won't be called."]
        #[link_name = "\u{1}_Z25JS_NewMaybeExternalStringP9JSContextPKDsmPK25JSExternalStringCallbacksPb"]
        pub fn JS_NewMaybeExternalString(
            cx: *mut root::JSContext,
            chars: *const u16,
            length: usize,
            callbacks: *const root::JSExternalStringCallbacks,
            allocatedExternal: *mut bool,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[doc = " Return whether 'str' was created with JS_NewExternalString or"]
        #[doc = " JS_NewExternalStringWithClosure."]
        #[link_name = "\u{1}_Z19JS_IsExternalStringP8JSString"]
        pub fn JS_IsExternalString(str: *mut root::JSString) -> bool;
    }
    extern "C" {
        #[doc = " Return the 'callbacks' arg passed to JS_NewExternalString or"]
        #[doc = " JS_NewMaybeExternalString."]
        #[link_name = "\u{1}_Z29JS_GetExternalStringCallbacksP8JSString"]
        pub fn JS_GetExternalStringCallbacks(
            str: *mut root::JSString,
        ) -> *const root::JSExternalStringCallbacks;
    }
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum JSValueType {
        JSVAL_TYPE_DOUBLE = 0,
        JSVAL_TYPE_INT32 = 1,
        JSVAL_TYPE_BOOLEAN = 2,
        JSVAL_TYPE_UNDEFINED = 3,
        JSVAL_TYPE_NULL = 4,
        JSVAL_TYPE_MAGIC = 5,
        JSVAL_TYPE_STRING = 6,
        JSVAL_TYPE_SYMBOL = 7,
        JSVAL_TYPE_PRIVATE_GCTHING = 8,
        JSVAL_TYPE_BIGINT = 9,
        JSVAL_TYPE_OBJECT = 12,
        JSVAL_TYPE_UNKNOWN = 32,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum JSValueTag {
        JSVAL_TAG_MAX_DOUBLE = 131056,
        JSVAL_TAG_INT32 = 131057,
        JSVAL_TAG_UNDEFINED = 131059,
        JSVAL_TAG_NULL = 131060,
        JSVAL_TAG_BOOLEAN = 131058,
        JSVAL_TAG_MAGIC = 131061,
        JSVAL_TAG_STRING = 131062,
        JSVAL_TAG_SYMBOL = 131063,
        JSVAL_TAG_PRIVATE_GCTHING = 131064,
        JSVAL_TAG_BIGINT = 131065,
        JSVAL_TAG_OBJECT = 131068,
    }
    #[repr(u64)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum JSValueShiftedTag {
        JSVAL_SHIFTED_TAG_MAX_DOUBLE = 18444492278190833663,
        JSVAL_SHIFTED_TAG_INT32 = 18444633011384221696,
        JSVAL_SHIFTED_TAG_UNDEFINED = 18444914486360932352,
        JSVAL_SHIFTED_TAG_NULL = 18445055223849287680,
        JSVAL_SHIFTED_TAG_BOOLEAN = 18444773748872577024,
        JSVAL_SHIFTED_TAG_MAGIC = 18445195961337643008,
        JSVAL_SHIFTED_TAG_STRING = 18445336698825998336,
        JSVAL_SHIFTED_TAG_SYMBOL = 18445477436314353664,
        JSVAL_SHIFTED_TAG_PRIVATE_GCTHING = 18445618173802708992,
        JSVAL_SHIFTED_TAG_BIGINT = 18445758911291064320,
        JSVAL_SHIFTED_TAG_OBJECT = 18446181123756130304,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum JSWhyMagic {
        #[doc = " a hole in a native object's elements"]
        JS_ELEMENTS_HOLE = 0,
        #[doc = " there is not a pending iterator value"]
        JS_NO_ITER_VALUE = 1,
        #[doc = " exception value thrown when closing a generator"]
        JS_GENERATOR_CLOSING = 2,
        #[doc = " used in debug builds to catch tracing errors"]
        JS_ARG_POISON = 3,
        #[doc = " an empty subnode in the AST serializer"]
        JS_SERIALIZE_NO_NODE = 4,
        #[doc = " optimized-away 'arguments' value"]
        JS_OPTIMIZED_ARGUMENTS = 5,
        #[doc = " magic value passed to natives to indicate construction"]
        JS_IS_CONSTRUCTING = 6,
        #[doc = " see class js::HashableValue"]
        JS_HASH_KEY_EMPTY = 7,
        #[doc = " error while running Ion code"]
        JS_ION_ERROR = 8,
        #[doc = " missing recover instruction result"]
        JS_ION_BAILOUT = 9,
        #[doc = " optimized out slot"]
        JS_OPTIMIZED_OUT = 10,
        #[doc = " uninitialized lexical bindings that produce ReferenceError on touch."]
        JS_UNINITIALIZED_LEXICAL = 11,
        #[doc = " standard constructors are not created for off-thread parsing."]
        JS_OFF_THREAD_CONSTRUCTOR = 12,
        #[doc = " used in jit::TrySkipAwait"]
        JS_CANNOT_SKIP_AWAIT = 13,
        #[doc = " for local use"]
        JS_GENERIC_MAGIC = 14,
        #[doc = " Write records queued up in WritableStreamDefaultController.[[queue]] in the"]
        #[doc = " spec are either \"close\" (a String) or Record { [[chunk]]: chunk }, where"]
        #[doc = " chunk is an arbitrary user-provided (and therefore non-magic) value."]
        #[doc = " Represent \"close\" the String as this magic value; represent Record records"]
        #[doc = " as the |chunk| value within each of them."]
        JS_WRITABLESTREAM_CLOSE_RECORD = 15,
        #[doc = " Write records queued up in WritableStreamDefaultController.[[queue]] in the"]
        #[doc = " spec are either \"close\" (a String) or Record { [[chunk]]: chunk }, where"]
        #[doc = " chunk is an arbitrary user-provided (and therefore non-magic) value."]
        #[doc = " Represent \"close\" the String as this magic value; represent Record records"]
        #[doc = " as the |chunk| value within each of them."]
        JS_WHY_MAGIC_COUNT = 16,
    }
    pub type JSNative = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            argc: ::std::os::raw::c_uint,
            vp: *mut root::JS::Value,
        ) -> bool,
    >;
    extern "C" {
        #[doc = " DEPRECATED"]
        #[doc = ""]
        #[doc = " Allocate memory sufficient to contain the characters of |str| truncated to"]
        #[doc = " Latin-1 and a trailing null terminator, fill the memory with the characters"]
        #[doc = " interpreted in that manner plus the null terminator, and return a pointer to"]
        #[doc = " the memory."]
        #[doc = ""]
        #[doc = " This function *loses information* when it copies the characters of |str| if"]
        #[doc = " |str| contains code units greater than 0xFF.  Additionally, users that"]
        #[doc = " depend on null-termination will misinterpret the copied characters if |str|"]
        #[doc = " contains any nulls.  Avoid using this function if possible, because it will"]
        #[doc = " eventually be removed."]
        #[link_name = "\u{1}_Z23JS_EncodeStringToLatin1P9JSContextP8JSString"]
        pub fn JS_EncodeStringToLatin1(
            cx: *mut root::JSContext,
            str: *mut root::JSString,
        ) -> root::JS::UniqueChars;
    }
    extern "C" {
        #[doc = " DEPRECATED"]
        #[doc = ""]
        #[doc = " Same behavior as JS_EncodeStringToLatin1(), but encode into a UTF-8 string."]
        #[doc = ""]
        #[doc = " This function *loses information* when it copies the characters of |str| if"]
        #[doc = " |str| contains invalid UTF-16: U+FFFD REPLACEMENT CHARACTER will be copied"]
        #[doc = " instead."]
        #[doc = ""]
        #[doc = " The returned string is also subject to misinterpretation if |str| contains"]
        #[doc = " any nulls (which are faithfully transcribed into the returned string, but"]
        #[doc = " which will implicitly truncate the string if it's passed to functions that"]
        #[doc = " expect null-terminated strings)."]
        #[doc = ""]
        #[doc = " Avoid using this function if possible, because we'll remove it once we can"]
        #[doc = " devise a better API for the task."]
        #[link_name = "\u{1}_Z21JS_EncodeStringToUTF8P9JSContextN2JS6HandleIP8JSStringEE"]
        pub fn JS_EncodeStringToUTF8(
            cx: *mut root::JSContext,
            str: root::JS::Handle<*mut root::JSString>,
        ) -> root::JS::UniqueChars;
    }
    extern "C" {
        #[doc = " DEPRECATED"]
        #[doc = ""]
        #[doc = " Same behavior as JS_EncodeStringToLatin1(), but encode into an ASCII string."]
        #[doc = ""]
        #[doc = " This function asserts in debug mode that the input string contains only"]
        #[doc = " ASCII characters."]
        #[doc = ""]
        #[doc = " The returned string is also subject to misinterpretation if |str| contains"]
        #[doc = " any nulls (which are faithfully transcribed into the returned string, but"]
        #[doc = " which will implicitly truncate the string if it's passed to functions that"]
        #[doc = " expect null-terminated strings)."]
        #[doc = ""]
        #[doc = " Avoid using this function if possible, because we'll remove it once we can"]
        #[doc = " devise a better API for the task."]
        #[link_name = "\u{1}_Z22JS_EncodeStringToASCIIP9JSContextP8JSString"]
        pub fn JS_EncodeStringToASCII(
            cx: *mut root::JSContext,
            str: *mut root::JSString,
        ) -> root::JS::UniqueChars;
    }
    extern "C" {
        #[doc = " Only JSStrings that have been interned via the JSAPI can be turned into"]
        #[doc = " jsids by API clients."]
        #[doc = ""]
        #[doc = " N.B. if a jsid is backed by a string which has not been interned, that"]
        #[doc = " string must be appropriately rooted to avoid being collected by the GC."]
        #[link_name = "\u{1}_Z23INTERNED_STRING_TO_JSIDP9JSContextP8JSString"]
        pub fn INTERNED_STRING_TO_JSID(
            cx: *mut root::JSContext,
            str: *mut root::JSString,
        ) -> root::jsid;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSAtomState {
        _unused: [u8; 0],
    }
    #[doc = " Get a property named by id in obj.  Note the jsid id type -- id may"]
    #[doc = " be a string (Unicode property identifier) or an int (element index).  The"]
    #[doc = " *vp out parameter, on success, is the new property value after the action."]
    pub type JSGetterOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            vp: root::JS::MutableHandleValue,
        ) -> bool,
    >;
    #[doc = " Add a property named by id to obj."]
    pub type JSAddPropertyOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            v: root::JS::HandleValue,
        ) -> bool,
    >;
    #[doc = " Set a property named by id in obj, treating the assignment as strict"]
    #[doc = " mode code if strict is true. Note the jsid id type -- id may be a string"]
    #[doc = " (Unicode property identifier) or an int (element index)."]
    pub type JSSetterOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            v: root::JS::HandleValue,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool,
    >;
    #[doc = " Delete a property named by id in obj."]
    #[doc = ""]
    #[doc = " If an error occurred, return false as per normal JSAPI error practice."]
    #[doc = ""]
    #[doc = " If no error occurred, but the deletion attempt wasn't allowed (perhaps"]
    #[doc = " because the property was non-configurable), call result.fail() and"]
    #[doc = " return true.  This will cause |delete obj[id]| to evaluate to false in"]
    #[doc = " non-strict mode code, and to throw a TypeError in strict mode code."]
    #[doc = ""]
    #[doc = " If no error occurred and the deletion wasn't disallowed (this is *not* the"]
    #[doc = " same as saying that a deletion actually occurred -- deleting a non-existent"]
    #[doc = " property, or an inherited property, is allowed -- it's just pointless),"]
    #[doc = " call result.succeed() and return true."]
    pub type JSDeletePropertyOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool,
    >;
    #[doc = " The type of ObjectOps::enumerate. This callback overrides a portion of"]
    #[doc = " SpiderMonkey's default [[Enumerate]] internal method. When an ordinary object"]
    #[doc = " is enumerated, that object and each object on its prototype chain is tested"]
    #[doc = " for an enumerate op, and those ops are called in order. The properties each"]
    #[doc = " op adds to the 'properties' vector are added to the set of values the for-in"]
    #[doc = " loop will iterate over. All of this is nonstandard."]
    #[doc = ""]
    #[doc = " An object is \"enumerated\" when it's the target of a for-in loop or"]
    #[doc = " JS_Enumerate(). The callback's job is to populate 'properties' with the"]
    #[doc = " object's property keys. If `enumerableOnly` is true, the callback should only"]
    #[doc = " add enumerable properties."]
    pub type JSNewEnumerateOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            properties: root::JS::MutableHandleIdVector,
            enumerableOnly: bool,
        ) -> bool,
    >;
    #[doc = " The old-style JSClass.enumerate op should define all lazy properties not"]
    #[doc = " yet reflected in obj."]
    pub type JSEnumerateOp = ::std::option::Option<
        unsafe extern "C" fn(cx: *mut root::JSContext, obj: root::JS::HandleObject) -> bool,
    >;
    #[doc = " The type of ObjectOps::funToString.  This callback allows an object to"]
    #[doc = " provide a custom string to use when Function.prototype.toString is invoked on"]
    #[doc = " that object.  A null return value means OOM."]
    pub type JSFunToStringOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            isToSource: bool,
        ) -> *mut root::JSString,
    >;
    #[doc = " Resolve a lazy property named by id in obj by defining it directly in obj."]
    #[doc = " Lazy properties are those reflected from some peer native property space"]
    #[doc = " (e.g., the DOM attributes for a given node reflected as obj) on demand."]
    #[doc = ""]
    #[doc = " JS looks for a property in an object, and if not found, tries to resolve"]
    #[doc = " the given id. *resolvedp should be set to true iff the property was defined"]
    #[doc = " on |obj|."]
    pub type JSResolveOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            resolvedp: *mut bool,
        ) -> bool,
    >;
    #[doc = " A class with a resolve hook can optionally have a mayResolve hook. This hook"]
    #[doc = " must have no side effects and must return true for a given id if the resolve"]
    #[doc = " hook may resolve this id. This is useful when we're doing a \"pure\" lookup: if"]
    #[doc = " mayResolve returns false, we know we don't have to call the effectful resolve"]
    #[doc = " hook."]
    #[doc = ""]
    #[doc = " maybeObj, if non-null, is the object on which we're doing the lookup. This"]
    #[doc = " can be nullptr: during JIT compilation we sometimes know the Class but not"]
    #[doc = " the object."]
    pub type JSMayResolveOp = ::std::option::Option<
        unsafe extern "C" fn(
            names: *const root::JSAtomState,
            id: root::jsid,
            maybeObj: *mut root::JSObject,
        ) -> bool,
    >;
    #[doc = " Finalize obj, which the garbage collector has determined to be unreachable"]
    #[doc = " from other live objects or from GC roots.  Obviously, finalizers must never"]
    #[doc = " store a reference to obj."]
    pub type JSFinalizeOp = ::std::option::Option<
        unsafe extern "C" fn(fop: *mut root::JSFreeOp, obj: *mut root::JSObject),
    >;
    #[doc = " Check whether v is an instance of obj.  Return false on error or exception,"]
    #[doc = " true on success with true in *bp if v is an instance of obj, false in"]
    #[doc = " *bp otherwise."]
    pub type JSHasInstanceOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            vp: root::JS::MutableHandleValue,
            bp: *mut bool,
        ) -> bool,
    >;
    #[doc = " Function type for trace operation of the class called to enumerate all"]
    #[doc = " traceable things reachable from obj's private data structure. For each such"]
    #[doc = " thing, a trace implementation must call JS::TraceEdge on the thing's"]
    #[doc = " location."]
    #[doc = ""]
    #[doc = " JSTraceOp implementation can assume that no other threads mutates object"]
    #[doc = " state. It must not change state of the object or corresponding native"]
    #[doc = " structures. The only exception for this rule is the case when the embedding"]
    #[doc = " needs a tight integration with GC. In that case the embedding can check if"]
    #[doc = " the traversal is a part of the marking phase through calling"]
    #[doc = " JS_IsGCMarkingTracer and apply a special code like emptying caches or"]
    #[doc = " marking its native structures."]
    pub type JSTraceOp = ::std::option::Option<
        unsafe extern "C" fn(trc: *mut root::JSTracer, obj: *mut root::JSObject),
    >;
    pub type JSObjectMovedOp = ::std::option::Option<
        unsafe extern "C" fn(obj: *mut root::JSObject, old: *mut root::JSObject) -> usize,
    >;
    extern "C" {
        #[link_name = "\u{1}_ZL18JS_NULL_CLASS_SPEC"]
        pub static JS_NULL_CLASS_SPEC: *const root::js::ClassSpec;
    }
    extern "C" {
        #[link_name = "\u{1}_ZL17JS_NULL_CLASS_EXT"]
        pub static JS_NULL_CLASS_EXT: *const root::js::ClassExtension;
    }
    extern "C" {
        #[link_name = "\u{1}_ZL18JS_NULL_OBJECT_OPS"]
        pub static JS_NULL_OBJECT_OPS: *const root::js::ObjectOps;
    }
    pub const JSCLASS_HAS_PRIVATE: u32 = 1;
    pub const JSCLASS_DELAY_METADATA_BUILDER: u32 = 2;
    pub const JSCLASS_IS_WRAPPED_NATIVE: u32 = 4;
    pub const JSCLASS_PRIVATE_IS_NSISUPPORTS: u32 = 8;
    pub const JSCLASS_IS_DOMJSCLASS: u32 = 16;
    pub const JSCLASS_HAS_XRAYED_CONSTRUCTOR: u32 = 32;
    pub const JSCLASS_EMULATES_UNDEFINED: u32 = 64;
    pub const JSCLASS_USERBIT1: u32 = 128;
    pub const JSCLASS_RESERVED_SLOTS_SHIFT: usize = 8;
    pub const JSCLASS_RESERVED_SLOTS_WIDTH: u32 = 8;
    pub const JSCLASS_RESERVED_SLOTS_MASK: u32 = 255;
    pub const JSCLASS_HIGH_FLAGS_SHIFT: u32 = 16;
    pub const JSCLASS_INTERNAL_FLAG1: u32 = 65536;
    pub const JSCLASS_IS_GLOBAL: u32 = 131072;
    pub const JSCLASS_INTERNAL_FLAG2: u32 = 262144;
    pub const JSCLASS_IS_PROXY: u32 = 524288;
    pub const JSCLASS_SKIP_NURSERY_FINALIZE: u32 = 1048576;
    pub const JSCLASS_USERBIT2: u32 = 2097152;
    pub const JSCLASS_USERBIT3: u32 = 4194304;
    pub const JSCLASS_BACKGROUND_FINALIZE: u32 = 8388608;
    pub const JSCLASS_FOREGROUND_FINALIZE: u32 = 16777216;
    pub const JSCLASS_GLOBAL_APPLICATION_SLOTS: u32 = 5;
    pub const JSCLASS_GLOBAL_SLOT_COUNT: u32 = 187;
    pub const JSCLASS_GLOBAL_FLAGS: u32 = 178944;
    pub const JSCLASS_CACHED_PROTO_SHIFT: u32 = 25;
    pub const JSCLASS_CACHED_PROTO_MASK: u32 = 127;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSClassOps {
        pub addProperty: root::JSAddPropertyOp,
        pub delProperty: root::JSDeletePropertyOp,
        pub enumerate: root::JSEnumerateOp,
        pub newEnumerate: root::JSNewEnumerateOp,
        pub resolve: root::JSResolveOp,
        pub mayResolve: root::JSMayResolveOp,
        pub finalize: root::JSFinalizeOp,
        pub call: root::JSNative,
        pub hasInstance: root::JSHasInstanceOp,
        pub construct: root::JSNative,
        pub trace: root::JSTraceOp,
    }
    #[test]
    fn bindgen_test_layout_JSClassOps() {
        assert_eq!(
            ::std::mem::size_of::<JSClassOps>(),
            88usize,
            concat!("Size of: ", stringify!(JSClassOps))
        );
        assert_eq!(
            ::std::mem::align_of::<JSClassOps>(),
            8usize,
            concat!("Alignment of ", stringify!(JSClassOps))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSClassOps>())).addProperty as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClassOps),
                "::",
                stringify!(addProperty)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSClassOps>())).delProperty as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClassOps),
                "::",
                stringify!(delProperty)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSClassOps>())).enumerate as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClassOps),
                "::",
                stringify!(enumerate)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSClassOps>())).newEnumerate as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClassOps),
                "::",
                stringify!(newEnumerate)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSClassOps>())).resolve as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClassOps),
                "::",
                stringify!(resolve)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSClassOps>())).mayResolve as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClassOps),
                "::",
                stringify!(mayResolve)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSClassOps>())).finalize as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClassOps),
                "::",
                stringify!(finalize)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSClassOps>())).call as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClassOps),
                "::",
                stringify!(call)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSClassOps>())).hasInstance as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClassOps),
                "::",
                stringify!(hasInstance)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSClassOps>())).construct as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClassOps),
                "::",
                stringify!(construct)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSClassOps>())).trace as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClassOps),
                "::",
                stringify!(trace)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_ZL17JS_NULL_CLASS_OPS"]
        pub static JS_NULL_CLASS_OPS: *const root::JSClassOps;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSClass {
        pub name: *const ::std::os::raw::c_char,
        pub flags: u32,
        pub cOps: *const root::JSClassOps,
        pub spec: *const root::js::ClassSpec,
        pub ext: *const root::js::ClassExtension,
        pub oOps: *const root::js::ObjectOps,
    }
    pub const JSClass_NON_NATIVE: u32 = 262144;
    #[test]
    fn bindgen_test_layout_JSClass() {
        assert_eq!(
            ::std::mem::size_of::<JSClass>(),
            48usize,
            concat!("Size of: ", stringify!(JSClass))
        );
        assert_eq!(
            ::std::mem::align_of::<JSClass>(),
            8usize,
            concat!("Alignment of ", stringify!(JSClass))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSClass>())).name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClass),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSClass>())).flags as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClass),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSClass>())).cOps as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClass),
                "::",
                stringify!(cOps)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSClass>())).spec as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClass),
                "::",
                stringify!(spec)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSClass>())).ext as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClass),
                "::",
                stringify!(ext)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSClass>())).oOps as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(JSClass),
                "::",
                stringify!(oOps)
            )
        );
    }
    impl root::JSExnType {
        pub const JSEXN_FIRST: root::JSExnType = JSExnType::JSEXN_ERR;
    }
    impl root::JSExnType {
        pub const JSEXN_WARN: root::JSExnType = JSExnType::JSEXN_ERROR_LIMIT;
    }
    #[repr(u32)]
    #[doc = " Possible exception types. These types are part of a JSErrorFormatString"]
    #[doc = " structure. They define which error to throw in case of a runtime error."]
    #[doc = ""]
    #[doc = " JSEXN_WARN is used for warnings in js.msg files (for instance because we"]
    #[doc = " don't want to prepend 'Error:' to warning messages). This value can go away"]
    #[doc = " if we ever decide to use an entirely separate mechanism for warnings."]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum JSExnType {
        JSEXN_ERR = 0,
        JSEXN_INTERNALERR = 1,
        JSEXN_AGGREGATEERR = 2,
        JSEXN_EVALERR = 3,
        JSEXN_RANGEERR = 4,
        JSEXN_REFERENCEERR = 5,
        JSEXN_SYNTAXERR = 6,
        JSEXN_TYPEERR = 7,
        JSEXN_URIERR = 8,
        JSEXN_DEBUGGEEWOULDRUN = 9,
        JSEXN_WASMCOMPILEERROR = 10,
        JSEXN_WASMLINKERROR = 11,
        JSEXN_WASMRUNTIMEERROR = 12,
        JSEXN_ERROR_LIMIT = 13,
        JSEXN_NOTE = 14,
        JSEXN_LIMIT = 15,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSErrorFormatString {
        #[doc = " The error message name in ASCII."]
        pub name: *const ::std::os::raw::c_char,
        #[doc = " The error format string in ASCII."]
        pub format: *const ::std::os::raw::c_char,
        #[doc = " The number of arguments to expand in the formatted error message."]
        pub argCount: u16,
        #[doc = " One of the JSExnType constants above."]
        pub exnType: i16,
    }
    #[test]
    fn bindgen_test_layout_JSErrorFormatString() {
        assert_eq!(
            ::std::mem::size_of::<JSErrorFormatString>(),
            24usize,
            concat!("Size of: ", stringify!(JSErrorFormatString))
        );
        assert_eq!(
            ::std::mem::align_of::<JSErrorFormatString>(),
            8usize,
            concat!("Alignment of ", stringify!(JSErrorFormatString))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSErrorFormatString>())).name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorFormatString),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSErrorFormatString>())).format as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorFormatString),
                "::",
                stringify!(format)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSErrorFormatString>())).argCount as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorFormatString),
                "::",
                stringify!(argCount)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSErrorFormatString>())).exnType as *const _ as usize },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorFormatString),
                "::",
                stringify!(exnType)
            )
        );
    }
    pub type JSErrorCallback = ::std::option::Option<
        unsafe extern "C" fn(
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
        ) -> *const root::JSErrorFormatString,
    >;
    #[doc = " Base class that implements parts shared by JSErrorReport and"]
    #[doc = " JSErrorNotes::Note."]
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSErrorBase {
        pub message_: root::JS::ConstUTF8CharsZ,
        pub filename: *const ::std::os::raw::c_char,
        pub sourceId: ::std::os::raw::c_uint,
        pub lineno: ::std::os::raw::c_uint,
        pub column: ::std::os::raw::c_uint,
        pub errorNumber: ::std::os::raw::c_uint,
        pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 1usize], u8>,
        pub __bindgen_padding_0: [u8; 7usize],
    }
    #[test]
    fn bindgen_test_layout_JSErrorBase() {
        assert_eq!(
            ::std::mem::size_of::<JSErrorBase>(),
            40usize,
            concat!("Size of: ", stringify!(JSErrorBase))
        );
        assert_eq!(
            ::std::mem::align_of::<JSErrorBase>(),
            8usize,
            concat!("Alignment of ", stringify!(JSErrorBase))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSErrorBase>())).message_ as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorBase),
                "::",
                stringify!(message_)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSErrorBase>())).filename as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorBase),
                "::",
                stringify!(filename)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSErrorBase>())).sourceId as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorBase),
                "::",
                stringify!(sourceId)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSErrorBase>())).lineno as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorBase),
                "::",
                stringify!(lineno)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSErrorBase>())).column as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorBase),
                "::",
                stringify!(column)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSErrorBase>())).errorNumber as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorBase),
                "::",
                stringify!(errorNumber)
            )
        );
    }
    impl JSErrorBase {
        #[inline]
        pub fn ownsMessage_(&self) -> bool {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_ownsMessage_(&mut self, val: bool) {
            unsafe {
                let val: u8 = ::std::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(ownsMessage_: bool) -> root::__BindgenBitfieldUnit<[u8; 1usize], u8> {
            let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 1usize], u8> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let ownsMessage_: u8 = unsafe { ::std::mem::transmute(ownsMessage_) };
                ownsMessage_ as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[doc = " Notes associated with JSErrorReport."]
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSErrorNotes {
        pub notes_: [u64; 4usize],
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSErrorNotes_Note {
        pub _base: root::JSErrorBase,
    }
    #[test]
    fn bindgen_test_layout_JSErrorNotes_Note() {
        assert_eq!(
            ::std::mem::size_of::<JSErrorNotes_Note>(),
            40usize,
            concat!("Size of: ", stringify!(JSErrorNotes_Note))
        );
        assert_eq!(
            ::std::mem::align_of::<JSErrorNotes_Note>(),
            8usize,
            concat!("Alignment of ", stringify!(JSErrorNotes_Note))
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSErrorNotes_iterator {
        pub note_: *mut u64,
    }
    pub type JSErrorNotes_iterator_iterator_category = root::std::input_iterator_tag;
    pub type JSErrorNotes_iterator_value_type = u64;
    pub type JSErrorNotes_iterator_difference_type = isize;
    pub type JSErrorNotes_iterator_pointer = *mut root::JSErrorNotes_iterator_value_type;
    pub type JSErrorNotes_iterator_reference = *mut root::JSErrorNotes_iterator_value_type;
    #[test]
    fn bindgen_test_layout_JSErrorNotes_iterator() {
        assert_eq!(
            ::std::mem::size_of::<JSErrorNotes_iterator>(),
            8usize,
            concat!("Size of: ", stringify!(JSErrorNotes_iterator))
        );
        assert_eq!(
            ::std::mem::align_of::<JSErrorNotes_iterator>(),
            8usize,
            concat!("Alignment of ", stringify!(JSErrorNotes_iterator))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSErrorNotes_iterator>())).note_ as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorNotes_iterator),
                "::",
                stringify!(note_)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_JSErrorNotes() {
        assert_eq!(
            ::std::mem::size_of::<JSErrorNotes>(),
            32usize,
            concat!("Size of: ", stringify!(JSErrorNotes))
        );
        assert_eq!(
            ::std::mem::align_of::<JSErrorNotes>(),
            8usize,
            concat!("Alignment of ", stringify!(JSErrorNotes))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSErrorNotes>())).notes_ as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorNotes),
                "::",
                stringify!(notes_)
            )
        );
    }
    #[doc = " Describes a single error or warning that occurs in the execution of script."]
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSErrorReport {
        pub _base: root::JSErrorBase,
        pub linebuf_: *const u16,
        pub linebufLength_: usize,
        pub tokenOffset_: usize,
        pub notes: u64,
        pub flags: ::std::os::raw::c_uint,
        pub exnType: i16,
        pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 1usize], u8>,
        pub __bindgen_padding_0: u8,
    }
    #[test]
    fn bindgen_test_layout_JSErrorReport() {
        assert_eq!(
            ::std::mem::size_of::<JSErrorReport>(),
            80usize,
            concat!("Size of: ", stringify!(JSErrorReport))
        );
        assert_eq!(
            ::std::mem::align_of::<JSErrorReport>(),
            8usize,
            concat!("Alignment of ", stringify!(JSErrorReport))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSErrorReport>())).linebuf_ as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorReport),
                "::",
                stringify!(linebuf_)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSErrorReport>())).linebufLength_ as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorReport),
                "::",
                stringify!(linebufLength_)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSErrorReport>())).tokenOffset_ as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorReport),
                "::",
                stringify!(tokenOffset_)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSErrorReport>())).notes as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorReport),
                "::",
                stringify!(notes)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSErrorReport>())).flags as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorReport),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSErrorReport>())).exnType as *const _ as usize },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(JSErrorReport),
                "::",
                stringify!(exnType)
            )
        );
    }
    impl JSErrorReport {
        #[inline]
        pub fn isMuted(&self) -> bool {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_isMuted(&mut self, val: bool) {
            unsafe {
                let val: u8 = ::std::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn ownsLinebuf_(&self) -> bool {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_ownsLinebuf_(&mut self, val: bool) {
            unsafe {
                let val: u8 = ::std::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            isMuted: bool,
            ownsLinebuf_: bool,
        ) -> root::__BindgenBitfieldUnit<[u8; 1usize], u8> {
            let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 1usize], u8> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let isMuted: u8 = unsafe { ::std::mem::transmute(isMuted) };
                isMuted as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let ownsLinebuf_: u8 = unsafe { ::std::mem::transmute(ownsLinebuf_) };
                ownsLinebuf_ as u64
            });
            __bindgen_bitfield_unit
        }
    }
    extern "C" {
        #[link_name = "\u{1}_Z9JS_mallocP9JSContextm"]
        pub fn JS_malloc(cx: *mut root::JSContext, nbytes: usize) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "\u{1}_Z10JS_reallocP9JSContextPvmm"]
        pub fn JS_realloc(
            cx: *mut root::JSContext,
            p: *mut ::std::os::raw::c_void,
            oldBytes: usize,
            newBytes: usize,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[doc = " A wrapper for |js_free(p)| that may delay |js_free(p)| invocation as a"]
        #[doc = " performance optimization.  |cx| may be nullptr."]
        #[link_name = "\u{1}_Z7JS_freeP9JSContextPv"]
        pub fn JS_free(cx: *mut root::JSContext, p: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[doc = " Same as above, but for buffers that will be used with the BYOB"]
        #[doc = " (Bring Your Own Buffer) JSString creation functions, such as"]
        #[doc = " JS_NewLatin1String and JS_NewUCString"]
        #[link_name = "\u{1}_Z16JS_string_mallocP9JSContextm"]
        pub fn JS_string_malloc(
            cx: *mut root::JSContext,
            nbytes: usize,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_string_reallocP9JSContextPvmm"]
        pub fn JS_string_realloc(
            cx: *mut root::JSContext,
            p: *mut ::std::os::raw::c_void,
            oldBytes: usize,
            newBytes: usize,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "\u{1}_Z14JS_string_freeP9JSContextPv"]
        pub fn JS_string_free(cx: *mut root::JSContext, p: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[doc = " A wrapper for |js_free(p)| that may delay |js_free(p)| invocation as a"]
        #[doc = " performance optimization as specified by the given JSFreeOp instance."]
        #[link_name = "\u{1}_Z9JS_freeopP8JSFreeOpPv"]
        pub fn JS_freeop(fop: *mut root::JSFreeOp, p: *mut ::std::os::raw::c_void);
    }
    #[repr(C)]
    pub struct JSPrincipals__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSPrincipals {
        pub vtable_: *const JSPrincipals__bindgen_vtable,
        pub refcount: u32,
    }
    #[test]
    fn bindgen_test_layout_JSPrincipals() {
        assert_eq!(
            ::std::mem::size_of::<JSPrincipals>(),
            16usize,
            concat!("Size of: ", stringify!(JSPrincipals))
        );
        assert_eq!(
            ::std::mem::align_of::<JSPrincipals>(),
            8usize,
            concat!("Alignment of ", stringify!(JSPrincipals))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSPrincipals>())).refcount as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPrincipals),
                "::",
                stringify!(refcount)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_HoldPrincipalsP12JSPrincipals"]
        pub fn JS_HoldPrincipals(principals: *mut root::JSPrincipals);
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DropPrincipalsP9JSContextP12JSPrincipals"]
        pub fn JS_DropPrincipals(cx: *mut root::JSContext, principals: *mut root::JSPrincipals);
    }
    pub type JSSubsumesOp = ::std::option::Option<
        unsafe extern "C" fn(
            first: *mut root::JSPrincipals,
            second: *mut root::JSPrincipals,
        ) -> bool,
    >;
    pub type JSCSPEvalChecker = ::std::option::Option<
        unsafe extern "C" fn(cx: *mut root::JSContext, value: root::JS::HandleValue) -> bool,
    >;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSSecurityCallbacks {
        pub contentSecurityPolicyAllows: root::JSCSPEvalChecker,
        pub subsumes: root::JSSubsumesOp,
    }
    #[test]
    fn bindgen_test_layout_JSSecurityCallbacks() {
        assert_eq!(
            ::std::mem::size_of::<JSSecurityCallbacks>(),
            16usize,
            concat!("Size of: ", stringify!(JSSecurityCallbacks))
        );
        assert_eq!(
            ::std::mem::align_of::<JSSecurityCallbacks>(),
            8usize,
            concat!("Alignment of ", stringify!(JSSecurityCallbacks))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSSecurityCallbacks>())).contentSecurityPolicyAllows
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSSecurityCallbacks),
                "::",
                stringify!(contentSecurityPolicyAllows)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSSecurityCallbacks>())).subsumes as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSSecurityCallbacks),
                "::",
                stringify!(subsumes)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_SetSecurityCallbacksP9JSContextPK19JSSecurityCallbacks"]
        pub fn JS_SetSecurityCallbacks(
            cx: *mut root::JSContext,
            callbacks: *const root::JSSecurityCallbacks,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_GetSecurityCallbacksP9JSContext"]
        pub fn JS_GetSecurityCallbacks(
            cx: *mut root::JSContext,
        ) -> *const root::JSSecurityCallbacks;
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_SetTrustedPrincipalsP9JSContextP12JSPrincipals"]
        pub fn JS_SetTrustedPrincipals(cx: *mut root::JSContext, prin: *mut root::JSPrincipals);
    }
    pub type JSDestroyPrincipalsOp =
        ::std::option::Option<unsafe extern "C" fn(principals: *mut root::JSPrincipals)>;
    extern "C" {
        #[link_name = "\u{1}_Z32JS_InitDestroyPrincipalsCallbackP9JSContextPFvP12JSPrincipalsE"]
        pub fn JS_InitDestroyPrincipalsCallback(
            cx: *mut root::JSContext,
            destroyPrincipals: root::JSDestroyPrincipalsOp,
        );
    }
    pub type JSReadPrincipalsOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            reader: *mut root::JSStructuredCloneReader,
            outPrincipals: *mut *mut root::JSPrincipals,
        ) -> bool,
    >;
    extern "C" {
        #[link_name = "\u{1}_Z29JS_InitReadPrincipalsCallbackP9JSContextPFbS0_P23JSStructuredCloneReaderPP12JSPrincipalsE"]
        pub fn JS_InitReadPrincipalsCallback(
            cx: *mut root::JSContext,
            read: root::JSReadPrincipalsOp,
        );
    }
    pub const JSPROP_ENUMERATE: u8 = 1;
    pub const JSPROP_READONLY: u8 = 2;
    pub const JSPROP_PERMANENT: u8 = 4;
    pub const JSPROP_GETTER: u8 = 16;
    pub const JSPROP_SETTER: u8 = 32;
    pub const JSPROP_INTERNAL_USE_BIT: u8 = 128;
    pub const JSPROP_RESOLVING: ::std::os::raw::c_uint = 8192;
    pub const JSPROP_IGNORE_ENUMERATE: ::std::os::raw::c_uint = 16384;
    pub const JSPROP_IGNORE_READONLY: ::std::os::raw::c_uint = 32768;
    pub const JSPROP_IGNORE_PERMANENT: ::std::os::raw::c_uint = 65536;
    pub const JSPROP_IGNORE_VALUE: ::std::os::raw::c_uint = 131072;
    pub const JSPROP_FLAGS_MASK: ::std::os::raw::c_uint = 254135;
    #[doc = " Wrapper to relace JSNative for JSPropertySpecs and JSFunctionSpecs. This will"]
    #[doc = " allow us to pass one JSJitInfo per function with the property/function spec,"]
    #[doc = " without additional field overhead."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSNativeWrapper {
        pub op: root::JSNative,
        pub info: *const root::JSJitInfo,
    }
    #[test]
    fn bindgen_test_layout_JSNativeWrapper() {
        assert_eq!(
            ::std::mem::size_of::<JSNativeWrapper>(),
            16usize,
            concat!("Size of: ", stringify!(JSNativeWrapper))
        );
        assert_eq!(
            ::std::mem::align_of::<JSNativeWrapper>(),
            8usize,
            concat!("Alignment of ", stringify!(JSNativeWrapper))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSNativeWrapper>())).op as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSNativeWrapper),
                "::",
                stringify!(op)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSNativeWrapper>())).info as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSNativeWrapper),
                "::",
                stringify!(info)
            )
        );
    }
    #[doc = " Description of a property. JS_DefineProperties and JS_InitClass take arrays"]
    #[doc = " of these and define many properties at once. JS_PSG, JS_PSGS and JS_PS_END"]
    #[doc = " are helper macros for defining such arrays."]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct JSPropertySpec {
        pub name: root::JSPropertySpec_Name,
        pub flags: u8,
        pub u: root::JSPropertySpec_AccessorsOrValue,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSPropertySpec_SelfHostedWrapper {
        pub unused: root::JSNative,
        pub funname: *const ::std::os::raw::c_char,
    }
    #[test]
    fn bindgen_test_layout_JSPropertySpec_SelfHostedWrapper() {
        assert_eq!(
            ::std::mem::size_of::<JSPropertySpec_SelfHostedWrapper>(),
            16usize,
            concat!("Size of: ", stringify!(JSPropertySpec_SelfHostedWrapper))
        );
        assert_eq!(
            ::std::mem::align_of::<JSPropertySpec_SelfHostedWrapper>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(JSPropertySpec_SelfHostedWrapper)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSPropertySpec_SelfHostedWrapper>())).unused as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec_SelfHostedWrapper),
                "::",
                stringify!(unused)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSPropertySpec_SelfHostedWrapper>())).funname as *const _
                    as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec_SelfHostedWrapper),
                "::",
                stringify!(funname)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct JSPropertySpec_ValueWrapper {
        pub type_: usize,
        pub __bindgen_anon_1: root::JSPropertySpec_ValueWrapper__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union JSPropertySpec_ValueWrapper__bindgen_ty_1 {
        pub string: *const ::std::os::raw::c_char,
        pub int32: i32,
        _bindgen_union_align: u64,
    }
    #[test]
    fn bindgen_test_layout_JSPropertySpec_ValueWrapper__bindgen_ty_1() {
        assert_eq!(
            ::std::mem::size_of::<JSPropertySpec_ValueWrapper__bindgen_ty_1>(),
            8usize,
            concat!(
                "Size of: ",
                stringify!(JSPropertySpec_ValueWrapper__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<JSPropertySpec_ValueWrapper__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(JSPropertySpec_ValueWrapper__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSPropertySpec_ValueWrapper__bindgen_ty_1>())).string
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec_ValueWrapper__bindgen_ty_1),
                "::",
                stringify!(string)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSPropertySpec_ValueWrapper__bindgen_ty_1>())).int32
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec_ValueWrapper__bindgen_ty_1),
                "::",
                stringify!(int32)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_JSPropertySpec_ValueWrapper() {
        assert_eq!(
            ::std::mem::size_of::<JSPropertySpec_ValueWrapper>(),
            16usize,
            concat!("Size of: ", stringify!(JSPropertySpec_ValueWrapper))
        );
        assert_eq!(
            ::std::mem::align_of::<JSPropertySpec_ValueWrapper>(),
            8usize,
            concat!("Alignment of ", stringify!(JSPropertySpec_ValueWrapper))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSPropertySpec_ValueWrapper>())).type_ as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec_ValueWrapper),
                "::",
                stringify!(type_)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union JSPropertySpec_Accessor {
        pub native: root::JSNativeWrapper,
        pub selfHosted: root::JSPropertySpec_SelfHostedWrapper,
        _bindgen_union_align: [u64; 2usize],
    }
    #[test]
    fn bindgen_test_layout_JSPropertySpec_Accessor() {
        assert_eq!(
            ::std::mem::size_of::<JSPropertySpec_Accessor>(),
            16usize,
            concat!("Size of: ", stringify!(JSPropertySpec_Accessor))
        );
        assert_eq!(
            ::std::mem::align_of::<JSPropertySpec_Accessor>(),
            8usize,
            concat!("Alignment of ", stringify!(JSPropertySpec_Accessor))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSPropertySpec_Accessor>())).native as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec_Accessor),
                "::",
                stringify!(native)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSPropertySpec_Accessor>())).selfHosted as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec_Accessor),
                "::",
                stringify!(selfHosted)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union JSPropertySpec_AccessorsOrValue {
        pub accessors: root::JSPropertySpec_AccessorsOrValue_Accessors,
        pub value: root::JSPropertySpec_ValueWrapper,
        _bindgen_union_align: [u64; 4usize],
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct JSPropertySpec_AccessorsOrValue_Accessors {
        pub getter: root::JSPropertySpec_Accessor,
        pub setter: root::JSPropertySpec_Accessor,
    }
    #[test]
    fn bindgen_test_layout_JSPropertySpec_AccessorsOrValue_Accessors() {
        assert_eq!(
            ::std::mem::size_of::<JSPropertySpec_AccessorsOrValue_Accessors>(),
            32usize,
            concat!(
                "Size of: ",
                stringify!(JSPropertySpec_AccessorsOrValue_Accessors)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<JSPropertySpec_AccessorsOrValue_Accessors>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(JSPropertySpec_AccessorsOrValue_Accessors)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSPropertySpec_AccessorsOrValue_Accessors>())).getter
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec_AccessorsOrValue_Accessors),
                "::",
                stringify!(getter)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSPropertySpec_AccessorsOrValue_Accessors>())).setter
                    as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec_AccessorsOrValue_Accessors),
                "::",
                stringify!(setter)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_JSPropertySpec_AccessorsOrValue() {
        assert_eq!(
            ::std::mem::size_of::<JSPropertySpec_AccessorsOrValue>(),
            32usize,
            concat!("Size of: ", stringify!(JSPropertySpec_AccessorsOrValue))
        );
        assert_eq!(
            ::std::mem::align_of::<JSPropertySpec_AccessorsOrValue>(),
            8usize,
            concat!("Alignment of ", stringify!(JSPropertySpec_AccessorsOrValue))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSPropertySpec_AccessorsOrValue>())).accessors as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec_AccessorsOrValue),
                "::",
                stringify!(accessors)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSPropertySpec_AccessorsOrValue>())).value as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec_AccessorsOrValue),
                "::",
                stringify!(value)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union JSPropertySpec_Name {
        pub string_: *const ::std::os::raw::c_char,
        pub symbol_: usize,
        _bindgen_union_align: u64,
    }
    #[test]
    fn bindgen_test_layout_JSPropertySpec_Name() {
        assert_eq!(
            ::std::mem::size_of::<JSPropertySpec_Name>(),
            8usize,
            concat!("Size of: ", stringify!(JSPropertySpec_Name))
        );
        assert_eq!(
            ::std::mem::align_of::<JSPropertySpec_Name>(),
            8usize,
            concat!("Alignment of ", stringify!(JSPropertySpec_Name))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSPropertySpec_Name>())).string_ as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec_Name),
                "::",
                stringify!(string_)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSPropertySpec_Name>())).symbol_ as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec_Name),
                "::",
                stringify!(symbol_)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_JSPropertySpec() {
        assert_eq!(
            ::std::mem::size_of::<JSPropertySpec>(),
            48usize,
            concat!("Size of: ", stringify!(JSPropertySpec))
        );
        assert_eq!(
            ::std::mem::align_of::<JSPropertySpec>(),
            8usize,
            concat!("Alignment of ", stringify!(JSPropertySpec))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSPropertySpec>())).name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSPropertySpec>())).flags as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSPropertySpec>())).u as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(JSPropertySpec),
                "::",
                stringify!(u)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct JSFunctionSpec {
        pub name: root::JSFunctionSpec_Name,
        pub call: root::JSNativeWrapper,
        pub nargs: u16,
        pub flags: u16,
        pub selfHostedName: *const ::std::os::raw::c_char,
    }
    pub type JSFunctionSpec_Name = root::JSPropertySpec_Name;
    #[test]
    fn bindgen_test_layout_JSFunctionSpec() {
        assert_eq!(
            ::std::mem::size_of::<JSFunctionSpec>(),
            40usize,
            concat!("Size of: ", stringify!(JSFunctionSpec))
        );
        assert_eq!(
            ::std::mem::align_of::<JSFunctionSpec>(),
            8usize,
            concat!("Alignment of ", stringify!(JSFunctionSpec))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSFunctionSpec>())).name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSFunctionSpec),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSFunctionSpec>())).call as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSFunctionSpec),
                "::",
                stringify!(call)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSFunctionSpec>())).nargs as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(JSFunctionSpec),
                "::",
                stringify!(nargs)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSFunctionSpec>())).flags as *const _ as usize },
            26usize,
            concat!(
                "Offset of field: ",
                stringify!(JSFunctionSpec),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSFunctionSpec>())).selfHostedName as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(JSFunctionSpec),
                "::",
                stringify!(selfHostedName)
            )
        );
    }
    #[doc = " MozRefCountType is Mozilla's reference count type."]
    #[doc = ""]
    #[doc = " We use the same type to represent the refcount of RefCounted objects"]
    #[doc = " as well, in order to be able to use the leak detection facilities"]
    #[doc = " that are implemented by XPCOM."]
    #[doc = ""]
    #[doc = " Note that this type is not in the mozilla namespace so that it is"]
    #[doc = " usable for both C and C++ code."]
    pub type MozRefCountType = usize;
    pub type MozExternalRefCountType = u32;
    pub type JSInterruptCallback =
        ::std::option::Option<unsafe extern "C" fn(cx: *mut root::JSContext) -> bool>;
    #[doc = " Callback used to ask the embedding for the cross compartment wrapper handler"]
    #[doc = " that implements the desired prolicy for this kind of object in the"]
    #[doc = " destination compartment. |obj| is the object to be wrapped. If |existing| is"]
    #[doc = " non-nullptr, it will point to an existing wrapper object that should be"]
    #[doc = " re-used if possible. |existing| is guaranteed to be a cross-compartment"]
    #[doc = " wrapper with a lazily-defined prototype and the correct global. It is"]
    #[doc = " guaranteed not to wrap a function."]
    pub type JSWrapObjectCallback = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            existing: root::JS::HandleObject,
            obj: root::JS::HandleObject,
        ) -> *mut root::JSObject,
    >;
    #[doc = " Callback used by the wrap hook to ask the embedding to prepare an object"]
    #[doc = " for wrapping in a context. This might include unwrapping other wrappers"]
    #[doc = " or even finding a more suitable object for the new compartment. If |origObj|"]
    #[doc = " is non-null, then it is the original object we are going to swap into during"]
    #[doc = " a transplant."]
    pub type JSPreWrapCallback = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            scope: root::JS::HandleObject,
            origObj: root::JS::HandleObject,
            obj: root::JS::HandleObject,
            objectPassedToWrap: root::JS::HandleObject,
            retObj: root::JS::MutableHandleObject,
        ),
    >;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSWrapObjectCallbacks {
        pub wrap: root::JSWrapObjectCallback,
        pub preWrap: root::JSPreWrapCallback,
    }
    #[test]
    fn bindgen_test_layout_JSWrapObjectCallbacks() {
        assert_eq!(
            ::std::mem::size_of::<JSWrapObjectCallbacks>(),
            16usize,
            concat!("Size of: ", stringify!(JSWrapObjectCallbacks))
        );
        assert_eq!(
            ::std::mem::align_of::<JSWrapObjectCallbacks>(),
            8usize,
            concat!("Alignment of ", stringify!(JSWrapObjectCallbacks))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSWrapObjectCallbacks>())).wrap as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSWrapObjectCallbacks),
                "::",
                stringify!(wrap)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSWrapObjectCallbacks>())).preWrap as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSWrapObjectCallbacks),
                "::",
                stringify!(preWrap)
            )
        );
    }
    pub type JSDestroyCompartmentCallback = ::std::option::Option<
        unsafe extern "C" fn(fop: *mut root::JSFreeOp, compartment: *mut root::JS::Compartment),
    >;
    pub type JSSizeOfIncludingThisCompartmentCallback = ::std::option::Option<
        unsafe extern "C" fn(
            mallocSizeOf: root::mozilla::MallocSizeOf,
            compartment: *mut root::JS::Compartment,
        ) -> usize,
    >;
    #[repr(C)]
    pub struct JSErrorInterceptor__bindgen_vtable(::std::os::raw::c_void);
    #[doc = " Callback used to intercept JavaScript errors."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSErrorInterceptor {
        pub vtable_: *const JSErrorInterceptor__bindgen_vtable,
    }
    #[test]
    fn bindgen_test_layout_JSErrorInterceptor() {
        assert_eq!(
            ::std::mem::size_of::<JSErrorInterceptor>(),
            8usize,
            concat!("Size of: ", stringify!(JSErrorInterceptor))
        );
        assert_eq!(
            ::std::mem::align_of::<JSErrorInterceptor>(),
            8usize,
            concat!("Alignment of ", stringify!(JSErrorInterceptor))
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_StringHasBeenPinnedP9JSContextP8JSString"]
        pub fn JS_StringHasBeenPinned(cx: *mut root::JSContext, str: *mut root::JSString) -> bool;
    }
    extern "C" {
        #[doc = " Microseconds since the epoch, midnight, January 1, 1970 UTC."]
        #[link_name = "\u{1}_Z6JS_Nowv"]
        pub fn JS_Now() -> i64;
    }
    extern "C" {
        #[doc = " Don't want to export data, so provide accessors for non-inline Values."]
        #[link_name = "\u{1}_Z22JS_GetEmptyStringValueP9JSContext"]
        pub fn JS_GetEmptyStringValue(cx: *mut root::JSContext) -> root::JS::Value;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_GetEmptyStringP9JSContext"]
        pub fn JS_GetEmptyString(cx: *mut root::JSContext) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_ValueToObjectP9JSContextN2JS6HandleINS1_5ValueEEENS1_13MutableHandleIP8JSObjectEE"]
        pub fn JS_ValueToObject(
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
            objp: root::JS::MutableHandleObject,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_ValueToFunctionP9JSContextN2JS6HandleINS1_5ValueEEE"]
        pub fn JS_ValueToFunction(
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
        ) -> *mut root::JSFunction;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_ValueToConstructorP9JSContextN2JS6HandleINS1_5ValueEEE"]
        pub fn JS_ValueToConstructor(
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
        ) -> *mut root::JSFunction;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_ValueToSourceP9JSContextN2JS6HandleINS1_5ValueEEE"]
        pub fn JS_ValueToSource(
            cx: *mut root::JSContext,
            v: root::JS::Handle<root::JS::Value>,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_DoubleIsInt32dPi"]
        pub fn JS_DoubleIsInt32(d: f64, ip: *mut i32) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z14JS_TypeOfValueP9JSContextN2JS6HandleINS1_5ValueEEE"]
        pub fn JS_TypeOfValue(
            cx: *mut root::JSContext,
            v: root::JS::Handle<root::JS::Value>,
        ) -> root::JSType;
    }
    extern "C" {
        #[doc = " True iff fun is the global eval function."]
        #[link_name = "\u{1}_Z24JS_IsBuiltinEvalFunctionP10JSFunction"]
        pub fn JS_IsBuiltinEvalFunction(fun: *mut root::JSFunction) -> bool;
    }
    extern "C" {
        #[doc = " True iff fun is the Function constructor."]
        #[link_name = "\u{1}_Z31JS_IsBuiltinFunctionConstructorP10JSFunction"]
        pub fn JS_IsBuiltinFunctionConstructor(fun: *mut root::JSFunction) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_NewContextjP9JSRuntime"]
        pub fn JS_NewContext(
            maxbytes: u32,
            parentRuntime: *mut root::JSRuntime,
        ) -> *mut root::JSContext;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DestroyContextP9JSContext"]
        pub fn JS_DestroyContext(cx: *mut root::JSContext);
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_GetContextPrivateP9JSContext"]
        pub fn JS_GetContextPrivate(cx: *mut root::JSContext) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_SetContextPrivateP9JSContextPv"]
        pub fn JS_SetContextPrivate(cx: *mut root::JSContext, data: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_GetParentRuntimeP9JSContext"]
        pub fn JS_GetParentRuntime(cx: *mut root::JSContext) -> *mut root::JSRuntime;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_GetRuntimeP9JSContext"]
        pub fn JS_GetRuntime(cx: *mut root::JSContext) -> *mut root::JSRuntime;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_SetFutexCanWaitP9JSContext"]
        pub fn JS_SetFutexCanWait(cx: *mut root::JSContext);
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_GetImplementationVersionv"]
        pub fn JS_GetImplementationVersion() -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "\u{1}_Z32JS_SetDestroyCompartmentCallbackP9JSContextPFvP8JSFreeOpPN2JS11CompartmentEE"]
        pub fn JS_SetDestroyCompartmentCallback(
            cx: *mut root::JSContext,
            callback: root::JSDestroyCompartmentCallback,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z44JS_SetSizeOfIncludingThisCompartmentCallbackP9JSContextPFmPFmPKvEPN2JS11CompartmentEE"]
        pub fn JS_SetSizeOfIncludingThisCompartmentCallback(
            cx: *mut root::JSContext,
            callback: root::JSSizeOfIncludingThisCompartmentCallback,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_SetWrapObjectCallbacksP9JSContextPK21JSWrapObjectCallbacks"]
        pub fn JS_SetWrapObjectCallbacks(
            cx: *mut root::JSContext,
            callbacks: *const root::JSWrapObjectCallbacks,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z30JS_SetErrorInterceptorCallbackP9JSRuntimeP18JSErrorInterceptor"]
        pub fn JS_SetErrorInterceptorCallback(
            arg1: *mut root::JSRuntime,
            callback: *mut root::JSErrorInterceptor,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z30JS_GetErrorInterceptorCallbackP9JSRuntime"]
        pub fn JS_GetErrorInterceptorCallback(
            arg1: *mut root::JSRuntime,
        ) -> *mut root::JSErrorInterceptor;
    }
    extern "C" {
        #[link_name = "\u{1}_Z15JS_GetErrorTypeRKN2JS5ValueE"]
        pub fn JS_GetErrorType(val: *const root::JS::Value) -> u8;
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_SetCompartmentPrivatePN2JS11CompartmentEPv"]
        pub fn JS_SetCompartmentPrivate(
            compartment: *mut root::JS::Compartment,
            data: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_GetCompartmentPrivatePN2JS11CompartmentE"]
        pub fn JS_GetCompartmentPrivate(
            compartment: *mut root::JS::Compartment,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_SetZoneUserDataPN2JS4ZoneEPv"]
        pub fn JS_SetZoneUserData(zone: *mut root::JS::Zone, data: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_GetZoneUserDataPN2JS4ZoneE"]
        pub fn JS_GetZoneUserData(zone: *mut root::JS::Zone) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_WrapObjectP9JSContextN2JS13MutableHandleIP8JSObjectEE"]
        pub fn JS_WrapObject(cx: *mut root::JSContext, objp: root::JS::MutableHandleObject)
            -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z12JS_WrapValueP9JSContextN2JS13MutableHandleINS1_5ValueEEE"]
        pub fn JS_WrapValue(cx: *mut root::JSContext, vp: root::JS::MutableHandleValue) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_TransplantObjectP9JSContextN2JS6HandleIP8JSObjectEES5_"]
        pub fn JS_TransplantObject(
            cx: *mut root::JSContext,
            origobj: root::JS::HandleObject,
            target: root::JS::HandleObject,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z34JS_RefreshCrossCompartmentWrappersP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_RefreshCrossCompartmentWrappers(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
        ) -> bool;
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSAutoRealm {
        pub cx_: *mut root::JSContext,
        pub oldRealm_: *mut root::JS::Realm,
    }
    #[test]
    fn bindgen_test_layout_JSAutoRealm() {
        assert_eq!(
            ::std::mem::size_of::<JSAutoRealm>(),
            16usize,
            concat!("Size of: ", stringify!(JSAutoRealm))
        );
        assert_eq!(
            ::std::mem::align_of::<JSAutoRealm>(),
            8usize,
            concat!("Alignment of ", stringify!(JSAutoRealm))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSAutoRealm>())).cx_ as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSAutoRealm),
                "::",
                stringify!(cx_)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSAutoRealm>())).oldRealm_ as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSAutoRealm),
                "::",
                stringify!(oldRealm_)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSAutoNullableRealm {
        pub cx_: *mut root::JSContext,
        pub oldRealm_: *mut root::JS::Realm,
    }
    #[test]
    fn bindgen_test_layout_JSAutoNullableRealm() {
        assert_eq!(
            ::std::mem::size_of::<JSAutoNullableRealm>(),
            16usize,
            concat!("Size of: ", stringify!(JSAutoNullableRealm))
        );
        assert_eq!(
            ::std::mem::align_of::<JSAutoNullableRealm>(),
            8usize,
            concat!("Alignment of ", stringify!(JSAutoNullableRealm))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSAutoNullableRealm>())).cx_ as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSAutoNullableRealm),
                "::",
                stringify!(cx_)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSAutoNullableRealm>())).oldRealm_ as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSAutoNullableRealm),
                "::",
                stringify!(oldRealm_)
            )
        );
    }
    pub type JSIterateCompartmentCallback = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            data: *mut ::std::os::raw::c_void,
            compartment: *mut root::JS::Compartment,
        ) -> root::JS::CompartmentIterResult,
    >;
    extern "C" {
        #[doc = " This function calls |compartmentCallback| on every compartment until either"]
        #[doc = " all compartments have been iterated or CompartmentIterResult::Stop is"]
        #[doc = " returned. Beware that there is no guarantee that the compartment will survive"]
        #[doc = " after the callback returns. Also, barriers are disabled via the TraceSession."]
        #[link_name = "\u{1}_Z22JS_IterateCompartmentsP9JSContextPvPFN2JS21CompartmentIterResultES0_S1_PNS2_11CompartmentEE"]
        pub fn JS_IterateCompartments(
            cx: *mut root::JSContext,
            data: *mut ::std::os::raw::c_void,
            compartmentCallback: root::JSIterateCompartmentCallback,
        );
    }
    extern "C" {
        #[doc = " This function calls |compartmentCallback| on every compartment in the given"]
        #[doc = " zone until either all compartments have been iterated or"]
        #[doc = " CompartmentIterResult::Stop is returned. Beware that there is no guarantee"]
        #[doc = " that the compartment will survive after the callback returns. Also, barriers"]
        #[doc = " are disabled via the TraceSession."]
        #[link_name = "\u{1}_Z28JS_IterateCompartmentsInZoneP9JSContextPN2JS4ZoneEPvPFNS1_21CompartmentIterResultES0_S4_PNS1_11CompartmentEE"]
        pub fn JS_IterateCompartmentsInZone(
            cx: *mut root::JSContext,
            zone: *mut root::JS::Zone,
            data: *mut ::std::os::raw::c_void,
            compartmentCallback: root::JSIterateCompartmentCallback,
        );
    }
    extern "C" {
        #[doc = " Mark a jsid after entering a new compartment. Different zones separately"]
        #[doc = " mark the ids in a runtime, and this must be used any time an id is obtained"]
        #[doc = " from one compartment and then used in another compartment, unless the two"]
        #[doc = " compartments are guaranteed to be in the same zone."]
        #[link_name = "\u{1}_Z18JS_MarkCrossZoneIdP9JSContextN2JS11PropertyKeyE"]
        pub fn JS_MarkCrossZoneId(cx: *mut root::JSContext, id: root::jsid);
    }
    extern "C" {
        #[doc = " If value stores a jsid (an atomized string or symbol), mark that id as for"]
        #[doc = " JS_MarkCrossZoneId."]
        #[link_name = "\u{1}_Z23JS_MarkCrossZoneIdValueP9JSContextRKN2JS5ValueE"]
        pub fn JS_MarkCrossZoneIdValue(cx: *mut root::JSContext, value: *const root::JS::Value);
    }
    extern "C" {
        #[doc = " Resolve id, which must contain either a string or an int, to a standard"]
        #[doc = " class name in obj if possible, defining the class's constructor and/or"]
        #[doc = " prototype and storing true in *resolved.  If id does not name a standard"]
        #[doc = " class or a top-level property induced by initializing a standard class,"]
        #[doc = " store false in *resolved and just return true.  Return false on error,"]
        #[doc = " as usual for bool result-typed API entry points."]
        #[doc = ""]
        #[doc = " This API can be called directly from a global object class's resolve op,"]
        #[doc = " to define standard classes lazily. The class should either have an enumerate"]
        #[doc = " hook that calls JS_EnumerateStandardClasses, or a newEnumerate hook that"]
        #[doc = " calls JS_NewEnumerateStandardClasses. newEnumerate is preferred because it's"]
        #[doc = " faster (does not define all standard classes)."]
        #[link_name = "\u{1}_Z23JS_ResolveStandardClassP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEPb"]
        pub fn JS_ResolveStandardClass(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            resolved: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_MayResolveStandardClassRK11JSAtomStateN2JS11PropertyKeyEP8JSObject"]
        pub fn JS_MayResolveStandardClass(
            names: *const root::JSAtomState,
            id: root::jsid,
            maybeObj: *mut root::JSObject,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_EnumerateStandardClassesP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_EnumerateStandardClasses(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Fill \"properties\" with a list of standard class names that have not yet been"]
        #[doc = " resolved on \"obj\".  This can be used as (part of) a newEnumerate class hook"]
        #[doc = " on a global.  Already-resolved things are excluded because they might have"]
        #[doc = " been deleted by script after being resolved and enumeration considers"]
        #[doc = " already-defined properties anyway."]
        #[link_name = "\u{1}_Z30JS_NewEnumerateStandardClassesP9JSContextN2JS6HandleIP8JSObjectEENS1_13MutableHandleINS1_13StackGCVectorINS1_11PropertyKeyEN2js15TempAllocPolicyEEEEEb"]
        pub fn JS_NewEnumerateStandardClasses(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            properties: root::JS::MutableHandleIdVector,
            enumerableOnly: bool,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Fill \"properties\" with a list of standard class names.  This can be used for"]
        #[doc = " proxies that want to define behavior that looks like enumerating a global"]
        #[doc = " without touching the global itself."]
        #[link_name = "\u{1}_Z47JS_NewEnumerateStandardClassesIncludingResolvedP9JSContextN2JS6HandleIP8JSObjectEENS1_13MutableHandleINS1_13StackGCVectorINS1_11PropertyKeyEN2js15TempAllocPolicyEEEEEb"]
        pub fn JS_NewEnumerateStandardClassesIncludingResolved(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            properties: root::JS::MutableHandleIdVector,
            enumerableOnly: bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_GetClassObjectP9JSContext10JSProtoKeyN2JS13MutableHandleIP8JSObjectEE"]
        pub fn JS_GetClassObject(
            cx: *mut root::JSContext,
            key: root::JSProtoKey,
            objp: root::JS::MutableHandle<*mut root::JSObject>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_GetClassPrototypeP9JSContext10JSProtoKeyN2JS13MutableHandleIP8JSObjectEE"]
        pub fn JS_GetClassPrototype(
            cx: *mut root::JSContext,
            key: root::JSProtoKey,
            objp: root::JS::MutableHandle<*mut root::JSObject>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z15JS_IdToProtoKeyP9JSContextN2JS6HandleINS1_11PropertyKeyEEE"]
        pub fn JS_IdToProtoKey(
            cx: *mut root::JSContext,
            id: root::JS::HandleId,
        ) -> root::JSProtoKey;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_IsGlobalObjectP8JSObject"]
        pub fn JS_IsGlobalObject(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_GlobalLexicalEnvironmentP8JSObject"]
        pub fn JS_GlobalLexicalEnvironment(obj: *mut root::JSObject) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z34JS_HasExtensibleLexicalEnvironmentP8JSObject"]
        pub fn JS_HasExtensibleLexicalEnvironment(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z31JS_ExtensibleLexicalEnvironmentP8JSObject"]
        pub fn JS_ExtensibleLexicalEnvironment(obj: *mut root::JSObject) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " Add 'Reflect.parse', a SpiderMonkey extension, to the Reflect object on the"]
        #[doc = " given global."]
        #[link_name = "\u{1}_Z19JS_InitReflectParseP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_InitReflectParse(
            cx: *mut root::JSContext,
            global: root::JS::HandleObject,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Add various profiling-related functions as properties of the given object."]
        #[doc = " Defined in builtin/Profilers.cpp."]
        #[link_name = "\u{1}_Z27JS_DefineProfilingFunctionsP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_DefineProfilingFunctions(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_DefineDebuggerObjectP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_DefineDebuggerObject(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
        ) -> bool;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSMallocAllocPolicy {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_JSMallocAllocPolicy() {
        assert_eq!(
            ::std::mem::size_of::<JSMallocAllocPolicy>(),
            1usize,
            concat!("Size of: ", stringify!(JSMallocAllocPolicy))
        );
        assert_eq!(
            ::std::mem::align_of::<JSMallocAllocPolicy>(),
            1usize,
            concat!("Alignment of ", stringify!(JSMallocAllocPolicy))
        );
    }
    extern "C" {
        #[doc = " Set the size of the native stack that should not be exceed. To disable"]
        #[doc = " stack size checking pass 0."]
        #[doc = ""]
        #[doc = " SpiderMonkey allows for a distinction between system code (such as GCs, which"]
        #[doc = " may incidentally be triggered by script but are not strictly performed on"]
        #[doc = " behalf of such script), trusted script (as determined by"]
        #[doc = " JS_SetTrustedPrincipals), and untrusted script. Each kind of code may have a"]
        #[doc = " different stack quota, allowing embedders to keep higher-priority machinery"]
        #[doc = " running in the face of scripted stack exhaustion by something else."]
        #[doc = ""]
        #[doc = " The stack quotas for each kind of code should be monotonically descending,"]
        #[doc = " and may be specified with this function. If 0 is passed for a given kind"]
        #[doc = " of code, it defaults to the value of the next-highest-priority kind."]
        #[doc = ""]
        #[doc = " This function may only be called immediately after the runtime is initialized"]
        #[doc = " and before any code is executed and/or interrupts requested."]
        #[link_name = "\u{1}_Z22JS_SetNativeStackQuotaP9JSContextmmm"]
        pub fn JS_SetNativeStackQuota(
            cx: *mut root::JSContext,
            systemCodeStackSize: usize,
            trustedScriptStackSize: usize,
            untrustedScriptStackSize: usize,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z12JS_ValueToIdP9JSContextN2JS6HandleINS1_5ValueEEENS1_13MutableHandleINS1_11PropertyKeyEEE"]
        pub fn JS_ValueToId(
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
            idp: root::JS::MutableHandleId,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_StringToIdP9JSContextN2JS6HandleIP8JSStringEENS1_13MutableHandleINS1_11PropertyKeyEEE"]
        pub fn JS_StringToId(
            cx: *mut root::JSContext,
            s: root::JS::HandleString,
            idp: root::JS::MutableHandleId,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z12JS_IdToValueP9JSContextN2JS11PropertyKeyENS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_IdToValue(
            cx: *mut root::JSContext,
            id: root::jsid,
            vp: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSConstScalarSpec<T> {
        pub name: *const ::std::os::raw::c_char,
        pub val: T,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    extern "C" {
        #[link_name = "\u{1}_Z12JS_InitClassP9JSContextN2JS6HandleIP8JSObjectEES5_PK7JSClassPFbS0_jPNS1_5ValueEEjPK14JSPropertySpecPK14JSFunctionSpecSF_SI_"]
        pub fn JS_InitClass(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            parent_proto: root::JS::HandleObject,
            clasp: *const root::JSClass,
            constructor: root::JSNative,
            nargs: ::std::os::raw::c_uint,
            ps: *const root::JSPropertySpec,
            fs: *const root::JSFunctionSpec,
            static_ps: *const root::JSPropertySpec,
            static_fs: *const root::JSFunctionSpec,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " Set up ctor.prototype = proto and proto.constructor = ctor with the"]
        #[doc = " right property flags."]
        #[link_name = "\u{1}_Z30JS_LinkConstructorAndPrototypeP9JSContextN2JS6HandleIP8JSObjectEES5_"]
        pub fn JS_LinkConstructorAndPrototype(
            cx: *mut root::JSContext,
            ctor: root::JS::Handle<*mut root::JSObject>,
            proto: root::JS::Handle<*mut root::JSObject>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z11JS_GetClassP8JSObject"]
        pub fn JS_GetClass(obj: *mut root::JSObject) -> *const root::JSClass;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_InstanceOfP9JSContextN2JS6HandleIP8JSObjectEEPK7JSClassPNS1_8CallArgsE"]
        pub fn JS_InstanceOf(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            clasp: *const root::JSClass,
            args: *mut root::JS::CallArgs,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z14JS_HasInstanceP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_5ValueEEEPb"]
        pub fn JS_HasInstance(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            v: root::JS::Handle<root::JS::Value>,
            bp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_GetPrivateP8JSObject"]
        pub fn JS_GetPrivate(obj: *mut root::JSObject) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_SetPrivateP8JSObjectPv"]
        pub fn JS_SetPrivate(obj: *mut root::JSObject, data: *mut ::std::os::raw::c_void);
    }
    extern "C" {
        #[link_name = "\u{1}_Z14JS_InitPrivateP8JSObjectPvmN2JS9MemoryUseE"]
        pub fn JS_InitPrivate(
            obj: *mut root::JSObject,
            data: *mut ::std::os::raw::c_void,
            nbytes: usize,
            use_: root::JS::MemoryUse,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_GetInstancePrivateP9JSContextN2JS6HandleIP8JSObjectEEPK7JSClassPNS1_8CallArgsE"]
        pub fn JS_GetInstancePrivate(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            clasp: *const root::JSClass,
            args: *mut root::JS::CallArgs,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_GetConstructorP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_GetConstructor(
            cx: *mut root::JSContext,
            proto: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_NewGlobalObjectP9JSContextPK7JSClassP12JSPrincipalsN2JS21OnNewGlobalHookOptionERKNS6_12RealmOptionsE"]
        pub fn JS_NewGlobalObject(
            cx: *mut root::JSContext,
            clasp: *const root::JSClass,
            principals: *mut root::JSPrincipals,
            hookOption: root::JS::OnNewGlobalHookOption,
            options: *const root::JS::RealmOptions,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " Spidermonkey does not have a good way of keeping track of what compartments"]
        #[doc = " should be marked on their own. We can mark the roots unconditionally, but"]
        #[doc = " marking GC things only relevant in live compartments is hard. To mitigate"]
        #[doc = " this, we create a static trace hook, installed on each global object, from"]
        #[doc = " which we can be sure the compartment is relevant, and mark it."]
        #[doc = ""]
        #[doc = " It is still possible to specify custom trace hooks for global object classes."]
        #[doc = " They can be provided via the RealmOptions passed to JS_NewGlobalObject."]
        #[link_name = "\u{1}_Z24JS_GlobalObjectTraceHookP8JSTracerP8JSObject"]
        pub fn JS_GlobalObjectTraceHook(trc: *mut root::JSTracer, global: *mut root::JSObject);
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_FireOnNewGlobalObjectP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_FireOnNewGlobalObject(cx: *mut root::JSContext, global: root::JS::HandleObject);
    }
    extern "C" {
        #[link_name = "\u{1}_Z12JS_NewObjectP9JSContextPK7JSClass"]
        pub fn JS_NewObject(
            cx: *mut root::JSContext,
            clasp: *const root::JSClass,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z11JS_IsNativeP8JSObject"]
        pub fn JS_IsNative(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[doc = " Unlike JS_NewObject, JS_NewObjectWithGivenProto does not compute a default"]
        #[doc = " proto. If proto is nullptr, the JS object will have `null` as [[Prototype]]."]
        #[link_name = "\u{1}_Z26JS_NewObjectWithGivenProtoP9JSContextPK7JSClassN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewObjectWithGivenProto(
            cx: *mut root::JSContext,
            clasp: *const root::JSClass,
            proto: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " Creates a new plain object, like `new Object()`, with Object.prototype as"]
        #[doc = " [[Prototype]]."]
        #[link_name = "\u{1}_Z17JS_NewPlainObjectP9JSContext"]
        pub fn JS_NewPlainObject(cx: *mut root::JSContext) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " Freeze obj, and all objects it refers to, recursively. This will not recurse"]
        #[doc = " through non-extensible objects, on the assumption that those are already"]
        #[doc = " deep-frozen."]
        #[link_name = "\u{1}_Z19JS_DeepFreezeObjectP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_DeepFreezeObject(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Freezes an object; see ES5's Object.freeze(obj) method."]
        #[link_name = "\u{1}_Z15JS_FreezeObjectP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_FreezeObject(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Get the prototype of obj, storing it in result."]
        #[doc = ""]
        #[doc = " Implements: ES6 [[GetPrototypeOf]] internal method."]
        #[link_name = "\u{1}_Z15JS_GetPrototypeP9JSContextN2JS6HandleIP8JSObjectEENS1_13MutableHandleIS4_EE"]
        pub fn JS_GetPrototype(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            result: root::JS::MutableHandleObject,
        ) -> bool;
    }
    extern "C" {
        #[doc = " If |obj| (underneath any functionally-transparent wrapper proxies) has as"]
        #[doc = " its [[GetPrototypeOf]] trap the ordinary [[GetPrototypeOf]] behavior defined"]
        #[doc = " for ordinary objects, set |*isOrdinary = true| and store |obj|'s prototype"]
        #[doc = " in |result|.  Otherwise set |*isOrdinary = false|.  In case of error, both"]
        #[doc = " outparams have unspecified value."]
        #[link_name = "\u{1}_Z25JS_GetPrototypeIfOrdinaryP9JSContextN2JS6HandleIP8JSObjectEEPbNS1_13MutableHandleIS4_EE"]
        pub fn JS_GetPrototypeIfOrdinary(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            isOrdinary: *mut bool,
            result: root::JS::MutableHandleObject,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Change the prototype of obj."]
        #[doc = ""]
        #[doc = " Implements: ES6 [[SetPrototypeOf]] internal method."]
        #[doc = ""]
        #[doc = " In cases where ES6 [[SetPrototypeOf]] returns false without an exception,"]
        #[doc = " JS_SetPrototype throws a TypeError and returns false."]
        #[doc = ""]
        #[doc = " Performance warning: JS_SetPrototype is very bad for performance. It may"]
        #[doc = " cause compiled jit-code to be invalidated. It also causes not only obj but"]
        #[doc = " all other objects in the same \"group\" as obj to be permanently deoptimized."]
        #[doc = " It's better to create the object with the right prototype from the start."]
        #[link_name = "\u{1}_Z15JS_SetPrototypeP9JSContextN2JS6HandleIP8JSObjectEES5_"]
        pub fn JS_SetPrototype(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            proto: root::JS::HandleObject,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Determine whether obj is extensible. Extensible objects can have new"]
        #[doc = " properties defined on them. Inextensible objects can't, and their"]
        #[doc = " [[Prototype]] slot is fixed as well."]
        #[doc = ""]
        #[doc = " Implements: ES6 [[IsExtensible]] internal method."]
        #[link_name = "\u{1}_Z15JS_IsExtensibleP9JSContextN2JS6HandleIP8JSObjectEEPb"]
        pub fn JS_IsExtensible(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            extensible: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Attempt to make |obj| non-extensible."]
        #[doc = ""]
        #[doc = " Not all failures are treated as errors. See the comment on"]
        #[doc = " JS::ObjectOpResult in js/public/Class.h."]
        #[doc = ""]
        #[doc = " Implements: ES6 [[PreventExtensions]] internal method."]
        #[link_name = "\u{1}_Z20JS_PreventExtensionsP9JSContextN2JS6HandleIP8JSObjectEERNS1_14ObjectOpResultE"]
        pub fn JS_PreventExtensions(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Attempt to make the [[Prototype]] of |obj| immutable, such that any attempt"]
        #[doc = " to modify it will fail.  If an error occurs during the attempt, return false"]
        #[doc = " (with a pending exception set, depending upon the nature of the error).  If"]
        #[doc = " no error occurs, return true with |*succeeded| set to indicate whether the"]
        #[doc = " attempt successfully made the [[Prototype]] immutable."]
        #[doc = ""]
        #[doc = " This is a nonstandard internal method."]
        #[link_name = "\u{1}_Z24JS_SetImmutablePrototypeP9JSContextN2JS6HandleIP8JSObjectEEPb"]
        pub fn JS_SetImmutablePrototype(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            succeeded: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Get a description of one of obj's own properties. If no such property exists"]
        #[doc = " on obj, return true with desc.object() set to null."]
        #[doc = ""]
        #[doc = " Implements: ES6 [[GetOwnProperty]] internal method."]
        #[link_name = "\u{1}_Z31JS_GetOwnPropertyDescriptorByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS1_13MutableHandleINS1_18PropertyDescriptorEEE"]
        pub fn JS_GetOwnPropertyDescriptorById(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_GetOwnPropertyDescriptorP9JSContextN2JS6HandleIP8JSObjectEEPKcNS1_13MutableHandleINS1_18PropertyDescriptorEEE"]
        pub fn JS_GetOwnPropertyDescriptor(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const ::std::os::raw::c_char,
            desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z29JS_GetOwnUCPropertyDescriptorP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS1_13MutableHandleINS1_18PropertyDescriptorEEE"]
        pub fn JS_GetOwnUCPropertyDescriptor(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const u16,
            namelen: usize,
            desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Like JS_GetOwnPropertyDescriptorById, but also searches the prototype chain"]
        #[doc = " if no own property is found directly on obj. The object on which the"]
        #[doc = " property is found is returned in desc.object(). If the property is not found"]
        #[doc = " on the prototype chain, this returns true with desc.object() set to null."]
        #[link_name = "\u{1}_Z28JS_GetPropertyDescriptorByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS1_13MutableHandleINS1_18PropertyDescriptorEEE"]
        pub fn JS_GetPropertyDescriptorById(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_GetPropertyDescriptorP9JSContextN2JS6HandleIP8JSObjectEEPKcNS1_13MutableHandleINS1_18PropertyDescriptorEEE"]
        pub fn JS_GetPropertyDescriptor(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const ::std::os::raw::c_char,
            desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_GetUCPropertyDescriptorP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS1_13MutableHandleINS1_18PropertyDescriptorEEE"]
        pub fn JS_GetUCPropertyDescriptor(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const u16,
            namelen: usize,
            desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Define a property on obj."]
        #[doc = ""]
        #[doc = " This function uses JS::ObjectOpResult to indicate conditions that ES6"]
        #[doc = " specifies as non-error failures. This is inconvenient at best, so use this"]
        #[doc = " function only if you are implementing a proxy handler's defineProperty()"]
        #[doc = " method. For all other purposes, use one of the many DefineProperty functions"]
        #[doc = " below that throw an exception in all failure cases."]
        #[doc = ""]
        #[doc = " Implements: ES6 [[DefineOwnProperty]] internal method."]
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS2_INS1_18PropertyDescriptorEEERNS1_14ObjectOpResultE"]
        pub fn JS_DefinePropertyById(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            desc: root::JS::Handle<root::JS::PropertyDescriptor>,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Define a property on obj, throwing a TypeError if the attempt fails."]
        #[doc = " This is the C++ equivalent of `Object.defineProperty(obj, id, desc)`."]
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS2_INS1_18PropertyDescriptorEEE"]
        pub fn JS_DefinePropertyById1(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            desc: root::JS::Handle<root::JS::PropertyDescriptor>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS2_INS1_5ValueEEEj"]
        pub fn JS_DefinePropertyById2(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            value: root::JS::HandleValue,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEPFbS0_jPNS1_5ValueEESB_j"]
        pub fn JS_DefinePropertyById3(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            getter: root::JSNative,
            setter: root::JSNative,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEES5_S5_j"]
        pub fn JS_DefinePropertyById4(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            getter: root::JS::HandleObject,
            setter: root::JS::HandleObject,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEES5_j"]
        pub fn JS_DefinePropertyById5(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            value: root::JS::HandleObject,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS2_IP8JSStringEEj"]
        pub fn JS_DefinePropertyById6(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            value: root::JS::HandleString,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEij"]
        pub fn JS_DefinePropertyById7(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            value: i32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEjj"]
        pub fn JS_DefinePropertyById8(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            value: u32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEdj"]
        pub fn JS_DefinePropertyById9(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            value: f64,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcNS2_INS1_5ValueEEEj"]
        pub fn JS_DefineProperty(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const ::std::os::raw::c_char,
            value: root::JS::HandleValue,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcPFbS0_jPNS1_5ValueEESB_j"]
        pub fn JS_DefineProperty1(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const ::std::os::raw::c_char,
            getter: root::JSNative,
            setter: root::JSNative,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcS5_S5_j"]
        pub fn JS_DefineProperty2(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const ::std::os::raw::c_char,
            getter: root::JS::HandleObject,
            setter: root::JS::HandleObject,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcS5_j"]
        pub fn JS_DefineProperty3(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const ::std::os::raw::c_char,
            value: root::JS::HandleObject,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcNS2_IP8JSStringEEj"]
        pub fn JS_DefineProperty4(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const ::std::os::raw::c_char,
            value: root::JS::HandleString,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcij"]
        pub fn JS_DefineProperty5(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const ::std::os::raw::c_char,
            value: i32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcjj"]
        pub fn JS_DefineProperty6(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const ::std::os::raw::c_char,
            value: u32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcdj"]
        pub fn JS_DefineProperty7(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const ::std::os::raw::c_char,
            value: f64,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS2_INS1_18PropertyDescriptorEEERNS1_14ObjectOpResultE"]
        pub fn JS_DefineUCProperty(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const u16,
            namelen: usize,
            desc: root::JS::Handle<root::JS::PropertyDescriptor>,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS2_INS1_18PropertyDescriptorEEE"]
        pub fn JS_DefineUCProperty1(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const u16,
            namelen: usize,
            desc: root::JS::Handle<root::JS::PropertyDescriptor>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS2_INS1_5ValueEEEj"]
        pub fn JS_DefineUCProperty2(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const u16,
            namelen: usize,
            value: root::JS::HandleValue,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmS5_S5_j"]
        pub fn JS_DefineUCProperty3(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const u16,
            namelen: usize,
            getter: root::JS::HandleObject,
            setter: root::JS::HandleObject,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmS5_j"]
        pub fn JS_DefineUCProperty4(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const u16,
            namelen: usize,
            value: root::JS::HandleObject,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS2_IP8JSStringEEj"]
        pub fn JS_DefineUCProperty5(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const u16,
            namelen: usize,
            value: root::JS::HandleString,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmij"]
        pub fn JS_DefineUCProperty6(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const u16,
            namelen: usize,
            value: i32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmjj"]
        pub fn JS_DefineUCProperty7(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const u16,
            namelen: usize,
            value: u32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmdj"]
        pub fn JS_DefineUCProperty8(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const u16,
            namelen: usize,
            value: f64,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjNS2_INS1_5ValueEEEj"]
        pub fn JS_DefineElement(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            index: u32,
            value: root::JS::HandleValue,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjS5_S5_j"]
        pub fn JS_DefineElement1(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            index: u32,
            getter: root::JS::HandleObject,
            setter: root::JS::HandleObject,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjS5_j"]
        pub fn JS_DefineElement2(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            index: u32,
            value: root::JS::HandleObject,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjNS2_IP8JSStringEEj"]
        pub fn JS_DefineElement3(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            index: u32,
            value: root::JS::HandleString,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjij"]
        pub fn JS_DefineElement4(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            index: u32,
            value: i32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjjj"]
        pub fn JS_DefineElement5(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            index: u32,
            value: u32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjdj"]
        pub fn JS_DefineElement6(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            index: u32,
            value: f64,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Compute the expression `id in obj`."]
        #[doc = ""]
        #[doc = " If obj has an own or inherited property obj[id], set *foundp = true and"]
        #[doc = " return true. If not, set *foundp = false and return true. On error, return"]
        #[doc = " false with an exception pending."]
        #[doc = ""]
        #[doc = " Implements: ES6 [[Has]] internal method."]
        #[link_name = "\u{1}_Z18JS_HasPropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEPb"]
        pub fn JS_HasPropertyById(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            foundp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z14JS_HasPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcPb"]
        pub fn JS_HasProperty(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const ::std::os::raw::c_char,
            foundp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_HasUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmPb"]
        pub fn JS_HasUCProperty(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const u16,
            namelen: usize,
            vp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_HasElementP9JSContextN2JS6HandleIP8JSObjectEEjPb"]
        pub fn JS_HasElement(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            index: u32,
            foundp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Determine whether obj has an own property with the key `id`."]
        #[doc = ""]
        #[doc = " Implements: ES6 7.3.11 HasOwnProperty(O, P)."]
        #[link_name = "\u{1}_Z21JS_HasOwnPropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEPb"]
        pub fn JS_HasOwnPropertyById(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            foundp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_HasOwnPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcPb"]
        pub fn JS_HasOwnProperty(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const ::std::os::raw::c_char,
            foundp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Get the value of the property `obj[id]`, or undefined if no such property"]
        #[doc = " exists. This is the C++ equivalent of `vp = Reflect.get(obj, id, receiver)`."]
        #[doc = ""]
        #[doc = " Most callers don't need the `receiver` argument. Consider using"]
        #[doc = " JS_GetProperty instead. (But if you're implementing a proxy handler's set()"]
        #[doc = " method, it's often correct to call this function and pass the receiver"]
        #[doc = " through.)"]
        #[doc = ""]
        #[doc = " Implements: ES6 [[Get]] internal method."]
        #[link_name = "\u{1}_Z23JS_ForwardGetPropertyToP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS2_INS1_5ValueEEENS1_13MutableHandleIS8_EE"]
        pub fn JS_ForwardGetPropertyTo(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            receiver: root::JS::HandleValue,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_ForwardGetElementToP9JSContextN2JS6HandleIP8JSObjectEEjS5_NS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_ForwardGetElementTo(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            index: u32,
            receiver: root::JS::HandleObject,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Get the value of the property `obj[id]`, or undefined if no such property"]
        #[doc = " exists. The result is stored in vp."]
        #[doc = ""]
        #[doc = " Implements: ES6 7.3.1 Get(O, P)."]
        #[link_name = "\u{1}_Z18JS_GetPropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_GetPropertyById(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z14JS_GetPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcNS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_GetProperty(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const ::std::os::raw::c_char,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_GetUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_GetUCProperty(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const u16,
            namelen: usize,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_GetElementP9JSContextN2JS6HandleIP8JSObjectEEjNS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_GetElement(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            index: u32,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Perform the same property assignment as `Reflect.set(obj, id, v, receiver)`."]
        #[doc = ""]
        #[doc = " This function has a `receiver` argument that most callers don't need."]
        #[doc = " Consider using JS_SetProperty instead."]
        #[doc = ""]
        #[doc = " Implements: ES6 [[Set]] internal method."]
        #[link_name = "\u{1}_Z23JS_ForwardSetPropertyToP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS2_INS1_5ValueEEES9_RNS1_14ObjectOpResultE"]
        pub fn JS_ForwardSetPropertyTo(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            v: root::JS::HandleValue,
            receiver: root::JS::HandleValue,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Perform the assignment `obj[id] = v`."]
        #[doc = ""]
        #[doc = " This function performs non-strict assignment, so if the property is"]
        #[doc = " read-only, nothing happens and no error is thrown."]
        #[link_name = "\u{1}_Z18JS_SetPropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS2_INS1_5ValueEEE"]
        pub fn JS_SetPropertyById(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            v: root::JS::HandleValue,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z14JS_SetPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcNS2_INS1_5ValueEEE"]
        pub fn JS_SetProperty(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const ::std::os::raw::c_char,
            v: root::JS::HandleValue,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_SetUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS2_INS1_5ValueEEE"]
        pub fn JS_SetUCProperty(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const u16,
            namelen: usize,
            v: root::JS::HandleValue,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_SetElementP9JSContextN2JS6HandleIP8JSObjectEEjNS2_INS1_5ValueEEE"]
        pub fn JS_SetElement(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            index: u32,
            v: root::JS::HandleValue,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_SetElementP9JSContextN2JS6HandleIP8JSObjectEEjS5_"]
        pub fn JS_SetElement1(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            index: u32,
            v: root::JS::HandleObject,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_SetElementP9JSContextN2JS6HandleIP8JSObjectEEjNS2_IP8JSStringEE"]
        pub fn JS_SetElement2(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            index: u32,
            v: root::JS::HandleString,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_SetElementP9JSContextN2JS6HandleIP8JSObjectEEji"]
        pub fn JS_SetElement3(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            index: u32,
            v: i32,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_SetElementP9JSContextN2JS6HandleIP8JSObjectEEjj"]
        pub fn JS_SetElement4(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            index: u32,
            v: u32,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_SetElementP9JSContextN2JS6HandleIP8JSObjectEEjd"]
        pub fn JS_SetElement5(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            index: u32,
            v: f64,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Delete a property. This is the C++ equivalent of"]
        #[doc = " `result = Reflect.deleteProperty(obj, id)`."]
        #[doc = ""]
        #[doc = " This function has a `result` out parameter that most callers don't need."]
        #[doc = " Unless you can pass through an ObjectOpResult provided by your caller, it's"]
        #[doc = " probably best to use the JS_DeletePropertyById signature with just 3"]
        #[doc = " arguments."]
        #[doc = ""]
        #[doc = " Implements: ES6 [[Delete]] internal method."]
        #[link_name = "\u{1}_Z21JS_DeletePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEERNS1_14ObjectOpResultE"]
        pub fn JS_DeletePropertyById(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DeletePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcRNS1_14ObjectOpResultE"]
        pub fn JS_DeleteProperty(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const ::std::os::raw::c_char,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DeleteUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmRNS1_14ObjectOpResultE"]
        pub fn JS_DeleteUCProperty(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const u16,
            namelen: usize,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_DeleteElementP9JSContextN2JS6HandleIP8JSObjectEEjRNS1_14ObjectOpResultE"]
        pub fn JS_DeleteElement(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            index: u32,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Delete a property, ignoring strict failures. This is the C++ equivalent of"]
        #[doc = " the JS `delete obj[id]` in non-strict mode code."]
        #[link_name = "\u{1}_Z21JS_DeletePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS1_11PropertyKeyE"]
        pub fn JS_DeletePropertyById1(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::jsid,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DeletePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKc"]
        pub fn JS_DeleteProperty1(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const ::std::os::raw::c_char,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_DeleteElementP9JSContextN2JS6HandleIP8JSObjectEEj"]
        pub fn JS_DeleteElement1(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            index: u32,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Get an array of the non-symbol enumerable properties of obj."]
        #[doc = " This function is roughly equivalent to:"]
        #[doc = ""]
        #[doc = "     var result = [];"]
        #[doc = "     for (key in obj) {"]
        #[doc = "         result.push(key);"]
        #[doc = "     }"]
        #[doc = "     return result;"]
        #[doc = ""]
        #[doc = " This is the closest thing we currently have to the ES6 [[Enumerate]]"]
        #[doc = " internal method."]
        #[doc = ""]
        #[doc = " The array of ids returned by JS_Enumerate must be rooted to protect its"]
        #[doc = " contents from garbage collection. Use JS::Rooted<JS::IdVector>."]
        #[link_name = "\u{1}_Z12JS_EnumerateP9JSContextN2JS6HandleIP8JSObjectEENS1_13MutableHandleINS1_8GCVectorINS1_11PropertyKeyELm0EN2js15TempAllocPolicyEEEEE"]
        pub fn JS_Enumerate(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            props: root::JS::MutableHandle<root::JS::IdVector>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Equivalent to `Object.assign(target, src)`: Copies the properties from the"]
        #[doc = " `src` object (which must not be null) to `target` (which also must not be"]
        #[doc = " null)."]
        #[link_name = "\u{1}_Z15JS_AssignObjectP9JSContextN2JS6HandleIP8JSObjectEES5_"]
        pub fn JS_AssignObject(
            cx: *mut root::JSContext,
            target: root::JS::HandleObject,
            src: root::JS::HandleObject,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Call a function, passing a this-value and arguments. This is the C++"]
        #[doc = " equivalent of `rval = Reflect.apply(fun, obj, args)`."]
        #[doc = ""]
        #[doc = " Implements: ES6 7.3.12 Call(F, V, [argumentsList])."]
        #[doc = " Use this function to invoke the [[Call]] internal method."]
        #[link_name = "\u{1}_Z20JS_CallFunctionValueP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_5ValueEEERKNS1_16HandleValueArrayENS1_13MutableHandleIS6_EE"]
        pub fn JS_CallFunctionValue(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            fval: root::JS::HandleValue,
            args: *const root::JS::HandleValueArray,
            rval: root::JS::MutableHandleValue,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z15JS_CallFunctionP9JSContextN2JS6HandleIP8JSObjectEENS2_IP10JSFunctionEERKNS1_16HandleValueArrayENS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_CallFunction(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            fun: root::JS::HandleFunction,
            args: *const root::JS::HandleValueArray,
            rval: root::JS::MutableHandleValue,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Perform the method call `rval = obj[name](args)`."]
        #[link_name = "\u{1}_Z19JS_CallFunctionNameP9JSContextN2JS6HandleIP8JSObjectEEPKcRKNS1_16HandleValueArrayENS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_CallFunctionName(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const ::std::os::raw::c_char,
            args: *const root::JS::HandleValueArray,
            rval: root::JS::MutableHandleValue,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Invoke a constructor, like the JS expression `new ctor(...args)`. Returns"]
        #[doc = " the new object, or null on error."]
        #[link_name = "\u{1}_Z6JS_NewP9JSContextN2JS6HandleIP8JSObjectEERKNS1_16HandleValueArrayE"]
        pub fn JS_New(
            cx: *mut root::JSContext,
            ctor: root::JS::HandleObject,
            args: *const root::JS::HandleValueArray,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " Other property-defining functions"]
        #[link_name = "\u{1}_Z15JS_DefineObjectP9JSContextN2JS6HandleIP8JSObjectEEPKcPK7JSClassj"]
        pub fn JS_DefineObject(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const ::std::os::raw::c_char,
            clasp: *const root::JSClass,
            attrs: ::std::os::raw::c_uint,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_DefineConstDoublesP9JSContextN2JS6HandleIP8JSObjectEEPK17JSConstScalarSpecIdE"]
        pub fn JS_DefineConstDoubles(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            cds: *const root::JSConstDoubleSpec,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_DefineConstIntegersP9JSContextN2JS6HandleIP8JSObjectEEPK17JSConstScalarSpecIiE"]
        pub fn JS_DefineConstIntegers(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            cis: *const root::JSConstIntegerSpec,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefinePropertiesP9JSContextN2JS6HandleIP8JSObjectEEPK14JSPropertySpec"]
        pub fn JS_DefineProperties(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            ps: *const root::JSPropertySpec,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z28JS_AlreadyHasOwnPropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEPb"]
        pub fn JS_AlreadyHasOwnPropertyById(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            foundp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_AlreadyHasOwnPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcPb"]
        pub fn JS_AlreadyHasOwnProperty(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const ::std::os::raw::c_char,
            foundp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_AlreadyHasOwnUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmPb"]
        pub fn JS_AlreadyHasOwnUCProperty(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            name: *const u16,
            namelen: usize,
            foundp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_AlreadyHasOwnElementP9JSContextN2JS6HandleIP8JSObjectEEjPb"]
        pub fn JS_AlreadyHasOwnElement(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            index: u32,
            foundp: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_NewArrayObjectP9JSContextRKN2JS16HandleValueArrayE"]
        pub fn JS_NewArrayObject(
            cx: *mut root::JSContext,
            contents: *const root::JS::HandleValueArray,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_NewArrayObjectP9JSContextm"]
        pub fn JS_NewArrayObject1(cx: *mut root::JSContext, length: usize) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " On success, returns true, setting |*isArray| to true if |value| is an Array"]
        #[doc = " object or a wrapper around one, or to false if not.  Returns false on"]
        #[doc = " failure."]
        #[doc = ""]
        #[doc = " This method returns true with |*isArray == false| when passed an ES6 proxy"]
        #[doc = " whose target is an Array, or when passed a revoked proxy."]
        #[link_name = "\u{1}_Z16JS_IsArrayObjectP9JSContextN2JS6HandleINS1_5ValueEEEPb"]
        pub fn JS_IsArrayObject(
            cx: *mut root::JSContext,
            value: root::JS::HandleValue,
            isArray: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[doc = " On success, returns true, setting |*isArray| to true if |obj| is an Array"]
        #[doc = " object or a wrapper around one, or to false if not.  Returns false on"]
        #[doc = " failure."]
        #[doc = ""]
        #[doc = " This method returns true with |*isArray == false| when passed an ES6 proxy"]
        #[doc = " whose target is an Array, or when passed a revoked proxy."]
        #[link_name = "\u{1}_Z16JS_IsArrayObjectP9JSContextN2JS6HandleIP8JSObjectEEPb"]
        pub fn JS_IsArrayObject1(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            isArray: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_GetArrayLengthP9JSContextN2JS6HandleIP8JSObjectEEPj"]
        pub fn JS_GetArrayLength(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            lengthp: *mut u32,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_SetArrayLengthP9JSContextN2JS6HandleIP8JSObjectEEj"]
        pub fn JS_SetArrayLength(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            length: u32,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Assign 'undefined' to all of the object's non-reserved slots. Note: this is"]
        #[doc = " done for all slots, regardless of the associated property descriptor."]
        #[link_name = "\u{1}_Z36JS_SetAllNonReservedSlotsToUndefinedN2JS6HandleIP8JSObjectEE"]
        pub fn JS_SetAllNonReservedSlotsToUndefined(obj: root::JS::HandleObject);
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_GetReservedSlotP8JSObjectj"]
        pub fn JS_GetReservedSlot(obj: *mut root::JSObject, index: u32) -> root::JS::Value;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_SetReservedSlotP8JSObjectjRKN2JS5ValueE"]
        pub fn JS_SetReservedSlot(obj: *mut root::JSObject, index: u32, v: *const root::JS::Value);
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_InitReservedSlotP8JSObjectjPvmN2JS9MemoryUseE"]
        pub fn JS_InitReservedSlot(
            obj: *mut root::JSObject,
            index: u32,
            ptr: *mut ::std::os::raw::c_void,
            nbytes: usize,
            use_: root::JS::MemoryUse,
        );
    }
    pub const JSFUN_CONSTRUCTOR: ::std::os::raw::c_uint = 1024;
    pub const JSFUN_FLAGS_MASK: ::std::os::raw::c_uint = 1024;
    extern "C" {
        #[link_name = "\u{1}_Z14JS_NewFunctionP9JSContextPFbS0_jPN2JS5ValueEEjjPKc"]
        pub fn JS_NewFunction(
            cx: *mut root::JSContext,
            call: root::JSNative,
            nargs: ::std::os::raw::c_uint,
            flags: ::std::os::raw::c_uint,
            name: *const ::std::os::raw::c_char,
        ) -> *mut root::JSFunction;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_GetFunctionObjectP10JSFunction"]
        pub fn JS_GetFunctionObject(fun: *mut root::JSFunction) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " Return the function's identifier as a JSString, or null if fun is unnamed."]
        #[doc = " The returned string lives as long as fun, so you don't need to root a saved"]
        #[doc = " reference to it if fun is well-connected or rooted, and provided you bound"]
        #[doc = " the use of the saved reference by fun's lifetime."]
        #[link_name = "\u{1}_Z16JS_GetFunctionIdP10JSFunction"]
        pub fn JS_GetFunctionId(fun: *mut root::JSFunction) -> *mut root::JSString;
    }
    extern "C" {
        #[doc = " Return a function's display name. This is the defined name if one was given"]
        #[doc = " where the function was defined, or it could be an inferred name by the JS"]
        #[doc = " engine in the case that the function was defined to be anonymous. This can"]
        #[doc = " still return nullptr if a useful display name could not be inferred. The"]
        #[doc = " same restrictions on rooting as those in JS_GetFunctionId apply."]
        #[link_name = "\u{1}_Z23JS_GetFunctionDisplayIdP10JSFunction"]
        pub fn JS_GetFunctionDisplayId(fun: *mut root::JSFunction) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_GetFunctionArityP10JSFunction"]
        pub fn JS_GetFunctionArity(fun: *mut root::JSFunction) -> u16;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_GetFunctionLengthP9JSContextN2JS6HandleIP10JSFunctionEEPt"]
        pub fn JS_GetFunctionLength(
            cx: *mut root::JSContext,
            fun: root::JS::HandleFunction,
            length: *mut u16,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Infallible predicate to test whether obj is a function object (faster than"]
        #[doc = " comparing obj's class name to \"Function\", but equivalent unless someone has"]
        #[doc = " overwritten the \"Function\" identifier with a different constructor and then"]
        #[doc = " created instances using that constructor that might be passed in as obj)."]
        #[link_name = "\u{1}_Z19JS_ObjectIsFunctionP8JSObject"]
        pub fn JS_ObjectIsFunction(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_IsNativeFunctionP8JSObjectPFbP9JSContextjPN2JS5ValueEE"]
        pub fn JS_IsNativeFunction(funobj: *mut root::JSObject, call: root::JSNative) -> bool;
    }
    extern "C" {
        #[doc = " Return whether the given function is a valid constructor."]
        #[link_name = "\u{1}_Z16JS_IsConstructorP10JSFunction"]
        pub fn JS_IsConstructor(fun: *mut root::JSFunction) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_DefineFunctionsP9JSContextN2JS6HandleIP8JSObjectEEPK14JSFunctionSpec"]
        pub fn JS_DefineFunctions(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            fs: *const root::JSFunctionSpec,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_DefineFunctionP9JSContextN2JS6HandleIP8JSObjectEEPKcPFbS0_jPNS1_5ValueEEjj"]
        pub fn JS_DefineFunction(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            call: root::JSNative,
            nargs: ::std::os::raw::c_uint,
            attrs: ::std::os::raw::c_uint,
        ) -> *mut root::JSFunction;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_DefineUCFunctionP9JSContextN2JS6HandleIP8JSObjectEEPKDsmPFbS0_jPNS1_5ValueEEjj"]
        pub fn JS_DefineUCFunction(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            call: root::JSNative,
            nargs: ::std::os::raw::c_uint,
            attrs: ::std::os::raw::c_uint,
        ) -> *mut root::JSFunction;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_DefineFunctionByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEPFbS0_jPNS1_5ValueEEjj"]
        pub fn JS_DefineFunctionById(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            call: root::JSNative,
            nargs: ::std::os::raw::c_uint,
            attrs: ::std::os::raw::c_uint,
        ) -> *mut root::JSFunction;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_IsFunctionBoundP10JSFunction"]
        pub fn JS_IsFunctionBound(fun: *mut root::JSFunction) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_GetBoundFunctionTargetP10JSFunction"]
        pub fn JS_GetBoundFunctionTarget(fun: *mut root::JSFunction) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_GetGlobalFromScriptP8JSScript"]
        pub fn JS_GetGlobalFromScript(script: *mut root::JSScript) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_GetScriptFilenameP8JSScript"]
        pub fn JS_GetScriptFilename(script: *mut root::JSScript) -> *const ::std::os::raw::c_char;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_GetScriptBaseLineNumberP9JSContextP8JSScript"]
        pub fn JS_GetScriptBaseLineNumber(
            cx: *mut root::JSContext,
            script: *mut root::JSScript,
        ) -> ::std::os::raw::c_uint;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_GetFunctionScriptP9JSContextN2JS6HandleIP10JSFunctionEE"]
        pub fn JS_GetFunctionScript(
            cx: *mut root::JSContext,
            fun: root::JS::HandleFunction,
        ) -> *mut root::JSScript;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_DecompileScriptP9JSContextN2JS6HandleIP8JSScriptEE"]
        pub fn JS_DecompileScript(
            cx: *mut root::JSContext,
            script: root::JS::Handle<*mut root::JSScript>,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_DecompileFunctionP9JSContextN2JS6HandleIP10JSFunctionEE"]
        pub fn JS_DecompileFunction(
            cx: *mut root::JSContext,
            fun: root::JS::Handle<*mut root::JSFunction>,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_CheckForInterruptP9JSContext"]
        pub fn JS_CheckForInterrupt(cx: *mut root::JSContext) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_AddInterruptCallbackP9JSContextPFbS0_E"]
        pub fn JS_AddInterruptCallback(
            cx: *mut root::JSContext,
            callback: root::JSInterruptCallback,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_DisableInterruptCallbackP9JSContext"]
        pub fn JS_DisableInterruptCallback(cx: *mut root::JSContext) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_ResetInterruptCallbackP9JSContextb"]
        pub fn JS_ResetInterruptCallback(cx: *mut root::JSContext, enable: bool);
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_RequestInterruptCallbackP9JSContext"]
        pub fn JS_RequestInterruptCallback(cx: *mut root::JSContext);
    }
    extern "C" {
        #[link_name = "\u{1}_Z34JS_RequestInterruptCallbackCanWaitP9JSContext"]
        pub fn JS_RequestInterruptCallbackCanWait(cx: *mut root::JSContext);
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_NewStringCopyNP9JSContextPKcm"]
        pub fn JS_NewStringCopyN(
            cx: *mut root::JSContext,
            s: *const ::std::os::raw::c_char,
            n: usize,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_NewStringCopyZP9JSContextPKc"]
        pub fn JS_NewStringCopyZ(
            cx: *mut root::JSContext,
            s: *const ::std::os::raw::c_char,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_NewStringCopyUTF8ZP9JSContextN2JS15ConstUTF8CharsZE"]
        pub fn JS_NewStringCopyUTF8Z(
            cx: *mut root::JSContext,
            s: root::JS::ConstUTF8CharsZ,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_NewStringCopyUTF8NP9JSContextN2JS9UTF8CharsE"]
        pub fn JS_NewStringCopyUTF8N(
            cx: *mut root::JSContext,
            s: root::JS::UTF8Chars,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_AtomizeAndPinJSStringP9JSContextN2JS6HandleIP8JSStringEE"]
        pub fn JS_AtomizeAndPinJSString(
            cx: *mut root::JSContext,
            str: root::JS::HandleString,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_AtomizeStringNP9JSContextPKcm"]
        pub fn JS_AtomizeStringN(
            cx: *mut root::JSContext,
            s: *const ::std::os::raw::c_char,
            length: usize,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_AtomizeStringP9JSContextPKc"]
        pub fn JS_AtomizeString(
            cx: *mut root::JSContext,
            s: *const ::std::os::raw::c_char,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_AtomizeAndPinStringNP9JSContextPKcm"]
        pub fn JS_AtomizeAndPinStringN(
            cx: *mut root::JSContext,
            s: *const ::std::os::raw::c_char,
            length: usize,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_AtomizeAndPinStringP9JSContextPKc"]
        pub fn JS_AtomizeAndPinString(
            cx: *mut root::JSContext,
            s: *const ::std::os::raw::c_char,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_NewLatin1StringP9JSContextN7mozilla9UniquePtrIA_hN2JS10FreePolicyEEEm"]
        pub fn JS_NewLatin1String(
            cx: *mut root::JSContext,
            chars: u8,
            length: usize,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z14JS_NewUCStringP9JSContextN7mozilla9UniquePtrIA_DsN2JS10FreePolicyEEEm"]
        pub fn JS_NewUCString(
            cx: *mut root::JSContext,
            chars: root::JS::UniqueTwoByteChars,
            length: usize,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_NewUCStringDontDeflateP9JSContextN7mozilla9UniquePtrIA_DsN2JS10FreePolicyEEEm"]
        pub fn JS_NewUCStringDontDeflate(
            cx: *mut root::JSContext,
            chars: root::JS::UniqueTwoByteChars,
            length: usize,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_NewUCStringCopyNP9JSContextPKDsm"]
        pub fn JS_NewUCStringCopyN(
            cx: *mut root::JSContext,
            s: *const u16,
            n: usize,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_NewUCStringCopyZP9JSContextPKDs"]
        pub fn JS_NewUCStringCopyZ(cx: *mut root::JSContext, s: *const u16) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_AtomizeUCStringNP9JSContextPKDsm"]
        pub fn JS_AtomizeUCStringN(
            cx: *mut root::JSContext,
            s: *const u16,
            length: usize,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_AtomizeUCStringP9JSContextPKDs"]
        pub fn JS_AtomizeUCString(cx: *mut root::JSContext, s: *const u16) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_AtomizeAndPinUCStringNP9JSContextPKDsm"]
        pub fn JS_AtomizeAndPinUCStringN(
            cx: *mut root::JSContext,
            s: *const u16,
            length: usize,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_AtomizeAndPinUCStringP9JSContextPKDs"]
        pub fn JS_AtomizeAndPinUCString(
            cx: *mut root::JSContext,
            s: *const u16,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_CompareStringsP9JSContextP8JSStringS2_Pi"]
        pub fn JS_CompareStrings(
            cx: *mut root::JSContext,
            str1: *mut root::JSString,
            str2: *mut root::JSString,
            result: *mut i32,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_StringEqualsAsciiP9JSContextP8JSStringPKcPb"]
        pub fn JS_StringEqualsAscii(
            cx: *mut root::JSContext,
            str: *mut root::JSString,
            asciiBytes: *const ::std::os::raw::c_char,
            match_: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_StringEqualsAsciiP9JSContextP8JSStringPKcmPb"]
        pub fn JS_StringEqualsAscii1(
            cx: *mut root::JSContext,
            str: *mut root::JSString,
            asciiBytes: *const ::std::os::raw::c_char,
            length: usize,
            match_: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_PutEscapedStringP9JSContextPcmP8JSStringc"]
        pub fn JS_PutEscapedString(
            cx: *mut root::JSContext,
            buffer: *mut ::std::os::raw::c_char,
            size: usize,
            str: *mut root::JSString,
            quote: ::std::os::raw::c_char,
        ) -> usize;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_GetStringLengthP8JSString"]
        pub fn JS_GetStringLength(str: *mut root::JSString) -> usize;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_StringIsLinearP8JSString"]
        pub fn JS_StringIsLinear(str: *mut root::JSString) -> bool;
    }
    extern "C" {
        #[doc = " Returns true iff the string's characters are stored as Latin1."]
        #[link_name = "\u{1}_Z23JS_StringHasLatin1CharsP8JSString"]
        pub fn JS_StringHasLatin1Chars(str: *mut root::JSString) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z32JS_GetLatin1StringCharsAndLengthP9JSContextRKN2JS15AutoRequireNoGCEP8JSStringPm"]
        pub fn JS_GetLatin1StringCharsAndLength(
            cx: *mut root::JSContext,
            nogc: *const root::JS::AutoRequireNoGC,
            str: *mut root::JSString,
            length: *mut usize,
        ) -> *const root::JS::Latin1Char;
    }
    extern "C" {
        #[link_name = "\u{1}_Z33JS_GetTwoByteStringCharsAndLengthP9JSContextRKN2JS15AutoRequireNoGCEP8JSStringPm"]
        pub fn JS_GetTwoByteStringCharsAndLength(
            cx: *mut root::JSContext,
            nogc: *const root::JS::AutoRequireNoGC,
            str: *mut root::JSString,
            length: *mut usize,
        ) -> *const u16;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_GetStringCharAtP9JSContextP8JSStringmPDs"]
        pub fn JS_GetStringCharAt(
            cx: *mut root::JSContext,
            str: *mut root::JSString,
            index: usize,
            res: *mut u16,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_GetLinearStringCharAtP14JSLinearStringm"]
        pub fn JS_GetLinearStringCharAt(str: *mut root::JSLinearString, index: usize) -> u16;
    }
    extern "C" {
        #[link_name = "\u{1}_Z32JS_GetTwoByteExternalStringCharsP8JSString"]
        pub fn JS_GetTwoByteExternalStringChars(str: *mut root::JSString) -> *const u16;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_CopyStringCharsP9JSContextN7mozilla5RangeIDsEEP8JSString"]
        pub fn JS_CopyStringChars(
            cx: *mut root::JSContext,
            dest: root::mozilla::Range<u16>,
            str: *mut root::JSString,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Copies the string's characters to a null-terminated char16_t buffer."]
        #[doc = ""]
        #[doc = " Returns nullptr on OOM."]
        #[link_name = "\u{1}_Z19JS_CopyStringCharsZP9JSContextP8JSString"]
        pub fn JS_CopyStringCharsZ(
            cx: *mut root::JSContext,
            str: *mut root::JSString,
        ) -> root::JS::UniqueTwoByteChars;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_EnsureLinearStringP9JSContextP8JSString"]
        pub fn JS_EnsureLinearString(
            cx: *mut root::JSContext,
            str: *mut root::JSString,
        ) -> *mut root::JSLinearString;
    }
    extern "C" {
        #[link_name = "\u{1}_Z29JS_GetLatin1LinearStringCharsRKN2JS15AutoRequireNoGCEP14JSLinearString"]
        pub fn JS_GetLatin1LinearStringChars(
            nogc: *const root::JS::AutoRequireNoGC,
            str: *mut root::JSLinearString,
        ) -> *const root::JS::Latin1Char;
    }
    extern "C" {
        #[link_name = "\u{1}_Z30JS_GetTwoByteLinearStringCharsRKN2JS15AutoRequireNoGCEP14JSLinearString"]
        pub fn JS_GetTwoByteLinearStringChars(
            nogc: *const root::JS::AutoRequireNoGC,
            str: *mut root::JSLinearString,
        ) -> *const u16;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_LinearStringEqualsAsciiP14JSLinearStringPKc"]
        pub fn JS_LinearStringEqualsAscii(
            str: *mut root::JSLinearString,
            asciiBytes: *const ::std::os::raw::c_char,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_LinearStringEqualsAsciiP14JSLinearStringPKcm"]
        pub fn JS_LinearStringEqualsAscii1(
            str: *mut root::JSLinearString,
            asciiBytes: *const ::std::os::raw::c_char,
            length: usize,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_PutEscapedLinearStringPcmP14JSLinearStringc"]
        pub fn JS_PutEscapedLinearString(
            buffer: *mut ::std::os::raw::c_char,
            size: usize,
            str: *mut root::JSLinearString,
            quote: ::std::os::raw::c_char,
        ) -> usize;
    }
    extern "C" {
        #[doc = " Create a dependent string, i.e., a string that owns no character storage,"]
        #[doc = " but that refers to a slice of another string's chars.  Dependent strings"]
        #[doc = " are mutable by definition, so the thread safety comments above apply."]
        #[link_name = "\u{1}_Z21JS_NewDependentStringP9JSContextN2JS6HandleIP8JSStringEEmm"]
        pub fn JS_NewDependentString(
            cx: *mut root::JSContext,
            str: root::JS::HandleString,
            start: usize,
            length: usize,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[doc = " Concatenate two strings, possibly resulting in a rope."]
        #[doc = " See above for thread safety comments."]
        #[link_name = "\u{1}_Z16JS_ConcatStringsP9JSContextN2JS6HandleIP8JSStringEES5_"]
        pub fn JS_ConcatStrings(
            cx: *mut root::JSContext,
            left: root::JS::HandleString,
            right: root::JS::HandleString,
        ) -> *mut root::JSString;
    }
    extern "C" {
        #[doc = " For JS_DecodeBytes, set *dstlenp to the size of the destination buffer before"]
        #[doc = " the call; on return, *dstlenp contains the number of characters actually"]
        #[doc = " stored. To determine the necessary destination buffer size, make a sizing"]
        #[doc = " call that passes nullptr for dst."]
        #[doc = ""]
        #[doc = " On errors, the functions report the error. In that case, *dstlenp contains"]
        #[doc = " the number of characters or bytes transferred so far.  If cx is nullptr, no"]
        #[doc = " error is reported on failure, and the functions simply return false."]
        #[doc = ""]
        #[doc = " NB: This function does not store an additional zero byte or char16_t after"]
        #[doc = " the transcoded string."]
        #[link_name = "\u{1}_Z14JS_DecodeBytesP9JSContextPKcmPDsPm"]
        pub fn JS_DecodeBytes(
            cx: *mut root::JSContext,
            src: *const ::std::os::raw::c_char,
            srclen: usize,
            dst: *mut u16,
            dstlenp: *mut usize,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Get number of bytes in the string encoding (without accounting for a"]
        #[doc = " terminating zero bytes. The function returns (size_t) -1 if the string"]
        #[doc = " can not be encoded into bytes and reports an error using cx accordingly."]
        #[link_name = "\u{1}_Z26JS_GetStringEncodingLengthP9JSContextP8JSString"]
        pub fn JS_GetStringEncodingLength(
            cx: *mut root::JSContext,
            str: *mut root::JSString,
        ) -> usize;
    }
    extern "C" {
        #[doc = " Encode string into a buffer. The function does not stores an additional"]
        #[doc = " zero byte. The function returns (size_t) -1 if the string can not be"]
        #[doc = " encoded into bytes with no error reported. Otherwise it returns the number"]
        #[doc = " of bytes that are necessary to encode the string. If that exceeds the"]
        #[doc = " length parameter, the string will be cut and only length bytes will be"]
        #[doc = " written into the buffer."]
        #[link_name = "\u{1}_Z23JS_EncodeStringToBufferP9JSContextP8JSStringPcm"]
        pub fn JS_EncodeStringToBuffer(
            cx: *mut root::JSContext,
            str: *mut root::JSString,
            buffer: *mut ::std::os::raw::c_char,
            length: usize,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Encode as many scalar values of the string as UTF-8 as can fit"]
        #[doc = " into the caller-provided buffer replacing unpaired surrogates"]
        #[doc = " with the REPLACEMENT CHARACTER."]
        #[doc = ""]
        #[doc = " If JS_StringHasLatin1Chars(str) returns true, the function"]
        #[doc = " is guaranteed to convert the entire string if"]
        #[doc = " buffer.Length() >= 2 * JS_GetStringLength(str). Otherwise,"]
        #[doc = " the function is guaranteed to convert the entire string if"]
        #[doc = " buffer.Length() >= 3 * JS_GetStringLength(str)."]
        #[doc = ""]
        #[doc = " This function does not alter the representation of |str| or"]
        #[doc = " any |JSString*| substring that is a constituent part of it."]
        #[doc = " Returns mozilla::Nothing() on OOM, without reporting an error;"]
        #[doc = " some data may have been written to |buffer| when this happens."]
        #[doc = ""]
        #[doc = " If there's no OOM, returns the number of code units read and"]
        #[doc = " the number of code units written."]
        #[doc = ""]
        #[doc = " The semantics of this method match the semantics of"]
        #[doc = " TextEncoder.encodeInto()."]
        #[doc = ""]
        #[doc = " The function does not store an additional zero byte."]
        #[link_name = "\u{1}_Z34JS_EncodeStringToUTF8BufferPartialP9JSContextP8JSStringN7mozilla4SpanIcLm18446744073709551615EEE"]
        pub fn JS_EncodeStringToUTF8BufferPartial(
            cx: *mut root::JSContext,
            str: *mut root::JSString,
            buffer: [u64; 2usize],
        ) -> u8;
    }
    extern "C" {
        #[doc = " Report an exception represented by the sprintf-like conversion of format"]
        #[doc = " and its arguments."]
        #[link_name = "\u{1}_Z19JS_ReportErrorASCIIP9JSContextPKcz"]
        pub fn JS_ReportErrorASCII(
            cx: *mut root::JSContext,
            format: *const ::std::os::raw::c_char,
            ...
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_ReportErrorLatin1P9JSContextPKcz"]
        pub fn JS_ReportErrorLatin1(
            cx: *mut root::JSContext,
            format: *const ::std::os::raw::c_char,
            ...
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_ReportErrorUTF8P9JSContextPKcz"]
        pub fn JS_ReportErrorUTF8(
            cx: *mut root::JSContext,
            format: *const ::std::os::raw::c_char,
            ...
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_ReportErrorNumberASCIIP9JSContextPFPK19JSErrorFormatStringPvjES4_jz"]
        pub fn JS_ReportErrorNumberASCII(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ...
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_ReportErrorNumberASCIIVAP9JSContextPFPK19JSErrorFormatStringPvjES4_jP13__va_list_tag"]
        pub fn JS_ReportErrorNumberASCIIVA(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ap: *mut root::__va_list_tag,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_ReportErrorNumberLatin1P9JSContextPFPK19JSErrorFormatStringPvjES4_jz"]
        pub fn JS_ReportErrorNumberLatin1(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ...
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z28JS_ReportErrorNumberLatin1VAP9JSContextPFPK19JSErrorFormatStringPvjES4_jP13__va_list_tag"]
        pub fn JS_ReportErrorNumberLatin1VA(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ap: *mut root::__va_list_tag,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_ReportErrorNumberUTF8P9JSContextPFPK19JSErrorFormatStringPvjES4_jz"]
        pub fn JS_ReportErrorNumberUTF8(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ...
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_ReportErrorNumberUTF8VAP9JSContextPFPK19JSErrorFormatStringPvjES4_jP13__va_list_tag"]
        pub fn JS_ReportErrorNumberUTF8VA(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ap: *mut root::__va_list_tag,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_ReportErrorNumberUCP9JSContextPFPK19JSErrorFormatStringPvjES4_jz"]
        pub fn JS_ReportErrorNumberUC(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ...
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_ReportErrorNumberUCArrayP9JSContextPFPK19JSErrorFormatStringPvjES4_jPPKDs"]
        pub fn JS_ReportErrorNumberUCArray(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            args: *mut *const u16,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z33JS_ReportErrorFlagsAndNumberASCIIP9JSContextjPFPK19JSErrorFormatStringPvjES4_jz"]
        pub fn JS_ReportErrorFlagsAndNumberASCII(
            cx: *mut root::JSContext,
            flags: ::std::os::raw::c_uint,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ...
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z34JS_ReportErrorFlagsAndNumberLatin1P9JSContextjPFPK19JSErrorFormatStringPvjES4_jz"]
        pub fn JS_ReportErrorFlagsAndNumberLatin1(
            cx: *mut root::JSContext,
            flags: ::std::os::raw::c_uint,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ...
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z32JS_ReportErrorFlagsAndNumberUTF8P9JSContextjPFPK19JSErrorFormatStringPvjES4_jz"]
        pub fn JS_ReportErrorFlagsAndNumberUTF8(
            cx: *mut root::JSContext,
            flags: ::std::os::raw::c_uint,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ...
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z30JS_ReportErrorFlagsAndNumberUCP9JSContextjPFPK19JSErrorFormatStringPvjES4_jz"]
        pub fn JS_ReportErrorFlagsAndNumberUC(
            cx: *mut root::JSContext,
            flags: ::std::os::raw::c_uint,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ...
        ) -> bool;
    }
    extern "C" {
        #[doc = " Complain when an allocation size overflows the maximum supported limit."]
        #[link_name = "\u{1}_Z27JS_ReportAllocationOverflowP9JSContext"]
        pub fn JS_ReportAllocationOverflow(cx: *mut root::JSContext);
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_IsExceptionPendingP9JSContext"]
        pub fn JS_IsExceptionPending(cx: *mut root::JSContext) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_GetPendingExceptionP9JSContextN2JS13MutableHandleINS1_5ValueEEE"]
        pub fn JS_GetPendingException(
            cx: *mut root::JSContext,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_SetPendingExceptionP9JSContextN2JS6HandleINS1_5ValueEEENS1_22ExceptionStackBehaviorE"]
        pub fn JS_SetPendingException(
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
            behavior: root::JS::ExceptionStackBehavior,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_ClearPendingExceptionP9JSContext"]
        pub fn JS_ClearPendingException(cx: *mut root::JSContext);
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_SaveExceptionStateP9JSContext"]
        pub fn JS_SaveExceptionState(cx: *mut root::JSContext) -> *mut root::JSExceptionState;
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_RestoreExceptionStateP9JSContextP16JSExceptionState"]
        pub fn JS_RestoreExceptionState(
            cx: *mut root::JSContext,
            state: *mut root::JSExceptionState,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_DropExceptionStateP9JSContextP16JSExceptionState"]
        pub fn JS_DropExceptionState(cx: *mut root::JSContext, state: *mut root::JSExceptionState);
    }
    extern "C" {
        #[doc = " If the given object is an exception object, the exception will have (or be"]
        #[doc = " able to lazily create) an error report struct, and this function will return"]
        #[doc = " the address of that struct.  Otherwise, it returns nullptr. The lifetime"]
        #[doc = " of the error report struct that might be returned is the same as the"]
        #[doc = " lifetime of the exception object."]
        #[link_name = "\u{1}_Z21JS_ErrorFromExceptionP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_ErrorFromException(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
        ) -> *mut root::JSErrorReport;
    }
    extern "C" {
        #[doc = " A JS context always has an \"owner thread\". The owner thread is set when the"]
        #[doc = " context is created (to the current thread) and practically all entry points"]
        #[doc = " into the JS engine check that a context (or anything contained in the"]
        #[doc = " context: runtime, compartment, object, etc) is only touched by its owner"]
        #[doc = " thread. Embeddings may check this invariant outside the JS engine by calling"]
        #[doc = " JS_AbortIfWrongThread (which will abort if not on the owner thread, even for"]
        #[doc = " non-debug builds)."]
        #[link_name = "\u{1}_Z21JS_AbortIfWrongThreadP9JSContext"]
        pub fn JS_AbortIfWrongThread(cx: *mut root::JSContext);
    }
    extern "C" {
        #[doc = " A constructor can request that the JS engine create a default new 'this'"]
        #[doc = " object of the given class, using the callee to determine parentage and"]
        #[doc = " [[Prototype]]."]
        #[link_name = "\u{1}_Z26JS_NewObjectForConstructorP9JSContextPK7JSClassRKN2JS8CallArgsE"]
        pub fn JS_NewObjectForConstructor(
            cx: *mut root::JSContext,
            clasp: *const root::JSClass,
            args: *const root::JS::CallArgs,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z28JS_SetParallelParsingEnabledP9JSContextb"]
        pub fn JS_SetParallelParsingEnabled(cx: *mut root::JSContext, enabled: bool);
    }
    extern "C" {
        #[link_name = "\u{1}_Z36JS_SetOffthreadIonCompilationEnabledP9JSContextb"]
        pub fn JS_SetOffthreadIonCompilationEnabled(cx: *mut root::JSContext, enabled: bool);
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum JSJitCompilerOption {
        JSJITCOMPILER_BASELINE_INTERPRETER_WARMUP_TRIGGER = 0,
        JSJITCOMPILER_BASELINE_WARMUP_TRIGGER = 1,
        JSJITCOMPILER_ION_NORMAL_WARMUP_TRIGGER = 2,
        JSJITCOMPILER_ION_FULL_WARMUP_TRIGGER = 3,
        JSJITCOMPILER_ION_GVN_ENABLE = 4,
        JSJITCOMPILER_ION_FORCE_IC = 5,
        JSJITCOMPILER_ION_ENABLE = 6,
        JSJITCOMPILER_ION_CHECK_RANGE_ANALYSIS = 7,
        JSJITCOMPILER_ION_FREQUENT_BAILOUT_THRESHOLD = 8,
        JSJITCOMPILER_BASELINE_INTERPRETER_ENABLE = 9,
        JSJITCOMPILER_BASELINE_ENABLE = 10,
        JSJITCOMPILER_OFFTHREAD_COMPILATION_ENABLE = 11,
        JSJITCOMPILER_FULL_DEBUG_CHECKS = 12,
        JSJITCOMPILER_JUMP_THRESHOLD = 13,
        JSJITCOMPILER_TRACK_OPTIMIZATIONS = 14,
        JSJITCOMPILER_NATIVE_REGEXP_ENABLE = 15,
        JSJITCOMPILER_SIMULATOR_ALWAYS_INTERRUPT = 16,
        JSJITCOMPILER_SPECTRE_INDEX_MASKING = 17,
        JSJITCOMPILER_SPECTRE_OBJECT_MITIGATIONS_BARRIERS = 18,
        JSJITCOMPILER_SPECTRE_OBJECT_MITIGATIONS_MISC = 19,
        JSJITCOMPILER_SPECTRE_STRING_MITIGATIONS = 20,
        JSJITCOMPILER_SPECTRE_VALUE_MASKING = 21,
        JSJITCOMPILER_SPECTRE_JIT_TO_CXX_CALLS = 22,
        JSJITCOMPILER_WASM_FOLD_OFFSETS = 23,
        JSJITCOMPILER_WASM_DELAY_TIER2 = 24,
        JSJITCOMPILER_WASM_JIT_BASELINE = 25,
        JSJITCOMPILER_WASM_JIT_CRANELIFT = 26,
        JSJITCOMPILER_WASM_JIT_ION = 27,
        JSJITCOMPILER_NOT_AN_OPTION = 28,
    }
    extern "C" {
        #[link_name = "\u{1}_Z29JS_SetGlobalJitCompilerOptionP9JSContext19JSJitCompilerOptionj"]
        pub fn JS_SetGlobalJitCompilerOption(
            cx: *mut root::JSContext,
            opt: root::JSJitCompilerOption,
            value: u32,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z29JS_GetGlobalJitCompilerOptionP9JSContext19JSJitCompilerOptionPj"]
        pub fn JS_GetGlobalJitCompilerOption(
            cx: *mut root::JSContext,
            opt: root::JSJitCompilerOption,
            valueOut: *mut u32,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Convert a uint32_t index into a jsid."]
        #[link_name = "\u{1}_Z12JS_IndexToIdP9JSContextjN2JS13MutableHandleINS1_11PropertyKeyEEE"]
        pub fn JS_IndexToId(
            cx: *mut root::JSContext,
            index: u32,
            arg1: root::JS::MutableHandleId,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Convert chars into a jsid."]
        #[doc = ""]
        #[doc = " |chars| may not be an index."]
        #[link_name = "\u{1}_Z12JS_CharsToIdP9JSContextN2JS12TwoByteCharsENS1_13MutableHandleINS1_11PropertyKeyEEE"]
        pub fn JS_CharsToId(
            cx: *mut root::JSContext,
            chars: root::JS::TwoByteChars,
            arg1: root::JS::MutableHandleId,
        ) -> bool;
    }
    extern "C" {
        #[doc = "  Test if the given string is a valid ECMAScript identifier"]
        #[link_name = "\u{1}_Z15JS_IsIdentifierP9JSContextN2JS6HandleIP8JSStringEEPb"]
        pub fn JS_IsIdentifier(
            cx: *mut root::JSContext,
            str: root::JS::HandleString,
            isIdentifier: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Test whether the given chars + length are a valid ECMAScript identifier."]
        #[doc = " This version is infallible, so just returns whether the chars are an"]
        #[doc = " identifier."]
        #[link_name = "\u{1}_Z15JS_IsIdentifierPKDsm"]
        pub fn JS_IsIdentifier1(chars: *const u16, length: usize) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_SetGrayGCRootsTracerP9JSContextPFvP8JSTracerPvES3_"]
        pub fn JS_SetGrayGCRootsTracer(
            cx: *mut root::JSContext,
            traceOp: root::JSTraceDataOp,
            data: *mut ::std::os::raw::c_void,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_FindCompilationScopeP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_FindCompilationScope(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_GetObjectFunctionP8JSObject"]
        pub fn JS_GetObjectFunction(obj: *mut root::JSObject) -> *mut root::JSFunction;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_SplicePrototypeP9JSContextN2JS6HandleIP8JSObjectEES5_"]
        pub fn JS_SplicePrototype(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            proto: root::JS::HandleObject,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_NewObjectWithUniqueTypeP9JSContextPK7JSClassN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewObjectWithUniqueType(
            cx: *mut root::JSContext,
            clasp: *const root::JSClass,
            proto: root::JS::HandleObject,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " Allocate an object in exactly the same way as JS_NewObjectWithGivenProto, but"]
        #[doc = " without invoking the metadata callback on it.  This allows creation of"]
        #[doc = " internal bookkeeping objects that are guaranteed to not have metadata"]
        #[doc = " attached to them."]
        #[link_name = "\u{1}_Z27JS_NewObjectWithoutMetadataP9JSContextPK7JSClassN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewObjectWithoutMetadata(
            cx: *mut root::JSContext,
            clasp: *const root::JSClass,
            proto: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z33JS_NondeterministicGetWeakMapKeysP9JSContextN2JS6HandleIP8JSObjectEENS1_13MutableHandleIS4_EE"]
        pub fn JS_NondeterministicGetWeakMapKeys(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            ret: root::JS::MutableHandleObject,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z33JS_NondeterministicGetWeakSetKeysP9JSContextN2JS6HandleIP8JSObjectEENS1_13MutableHandleIS4_EE"]
        pub fn JS_NondeterministicGetWeakSetKeys(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            ret: root::JS::MutableHandleObject,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_PCToLineNumberP8JSScriptPhPj"]
        pub fn JS_PCToLineNumber(
            script: *mut root::JSScript,
            pc: *mut root::jsbytecode,
            columnp: *mut ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_uint;
    }
    extern "C" {
        #[doc = " Determine whether the given object is backed by a DeadObjectProxy."]
        #[doc = ""]
        #[doc = " Such objects hold no other objects (they have no outgoing reference edges)"]
        #[doc = " and will throw if you touch them (e.g. by reading/writing a property)."]
        #[link_name = "\u{1}_Z16JS_IsDeadWrapperP8JSObject"]
        pub fn JS_IsDeadWrapper(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[doc = " Creates a new dead wrapper object in the given scope. To be used when"]
        #[doc = " attempting to wrap objects from scopes which are already dead."]
        #[doc = ""]
        #[doc = " If origObject is passed, it must be an proxy object, and will be"]
        #[doc = " used to determine the characteristics of the new dead wrapper."]
        #[link_name = "\u{1}_Z17JS_NewDeadWrapperP9JSContextP8JSObject"]
        pub fn JS_NewDeadWrapper(
            cx: *mut root::JSContext,
            origObject: *mut root::JSObject,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z35JS_TraceShapeCycleCollectorChildrenPN2JS14CallbackTracerENS_9GCCellPtrE"]
        pub fn JS_TraceShapeCycleCollectorChildren(
            trc: *mut root::JS::CallbackTracer,
            shape: root::JS::GCCellPtr,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z41JS_TraceObjectGroupCycleCollectorChildrenPN2JS14CallbackTracerENS_9GCCellPtrE"]
        pub fn JS_TraceObjectGroupCycleCollectorChildren(
            trc: *mut root::JS::CallbackTracer,
            group: root::JS::GCCellPtr,
        );
    }
    pub const JS_TELEMETRY_GC_REASON: root::_bindgen_ty_26 = _bindgen_ty_26::JS_TELEMETRY_GC_REASON;
    pub const JS_TELEMETRY_GC_IS_ZONE_GC: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_GC_IS_ZONE_GC;
    pub const JS_TELEMETRY_GC_MS: root::_bindgen_ty_26 = _bindgen_ty_26::JS_TELEMETRY_GC_MS;
    pub const JS_TELEMETRY_GC_BUDGET_MS: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_GC_BUDGET_MS;
    pub const JS_TELEMETRY_GC_BUDGET_OVERRUN: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_GC_BUDGET_OVERRUN;
    pub const JS_TELEMETRY_GC_ANIMATION_MS: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_GC_ANIMATION_MS;
    pub const JS_TELEMETRY_GC_MAX_PAUSE_MS_2: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_GC_MAX_PAUSE_MS_2;
    pub const JS_TELEMETRY_GC_MARK_MS: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_GC_MARK_MS;
    pub const JS_TELEMETRY_GC_SWEEP_MS: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_GC_SWEEP_MS;
    pub const JS_TELEMETRY_GC_COMPACT_MS: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_GC_COMPACT_MS;
    pub const JS_TELEMETRY_GC_MARK_ROOTS_MS: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_GC_MARK_ROOTS_MS;
    pub const JS_TELEMETRY_GC_MARK_GRAY_MS: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_GC_MARK_GRAY_MS;
    pub const JS_TELEMETRY_GC_SLICE_MS: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_GC_SLICE_MS;
    pub const JS_TELEMETRY_GC_SLOW_PHASE: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_GC_SLOW_PHASE;
    pub const JS_TELEMETRY_GC_SLOW_TASK: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_GC_SLOW_TASK;
    pub const JS_TELEMETRY_GC_MMU_50: root::_bindgen_ty_26 = _bindgen_ty_26::JS_TELEMETRY_GC_MMU_50;
    pub const JS_TELEMETRY_GC_RESET: root::_bindgen_ty_26 = _bindgen_ty_26::JS_TELEMETRY_GC_RESET;
    pub const JS_TELEMETRY_GC_RESET_REASON: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_GC_RESET_REASON;
    pub const JS_TELEMETRY_GC_INCREMENTAL_DISABLED: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_GC_INCREMENTAL_DISABLED;
    pub const JS_TELEMETRY_GC_NON_INCREMENTAL: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_GC_NON_INCREMENTAL;
    pub const JS_TELEMETRY_GC_NON_INCREMENTAL_REASON: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_GC_NON_INCREMENTAL_REASON;
    pub const JS_TELEMETRY_GC_SCC_SWEEP_TOTAL_MS: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_GC_SCC_SWEEP_TOTAL_MS;
    pub const JS_TELEMETRY_GC_SCC_SWEEP_MAX_PAUSE_MS: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_GC_SCC_SWEEP_MAX_PAUSE_MS;
    pub const JS_TELEMETRY_GC_MINOR_REASON: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_GC_MINOR_REASON;
    pub const JS_TELEMETRY_GC_MINOR_REASON_LONG: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_GC_MINOR_REASON_LONG;
    pub const JS_TELEMETRY_GC_MINOR_US: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_GC_MINOR_US;
    pub const JS_TELEMETRY_GC_NURSERY_BYTES: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_GC_NURSERY_BYTES;
    pub const JS_TELEMETRY_GC_PRETENURE_COUNT: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_GC_PRETENURE_COUNT;
    pub const JS_TELEMETRY_GC_NURSERY_PROMOTION_RATE: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_GC_NURSERY_PROMOTION_RATE;
    pub const JS_TELEMETRY_GC_TENURED_SURVIVAL_RATE: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_GC_TENURED_SURVIVAL_RATE;
    pub const JS_TELEMETRY_GC_MARK_RATE: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_GC_MARK_RATE;
    pub const JS_TELEMETRY_GC_TIME_BETWEEN_S: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_GC_TIME_BETWEEN_S;
    pub const JS_TELEMETRY_GC_TIME_BETWEEN_SLICES_MS: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_GC_TIME_BETWEEN_SLICES_MS;
    pub const JS_TELEMETRY_GC_SLICE_COUNT: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_GC_SLICE_COUNT;
    pub const JS_TELEMETRY_GC_EFFECTIVENESS: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_GC_EFFECTIVENESS;
    pub const JS_TELEMETRY_PRIVILEGED_PARSER_COMPILE_LAZY_AFTER_MS: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_PRIVILEGED_PARSER_COMPILE_LAZY_AFTER_MS;
    pub const JS_TELEMETRY_WEB_PARSER_COMPILE_LAZY_AFTER_MS: root::_bindgen_ty_26 =
        _bindgen_ty_26::JS_TELEMETRY_WEB_PARSER_COMPILE_LAZY_AFTER_MS;
    pub const JS_TELEMETRY_END: root::_bindgen_ty_26 = _bindgen_ty_26::JS_TELEMETRY_END;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum _bindgen_ty_26 {
        JS_TELEMETRY_GC_REASON = 0,
        JS_TELEMETRY_GC_IS_ZONE_GC = 1,
        JS_TELEMETRY_GC_MS = 2,
        JS_TELEMETRY_GC_BUDGET_MS = 3,
        JS_TELEMETRY_GC_BUDGET_OVERRUN = 4,
        JS_TELEMETRY_GC_ANIMATION_MS = 5,
        JS_TELEMETRY_GC_MAX_PAUSE_MS_2 = 6,
        JS_TELEMETRY_GC_MARK_MS = 7,
        JS_TELEMETRY_GC_SWEEP_MS = 8,
        JS_TELEMETRY_GC_COMPACT_MS = 9,
        JS_TELEMETRY_GC_MARK_ROOTS_MS = 10,
        JS_TELEMETRY_GC_MARK_GRAY_MS = 11,
        JS_TELEMETRY_GC_SLICE_MS = 12,
        JS_TELEMETRY_GC_SLOW_PHASE = 13,
        JS_TELEMETRY_GC_SLOW_TASK = 14,
        JS_TELEMETRY_GC_MMU_50 = 15,
        JS_TELEMETRY_GC_RESET = 16,
        JS_TELEMETRY_GC_RESET_REASON = 17,
        JS_TELEMETRY_GC_INCREMENTAL_DISABLED = 18,
        JS_TELEMETRY_GC_NON_INCREMENTAL = 19,
        JS_TELEMETRY_GC_NON_INCREMENTAL_REASON = 20,
        JS_TELEMETRY_GC_SCC_SWEEP_TOTAL_MS = 21,
        JS_TELEMETRY_GC_SCC_SWEEP_MAX_PAUSE_MS = 22,
        JS_TELEMETRY_GC_MINOR_REASON = 23,
        JS_TELEMETRY_GC_MINOR_REASON_LONG = 24,
        JS_TELEMETRY_GC_MINOR_US = 25,
        JS_TELEMETRY_GC_NURSERY_BYTES = 26,
        JS_TELEMETRY_GC_PRETENURE_COUNT = 27,
        JS_TELEMETRY_GC_NURSERY_PROMOTION_RATE = 28,
        JS_TELEMETRY_GC_TENURED_SURVIVAL_RATE = 29,
        JS_TELEMETRY_GC_MARK_RATE = 30,
        JS_TELEMETRY_GC_TIME_BETWEEN_S = 31,
        JS_TELEMETRY_GC_TIME_BETWEEN_SLICES_MS = 32,
        JS_TELEMETRY_GC_SLICE_COUNT = 33,
        JS_TELEMETRY_GC_EFFECTIVENESS = 34,
        JS_TELEMETRY_PRIVILEGED_PARSER_COMPILE_LAZY_AFTER_MS = 35,
        JS_TELEMETRY_WEB_PARSER_COMPILE_LAZY_AFTER_MS = 36,
        JS_TELEMETRY_END = 37,
    }
    pub type JSAccumulateTelemetryDataCallback = ::std::option::Option<
        unsafe extern "C" fn(
            id: ::std::os::raw::c_int,
            sample: u32,
            key: *const ::std::os::raw::c_char,
        ),
    >;
    extern "C" {
        #[link_name = "\u{1}_Z33JS_SetAccumulateTelemetryCallbackP9JSContextPFvijPKcE"]
        pub fn JS_SetAccumulateTelemetryCallback(
            cx: *mut root::JSContext,
            callback: root::JSAccumulateTelemetryDataCallback,
        );
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum JSUseCounter {
        ASMJS = 0,
        WASM = 1,
    }
    pub type JSSetUseCounterCallback = ::std::option::Option<
        unsafe extern "C" fn(obj: *mut root::JSObject, counter: root::JSUseCounter),
    >;
    extern "C" {
        #[link_name = "\u{1}_Z27JS_SetSetUseCounterCallbackP9JSContextPFvP8JSObject12JSUseCounterE"]
        pub fn JS_SetSetUseCounterCallback(
            cx: *mut root::JSContext,
            callback: root::JSSetUseCounterCallback,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_ReportFirstCompileTimeN2JS6HandleIP8JSScriptEERN7mozilla16BaseTimeDurationINS4_27TimeDurationValueCalculatorEEES8_"]
        pub fn JS_ReportFirstCompileTime(
            script: root::JS::HandleScript,
            parse: *mut root::mozilla::TimeDuration,
            emit: *mut root::mozilla::TimeDuration,
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_GetScriptPrincipalsP8JSScript"]
        pub fn JS_GetScriptPrincipals(script: *mut root::JSScript) -> *mut root::JSPrincipals;
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_ScriptHasMutedErrorsP8JSScript"]
        pub fn JS_ScriptHasMutedErrors(script: *mut root::JSScript) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z14JS_CloneObjectP9JSContextN2JS6HandleIP8JSObjectEES5_"]
        pub fn JS_CloneObject(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            proto: root::JS::HandleObject,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " Copy the own properties of src to dst in a fast way.  src and dst must both"]
        #[doc = " be native and must be in the compartment of cx.  They must have the same"]
        #[doc = " class, the same parent, and the same prototype.  Class reserved slots will"]
        #[doc = " NOT be copied."]
        #[doc = ""]
        #[doc = " dst must not have any properties on it before this function is called."]
        #[doc = ""]
        #[doc = " src must have been allocated via JS_NewObjectWithoutMetadata so that we can"]
        #[doc = " be sure it has no metadata that needs copying to dst.  This also means that"]
        #[doc = " dst needs to have the compartment global as its parent.  This function will"]
        #[doc = " preserve the existing metadata on dst, if any."]
        #[link_name = "\u{1}_Z49JS_InitializePropertiesFromCompatibleNativeObjectP9JSContextN2JS6HandleIP8JSObjectEES5_"]
        pub fn JS_InitializePropertiesFromCompatibleNativeObject(
            cx: *mut root::JSContext,
            dst: root::JS::HandleObject,
            src: root::JS::HandleObject,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Copies all own properties from |obj| to |target|. Both |obj| and |target|"]
        #[doc = " must not be cross-compartment wrappers because we have to enter their realms."]
        #[doc = ""]
        #[doc = " This function immediately enters a realm, and does not impose any"]
        #[doc = " restrictions on the realm of |cx|."]
        #[link_name = "\u{1}_Z21JS_CopyPropertiesFromP9JSContextN2JS6HandleIP8JSObjectEES5_"]
        pub fn JS_CopyPropertiesFrom(
            cx: *mut root::JSContext,
            target: root::JS::HandleObject,
            obj: root::JS::HandleObject,
        ) -> bool;
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum PropertyCopyBehavior {
        MakeNonConfigurableIntoConfigurable = 0,
        CopyNonConfigurableAsIs = 1,
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_CopyPropertyFromP9JSContextN2JS6HandleINS1_11PropertyKeyEEENS2_IP8JSObjectEES7_20PropertyCopyBehavior"]
        pub fn JS_CopyPropertyFrom(
            cx: *mut root::JSContext,
            id: root::JS::HandleId,
            target: root::JS::HandleObject,
            obj: root::JS::HandleObject,
            copyBehavior: root::PropertyCopyBehavior,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_WrapPropertyDescriptorP9JSContextN2JS13MutableHandleINS1_18PropertyDescriptorEEE"]
        pub fn JS_WrapPropertyDescriptor(
            cx: *mut root::JSContext,
            desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
        ) -> bool;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSFunctionSpecWithHelp {
        pub name: *const ::std::os::raw::c_char,
        pub call: root::JSNative,
        pub nargs: u16,
        pub flags: u16,
        pub jitInfo: *const root::JSJitInfo,
        pub usage: *const ::std::os::raw::c_char,
        pub help: *const ::std::os::raw::c_char,
    }
    #[test]
    fn bindgen_test_layout_JSFunctionSpecWithHelp() {
        assert_eq!(
            ::std::mem::size_of::<JSFunctionSpecWithHelp>(),
            48usize,
            concat!("Size of: ", stringify!(JSFunctionSpecWithHelp))
        );
        assert_eq!(
            ::std::mem::align_of::<JSFunctionSpecWithHelp>(),
            8usize,
            concat!("Alignment of ", stringify!(JSFunctionSpecWithHelp))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSFunctionSpecWithHelp>())).name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSFunctionSpecWithHelp),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSFunctionSpecWithHelp>())).call as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSFunctionSpecWithHelp),
                "::",
                stringify!(call)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSFunctionSpecWithHelp>())).nargs as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(JSFunctionSpecWithHelp),
                "::",
                stringify!(nargs)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSFunctionSpecWithHelp>())).flags as *const _ as usize
            },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(JSFunctionSpecWithHelp),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSFunctionSpecWithHelp>())).jitInfo as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(JSFunctionSpecWithHelp),
                "::",
                stringify!(jitInfo)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSFunctionSpecWithHelp>())).usage as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(JSFunctionSpecWithHelp),
                "::",
                stringify!(usage)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSFunctionSpecWithHelp>())).help as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(JSFunctionSpecWithHelp),
                "::",
                stringify!(help)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_DefineFunctionsWithHelpP9JSContextN2JS6HandleIP8JSObjectEEPK22JSFunctionSpecWithHelp"]
        pub fn JS_DefineFunctionsWithHelp(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            fs: *const root::JSFunctionSpecWithHelp,
        ) -> bool;
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum JSErrNum {
        JSMSG_NOT_AN_ERROR = 0,
        JSMSG_NOT_DEFINED = 1,
        JSMSG_MORE_ARGS_NEEDED = 2,
        JSMSG_INCOMPATIBLE_PROTO = 3,
        JSMSG_NO_CONSTRUCTOR = 4,
        JSMSG_BAD_SORT_ARG = 5,
        JSMSG_READ_ONLY = 6,
        JSMSG_CANT_DELETE = 7,
        JSMSG_CANT_TRUNCATE_ARRAY = 8,
        JSMSG_NOT_FUNCTION = 9,
        JSMSG_NOT_CONSTRUCTOR = 10,
        JSMSG_BOGUS_CONSTRUCTOR = 11,
        JSMSG_CANT_CONVERT_TO = 12,
        JSMSG_TOPRIMITIVE_NOT_CALLABLE = 13,
        JSMSG_TOPRIMITIVE_RETURNED_OBJECT = 14,
        JSMSG_NO_PROPERTIES = 15,
        JSMSG_BAD_REGEXP_FLAG = 16,
        JSMSG_INVALID_DATA_VIEW_LENGTH = 17,
        JSMSG_OFFSET_LARGER_THAN_FILESIZE = 18,
        JSMSG_OFFSET_OUT_OF_BUFFER = 19,
        JSMSG_OFFSET_OUT_OF_DATAVIEW = 20,
        JSMSG_SPREAD_TOO_LARGE = 21,
        JSMSG_BAD_WEAKMAP_KEY = 22,
        JSMSG_BAD_GETTER_OR_SETTER = 23,
        JSMSG_BAD_ARRAY_LENGTH = 24,
        JSMSG_SOURCE_ARRAY_TOO_LONG = 25,
        JSMSG_REDECLARED_PREV = 26,
        JSMSG_REDECLARED_VAR = 27,
        JSMSG_UNDECLARED_VAR = 28,
        JSMSG_GETTER_ONLY = 29,
        JSMSG_OVERWRITING_ACCESSOR = 30,
        JSMSG_UNDEFINED_PROP = 31,
        JSMSG_INVALID_MAP_ITERABLE = 32,
        JSMSG_NESTING_GENERATOR = 33,
        JSMSG_INCOMPATIBLE_METHOD = 34,
        JSMSG_BAD_SURROGATE_CHAR = 35,
        JSMSG_UTF8_CHAR_TOO_LARGE = 36,
        JSMSG_MALFORMED_UTF8_CHAR = 37,
        JSMSG_BUILTIN_CTOR_NO_NEW = 38,
        JSMSG_EMPTY_ARRAY_REDUCE = 39,
        JSMSG_UNEXPECTED_TYPE = 40,
        JSMSG_MISSING_FUN_ARG = 41,
        JSMSG_OBJECT_REQUIRED = 42,
        JSMSG_OBJECT_REQUIRED_ARG = 43,
        JSMSG_OBJECT_REQUIRED_WEAKMAP_KEY = 44,
        JSMSG_OBJECT_REQUIRED_WEAKSET_VAL = 45,
        JSMSG_OBJECT_REQUIRED_PROP_DESC = 46,
        JSMSG_OBJECT_REQUIRED_RET_OWNKEYS = 47,
        JSMSG_WRONG_TYPE_ARG = 48,
        JSMSG_SET_NON_OBJECT_RECEIVER = 49,
        JSMSG_INVALID_DESCRIPTOR = 50,
        JSMSG_OBJECT_NOT_EXTENSIBLE = 51,
        JSMSG_CANT_DEFINE_PROP_OBJECT_NOT_EXTENSIBLE = 52,
        JSMSG_CANT_REDEFINE_PROP = 53,
        JSMSG_CANT_REDEFINE_ARRAY_LENGTH = 54,
        JSMSG_CANT_DEFINE_PAST_ARRAY_LENGTH = 55,
        JSMSG_BAD_GET_SET_FIELD = 56,
        JSMSG_THROW_TYPE_ERROR = 57,
        JSMSG_NOT_EXPECTED_TYPE = 58,
        JSMSG_NOT_ITERABLE = 59,
        JSMSG_ALREADY_HAS_PRAGMA = 60,
        JSMSG_GET_ITER_RETURNED_PRIMITIVE = 61,
        JSMSG_ITER_METHOD_RETURNED_PRIMITIVE = 62,
        JSMSG_CANT_SET_PROTO = 63,
        JSMSG_CANT_SET_PROTO_OF = 64,
        JSMSG_CANT_SET_PROTO_CYCLE = 65,
        JSMSG_INVALID_ARG_TYPE = 66,
        JSMSG_TERMINATED = 67,
        JSMSG_CANT_CALL_CLASS_CONSTRUCTOR = 68,
        JSMSG_UNINITIALIZED_THIS = 69,
        JSMSG_BAD_DERIVED_RETURN = 70,
        JSMSG_BAD_HERITAGE = 71,
        JSMSG_NOT_OBJORNULL = 72,
        JSMSG_CONSTRUCTOR_DISABLED = 73,
        JSMSG_JSON_BAD_PARSE = 74,
        JSMSG_JSON_CYCLIC_VALUE = 75,
        JSMSG_ASSIGN_TO_CALL = 76,
        JSMSG_BAD_INSTANCEOF_RHS = 77,
        JSMSG_BAD_PROTOTYPE = 78,
        JSMSG_IN_NOT_OBJECT = 79,
        JSMSG_IN_STRING = 80,
        JSMSG_TOO_MANY_CON_SPREADARGS = 81,
        JSMSG_TOO_MANY_FUN_SPREADARGS = 82,
        JSMSG_UNINITIALIZED_LEXICAL = 83,
        JSMSG_BAD_CONST_ASSIGN = 84,
        JSMSG_CANT_DECLARE_GLOBAL_BINDING = 85,
        JSMSG_INVALID_DATE = 86,
        JSMSG_BAD_TOISOSTRING_PROP = 87,
        JSMSG_BAD_URI = 88,
        JSMSG_INVALID_NORMALIZE_FORM = 89,
        JSMSG_NEGATIVE_REPETITION_COUNT = 90,
        JSMSG_NOT_A_CODEPOINT = 91,
        JSMSG_RESULTING_STRING_TOO_LARGE = 92,
        JSMSG_FLAGS_UNDEFINED_OR_NULL = 93,
        JSMSG_REQUIRES_GLOBAL_REGEXP = 94,
        JSMSG_BAD_RADIX = 95,
        JSMSG_PRECISION_RANGE = 96,
        JSMSG_BAD_APPLY_ARGS = 97,
        JSMSG_BAD_FORMAL = 98,
        JSMSG_CALLER_IS_STRICT = 99,
        JSMSG_DEPRECATED_USAGE = 100,
        JSMSG_NOT_SCRIPTED_FUNCTION = 101,
        JSMSG_NO_REST_NAME = 102,
        JSMSG_PARAMETER_AFTER_REST = 103,
        JSMSG_TOO_MANY_ARGUMENTS = 104,
        JSMSG_CSP_BLOCKED_EVAL = 105,
        JSMSG_CSP_BLOCKED_FUNCTION = 106,
        JSMSG_ACCESSOR_DEF_DENIED = 107,
        JSMSG_DEAD_OBJECT = 108,
        JSMSG_OBJECT_ACCESS_DENIED = 109,
        JSMSG_PROPERTY_ACCESS_DENIED = 110,
        JSMSG_CANT_CLONE_OBJECT = 111,
        JSMSG_CANT_OPEN = 112,
        JSMSG_SUPPORT_NOT_ENABLED = 113,
        JSMSG_USER_DEFINED_ERROR = 114,
        JSMSG_ALLOC_OVERFLOW = 115,
        JSMSG_BAD_BYTECODE = 116,
        JSMSG_BUFFER_TOO_SMALL = 117,
        JSMSG_BUILD_ID_NOT_AVAILABLE = 118,
        JSMSG_BYTECODE_TOO_BIG = 119,
        JSMSG_NEED_DIET = 120,
        JSMSG_OUT_OF_MEMORY = 121,
        JSMSG_OVER_RECURSED = 122,
        JSMSG_TOO_BIG_TO_ENCODE = 123,
        JSMSG_TOO_DEEP = 124,
        JSMSG_UNCAUGHT_EXCEPTION = 125,
        JSMSG_UNKNOWN_FORMAT = 126,
        JSMSG_UNSAFE_FILENAME = 127,
        JSMSG_ACCESSOR_WRONG_ARGS = 128,
        JSMSG_ARRAY_INIT_TOO_BIG = 129,
        JSMSG_AS_AFTER_IMPORT_STAR = 130,
        JSMSG_AS_AFTER_RESERVED_WORD = 131,
        JSMSG_AWAIT_IN_PARAMETER = 132,
        JSMSG_AWAIT_OUTSIDE_ASYNC = 133,
        JSMSG_BAD_ARROW_ARGS = 134,
        JSMSG_BAD_BINDING = 135,
        JSMSG_BAD_COALESCE_MIXING = 136,
        JSMSG_BAD_CONST_DECL = 137,
        JSMSG_BAD_CONTINUE = 138,
        JSMSG_BAD_DESTRUCT_ASS = 139,
        JSMSG_BAD_DESTRUCT_TARGET = 140,
        JSMSG_BAD_DESTRUCT_PARENS = 141,
        JSMSG_BAD_DESTRUCT_DECL = 142,
        JSMSG_BAD_DUP_ARGS = 143,
        JSMSG_BAD_FOR_EACH_LOOP = 144,
        JSMSG_BAD_FOR_LEFTSIDE = 145,
        JSMSG_LEXICAL_DECL_DEFINES_LET = 146,
        JSMSG_LET_STARTING_FOROF_LHS = 147,
        JSMSG_BAD_INCOP_OPERAND = 148,
        JSMSG_BAD_LEFTSIDE_OF_ASS = 149,
        JSMSG_BAD_METHOD_DEF = 150,
        JSMSG_BAD_POW_LEFTSIDE = 151,
        JSMSG_BAD_PROP_ID = 152,
        JSMSG_BAD_RETURN_OR_YIELD = 153,
        JSMSG_BAD_STRICT_ASSIGN = 154,
        JSMSG_BAD_STRICT_ASSIGN_ARGUMENTS = 155,
        JSMSG_BAD_STRICT_ASSIGN_EVAL = 156,
        JSMSG_BAD_SWITCH = 157,
        JSMSG_BAD_SUPER = 158,
        JSMSG_BAD_SUPERPROP = 159,
        JSMSG_BAD_SUPERCALL = 160,
        JSMSG_BAD_ARGUMENTS = 161,
        JSMSG_BRACKET_AFTER_LIST = 162,
        JSMSG_BRACKET_IN_INDEX = 163,
        JSMSG_BRACKET_OPENED = 164,
        JSMSG_CATCH_AFTER_GENERAL = 165,
        JSMSG_CATCH_IDENTIFIER = 166,
        JSMSG_CATCH_OR_FINALLY = 167,
        JSMSG_CATCH_WITHOUT_TRY = 168,
        JSMSG_COLON_AFTER_CASE = 169,
        JSMSG_COLON_AFTER_ID = 170,
        JSMSG_COLON_IN_COND = 171,
        JSMSG_COMP_PROP_UNTERM_EXPR = 172,
        JSMSG_CONTRARY_NONDIRECTIVE = 173,
        JSMSG_CURLY_AFTER_BODY = 174,
        JSMSG_CURLY_OPENED = 175,
        JSMSG_CURLY_AFTER_CATCH = 176,
        JSMSG_CURLY_AFTER_FINALLY = 177,
        JSMSG_CURLY_AFTER_LIST = 178,
        JSMSG_CURLY_AFTER_TRY = 179,
        JSMSG_CURLY_BEFORE_BODY = 180,
        JSMSG_CURLY_BEFORE_CATCH = 181,
        JSMSG_CURLY_BEFORE_CLASS = 182,
        JSMSG_CURLY_BEFORE_FINALLY = 183,
        JSMSG_CURLY_BEFORE_SWITCH = 184,
        JSMSG_CURLY_BEFORE_TRY = 185,
        JSMSG_CURLY_IN_COMPOUND = 186,
        JSMSG_DECLARATION_AFTER_EXPORT = 187,
        JSMSG_DECLARATION_AFTER_IMPORT = 188,
        JSMSG_DEPRECATED_DELETE_OPERAND = 189,
        JSMSG_DEPRECATED_OCTAL = 190,
        JSMSG_DEPRECATED_PRAGMA = 191,
        JSMSG_DUPLICATE_EXPORT_NAME = 192,
        JSMSG_DUPLICATE_FORMAL = 193,
        JSMSG_DUPLICATE_LABEL = 194,
        JSMSG_DUPLICATE_PROPERTY = 195,
        JSMSG_DUPLICATE_PROTO_PROPERTY = 196,
        JSMSG_EMPTY_CONSEQUENT = 197,
        JSMSG_EQUAL_AS_ASSIGN = 198,
        JSMSG_EXPORT_DECL_AT_TOP_LEVEL = 199,
        JSMSG_FINALLY_WITHOUT_TRY = 200,
        JSMSG_FORBIDDEN_AS_STATEMENT = 201,
        JSMSG_FOR_AWAIT_OUTSIDE_ASYNC = 202,
        JSMSG_FROM_AFTER_IMPORT_CLAUSE = 203,
        JSMSG_FROM_AFTER_EXPORT_STAR = 204,
        JSMSG_GARBAGE_AFTER_INPUT = 205,
        JSMSG_IDSTART_AFTER_NUMBER = 206,
        JSMSG_BAD_ESCAPE = 207,
        JSMSG_MISSING_PRIVATE_NAME = 208,
        JSMSG_ILLEGAL_CHARACTER = 209,
        JSMSG_IMPORT_META_OUTSIDE_MODULE = 210,
        JSMSG_IMPORT_DECL_AT_TOP_LEVEL = 211,
        JSMSG_OF_AFTER_FOR_LOOP_DECL = 212,
        JSMSG_IN_AFTER_LEXICAL_FOR_DECL = 213,
        JSMSG_INVALID_FOR_IN_DECL_WITH_INIT = 214,
        JSMSG_INVALID_ID = 215,
        JSMSG_SEPARATOR_IN_ZERO_PREFIXED_NUMBER = 216,
        JSMSG_LABEL_NOT_FOUND = 217,
        JSMSG_LEXICAL_DECL_NOT_IN_BLOCK = 218,
        JSMSG_LEXICAL_DECL_LABEL = 219,
        JSMSG_GENERATOR_LABEL = 220,
        JSMSG_FUNCTION_LABEL = 221,
        JSMSG_SLOPPY_FUNCTION_LABEL = 222,
        JSMSG_LINE_BREAK_AFTER_THROW = 223,
        JSMSG_LINE_BREAK_BEFORE_ARROW = 224,
        JSMSG_MALFORMED_ESCAPE = 225,
        JSMSG_MISSING_BINARY_DIGITS = 226,
        JSMSG_MISSING_EXPONENT = 227,
        JSMSG_MISSING_EXPR_AFTER_THROW = 228,
        JSMSG_MISSING_FORMAL = 229,
        JSMSG_MISSING_HEXDIGITS = 230,
        JSMSG_MISSING_OCTAL_DIGITS = 231,
        JSMSG_NUMBER_END_WITH_UNDERSCORE = 232,
        JSMSG_NUMBER_MULTIPLE_ADJACENT_UNDERSCORES = 233,
        JSMSG_MODULE_SPEC_AFTER_FROM = 234,
        JSMSG_NAME_AFTER_DOT = 235,
        JSMSG_NAMED_IMPORTS_OR_NAMESPACE_IMPORT = 236,
        JSMSG_NO_BINDING_NAME = 237,
        JSMSG_NO_EXPORT_NAME = 238,
        JSMSG_NO_IMPORT_NAME = 239,
        JSMSG_NO_VARIABLE_NAME = 240,
        JSMSG_OF_AFTER_FOR_NAME = 241,
        JSMSG_PAREN_AFTER_ARGS = 242,
        JSMSG_PAREN_AFTER_CATCH = 243,
        JSMSG_PAREN_AFTER_COND = 244,
        JSMSG_PAREN_AFTER_FOR = 245,
        JSMSG_PAREN_AFTER_FORMAL = 246,
        JSMSG_PAREN_AFTER_FOR_CTRL = 247,
        JSMSG_PAREN_AFTER_FOR_OF_ITERABLE = 248,
        JSMSG_PAREN_AFTER_SWITCH = 249,
        JSMSG_PAREN_AFTER_WITH = 250,
        JSMSG_PAREN_BEFORE_CATCH = 251,
        JSMSG_PAREN_BEFORE_COND = 252,
        JSMSG_PAREN_BEFORE_FORMAL = 253,
        JSMSG_PAREN_BEFORE_SWITCH = 254,
        JSMSG_PAREN_BEFORE_WITH = 255,
        JSMSG_PAREN_IN_PAREN = 256,
        JSMSG_RC_AFTER_EXPORT_SPEC_LIST = 257,
        JSMSG_RC_AFTER_IMPORT_SPEC_LIST = 258,
        JSMSG_REDECLARED_CATCH_IDENTIFIER = 259,
        JSMSG_RESERVED_ID = 260,
        JSMSG_REST_WITH_COMMA = 261,
        JSMSG_REST_WITH_DEFAULT = 262,
        JSMSG_SELFHOSTED_TOP_LEVEL_LEXICAL = 263,
        JSMSG_SELFHOSTED_METHOD_CALL = 264,
        JSMSG_SELFHOSTED_UNBOUND_NAME = 265,
        JSMSG_SEMI_AFTER_FOR_COND = 266,
        JSMSG_SEMI_AFTER_FOR_INIT = 267,
        JSMSG_SOURCE_TOO_LONG = 268,
        JSMSG_STMT_AFTER_RETURN = 269,
        JSMSG_STRICT_CODE_WITH = 270,
        JSMSG_STRICT_NON_SIMPLE_PARAMS = 271,
        JSMSG_TEMPLSTR_UNTERM_EXPR = 272,
        JSMSG_TOO_MANY_CASES = 273,
        JSMSG_TOO_MANY_CATCH_VARS = 274,
        JSMSG_TOO_MANY_CON_ARGS = 275,
        JSMSG_TOO_MANY_DEFAULTS = 276,
        JSMSG_TOO_MANY_FUN_ARGS = 277,
        JSMSG_TOO_MANY_LOCALS = 278,
        JSMSG_TOO_MANY_RESUME_INDEXES = 279,
        JSMSG_TOUGH_BREAK = 280,
        JSMSG_UNEXPECTED_TOKEN = 281,
        JSMSG_UNEXPECTED_TOKEN_NO_EXPECT = 282,
        JSMSG_UNEXPECTED_PARAMLIST_END = 283,
        JSMSG_UNNAMED_CLASS_STMT = 284,
        JSMSG_UNNAMED_FUNCTION_STMT = 285,
        JSMSG_UNTERMINATED_COMMENT = 286,
        JSMSG_UNTERMINATED_REGEXP = 287,
        JSMSG_EOF_BEFORE_END_OF_LITERAL = 288,
        JSMSG_EOL_BEFORE_END_OF_STRING = 289,
        JSMSG_EOF_IN_ESCAPE_IN_LITERAL = 290,
        JSMSG_USELESS_EXPR = 291,
        JSMSG_USE_ASM_DIRECTIVE_FAIL = 292,
        JSMSG_VAR_HIDES_ARG = 293,
        JSMSG_WHILE_AFTER_DO = 294,
        JSMSG_YIELD_IN_PARAMETER = 295,
        JSMSG_YIELD_OUTSIDE_GENERATOR = 296,
        JSMSG_BAD_COLUMN_NUMBER = 297,
        JSMSG_COMPUTED_NAME_IN_PATTERN = 298,
        JSMSG_DEFAULT_IN_PATTERN = 299,
        JSMSG_BAD_NEWTARGET = 300,
        JSMSG_ESCAPED_KEYWORD = 301,
        JSMSG_FIELDS_NOT_SUPPORTED = 302,
        JSMSG_PRIVATE_FIELDS_NOT_SUPPORTED = 303,
        JSMSG_BAD_LEADING_UTF8_UNIT = 304,
        JSMSG_NOT_ENOUGH_CODE_UNITS = 305,
        JSMSG_BAD_TRAILING_UTF8_UNIT = 306,
        JSMSG_FORBIDDEN_UTF8_CODE_POINT = 307,
        JSMSG_BAD_CODE_UNITS = 308,
        JSMSG_USE_ASM_TYPE_FAIL = 309,
        JSMSG_USE_ASM_LINK_FAIL = 310,
        JSMSG_USE_ASM_TYPE_OK = 311,
        JSMSG_USE_ASM_TYPE_OK_NO_TIME = 312,
        JSMSG_WASM_VERBOSE = 313,
        JSMSG_WASM_COMPILE_WARNING = 314,
        JSMSG_WASM_HUGE_MEMORY_FAILED = 315,
        JSMSG_WASM_COMPILE_ERROR = 316,
        JSMSG_WASM_NO_SHMEM_COMPILE = 317,
        JSMSG_WASM_BAD_IMPORT_TYPE = 318,
        JSMSG_WASM_BAD_IMPORT_SIG = 319,
        JSMSG_WASM_BAD_IMP_SIZE = 320,
        JSMSG_WASM_BAD_IMP_MAX = 321,
        JSMSG_WASM_IMP_SHARED_REQD = 322,
        JSMSG_WASM_IMP_SHARED_BANNED = 323,
        JSMSG_WASM_BAD_FIT = 324,
        JSMSG_WASM_BAD_I64_LINK = 325,
        JSMSG_WASM_NO_SHMEM_LINK = 326,
        JSMSG_WASM_BAD_GLOB_MUT_LINK = 327,
        JSMSG_WASM_BAD_GLOB_TYPE_LINK = 328,
        JSMSG_WASM_BAD_TBL_TYPE_LINK = 329,
        JSMSG_WASM_IND_CALL_TO_NULL = 330,
        JSMSG_WASM_IND_CALL_BAD_SIG = 331,
        JSMSG_WASM_UNREACHABLE = 332,
        JSMSG_WASM_INTEGER_OVERFLOW = 333,
        JSMSG_WASM_INVALID_CONVERSION = 334,
        JSMSG_WASM_INT_DIVIDE_BY_ZERO = 335,
        JSMSG_WASM_OUT_OF_BOUNDS = 336,
        JSMSG_WASM_UNALIGNED_ACCESS = 337,
        JSMSG_WASM_WAKE_OVERFLOW = 338,
        JSMSG_WASM_DEREF_NULL = 339,
        JSMSG_WASM_BAD_RANGE = 340,
        JSMSG_WASM_BAD_GROW = 341,
        JSMSG_WASM_TABLE_OUT_OF_BOUNDS = 342,
        JSMSG_WASM_BAD_UINT32 = 343,
        JSMSG_WASM_BAD_BUF_ARG = 344,
        JSMSG_WASM_BAD_MOD_ARG = 345,
        JSMSG_WASM_BAD_BUF_MOD_ARG = 346,
        JSMSG_WASM_BAD_DESC_ARG = 347,
        JSMSG_WASM_BAD_ELEMENT = 348,
        JSMSG_WASM_BAD_ELEMENT_GENERALIZED = 349,
        JSMSG_WASM_BAD_IMPORT_ARG = 350,
        JSMSG_WASM_BAD_IMPORT_FIELD = 351,
        JSMSG_WASM_BAD_FUNCREF_VALUE = 352,
        JSMSG_WASM_BAD_I64_TYPE = 353,
        JSMSG_WASM_BAD_GLOBAL_TYPE = 354,
        JSMSG_WASM_NO_TRANSFER = 355,
        JSMSG_WASM_TEXT_FAIL = 356,
        JSMSG_WASM_MISSING_MAXIMUM = 357,
        JSMSG_WASM_GLOBAL_IMMUTABLE = 358,
        JSMSG_BAD_TRAP_RETURN_VALUE = 359,
        JSMSG_BAD_GETPROTOTYPEOF_TRAP_RETURN = 360,
        JSMSG_INCONSISTENT_GETPROTOTYPEOF_TRAP = 361,
        JSMSG_PROXY_SETPROTOTYPEOF_RETURNED_FALSE = 362,
        JSMSG_PROXY_ISEXTENSIBLE_RETURNED_FALSE = 363,
        JSMSG_INCONSISTENT_SETPROTOTYPEOF_TRAP = 364,
        JSMSG_CANT_CHANGE_EXTENSIBILITY = 365,
        JSMSG_CANT_DEFINE_INVALID = 366,
        JSMSG_CANT_DEFINE_NEW = 367,
        JSMSG_CANT_DEFINE_NE_AS_NC = 368,
        JSMSG_PROXY_DEFINE_RETURNED_FALSE = 369,
        JSMSG_PROXY_DELETE_RETURNED_FALSE = 370,
        JSMSG_PROXY_PREVENTEXTENSIONS_RETURNED_FALSE = 371,
        JSMSG_PROXY_SET_RETURNED_FALSE = 372,
        JSMSG_CANT_REPORT_AS_NON_EXTENSIBLE = 373,
        JSMSG_CANT_DELETE_NON_EXTENSIBLE = 374,
        JSMSG_CANT_REPORT_C_AS_NC = 375,
        JSMSG_CANT_REPORT_E_AS_NE = 376,
        JSMSG_CANT_REPORT_INVALID = 377,
        JSMSG_CANT_REPORT_NC_AS_NE = 378,
        JSMSG_CANT_REPORT_NEW = 379,
        JSMSG_CANT_REPORT_NE_AS_NC = 380,
        JSMSG_CANT_REPORT_W_AS_NW = 381,
        JSMSG_CANT_SET_NW_NC = 382,
        JSMSG_CANT_SET_WO_SETTER = 383,
        JSMSG_CANT_SKIP_NC = 384,
        JSMSG_OWNKEYS_STR_SYM = 385,
        JSMSG_OWNKEYS_DUPLICATE = 386,
        JSMSG_MUST_REPORT_SAME_VALUE = 387,
        JSMSG_MUST_REPORT_UNDEFINED = 388,
        JSMSG_PROXY_CONSTRUCT_OBJECT = 389,
        JSMSG_PROXY_EXTENSIBILITY = 390,
        JSMSG_PROXY_GETOWN_OBJORUNDEF = 391,
        JSMSG_PROXY_REVOKED = 392,
        JSMSG_PROXY_ARG_REVOKED = 393,
        JSMSG_BAD_TRAP = 394,
        JSMSG_SC_BAD_CLONE_VERSION = 395,
        JSMSG_SC_BAD_SERIALIZED_DATA = 396,
        JSMSG_SC_DUP_TRANSFERABLE = 397,
        JSMSG_SC_NOT_TRANSFERABLE = 398,
        JSMSG_SC_UNSUPPORTED_TYPE = 399,
        JSMSG_SC_NOT_CLONABLE = 400,
        JSMSG_SC_NOT_CLONABLE_WITH_COOP_COEP = 401,
        JSMSG_SC_SAB_DISABLED = 402,
        JSMSG_SC_SAB_REFCNT_OFLO = 403,
        JSMSG_SC_SHMEM_TRANSFERABLE = 404,
        JSMSG_SC_SHMEM_POLICY = 405,
        JSMSG_ASSIGN_FUNCTION_OR_NULL = 406,
        JSMSG_DEBUG_BAD_LINE = 407,
        JSMSG_DEBUG_BAD_OFFSET = 408,
        JSMSG_DEBUG_BAD_REFERENT = 409,
        JSMSG_DEBUG_BAD_RESUMPTION = 410,
        JSMSG_DEBUG_BAD_YIELD = 411,
        JSMSG_DEBUG_CANT_DEBUG_GLOBAL = 412,
        JSMSG_DEBUG_SAME_COMPARTMENT = 413,
        JSMSG_DEBUG_CCW_REQUIRED = 414,
        JSMSG_DEBUG_COMPARTMENT_MISMATCH = 415,
        JSMSG_DEBUG_LOOP = 416,
        JSMSG_DEBUG_NOT_DEBUGGEE = 417,
        JSMSG_DEBUG_NOT_DEBUGGING = 418,
        JSMSG_DEBUG_NOT_IDLE = 419,
        JSMSG_DEBUG_NOT_LIVE = 420,
        JSMSG_DEBUG_NO_ENV_OBJECT = 421,
        JSMSG_DEBUG_PROTO = 422,
        JSMSG_DEBUG_WRONG_OWNER = 423,
        JSMSG_DEBUG_OPTIMIZED_OUT = 424,
        JSMSG_DEBUG_OPTIMIZED_OUT_FUN = 425,
        JSMSG_DEBUG_FORCED_RETURN_DISALLOWED = 426,
        JSMSG_DEBUG_RESUMPTION_VALUE_DISALLOWED = 427,
        JSMSG_DEBUG_VARIABLE_NOT_FOUND = 428,
        JSMSG_DEBUG_WRAPPER_IN_WAY = 429,
        JSMSG_DEBUGGEE_WOULD_RUN = 430,
        JSMSG_NOT_CALLABLE_OR_UNDEFINED = 431,
        JSMSG_NOT_TRACKING_ALLOCATIONS = 432,
        JSMSG_OBJECT_METADATA_CALLBACK_ALREADY_SET = 433,
        JSMSG_QUERY_INNERMOST_WITHOUT_LINE_URL = 434,
        JSMSG_QUERY_LINE_WITHOUT_URL = 435,
        JSMSG_DEBUG_CANT_SET_OPT_ENV = 436,
        JSMSG_DEBUG_INVISIBLE_COMPARTMENT = 437,
        JSMSG_DEBUG_CENSUS_BREAKDOWN = 438,
        JSMSG_DEBUG_PROMISE_NOT_RESOLVED = 439,
        JSMSG_DEBUG_PROMISE_NOT_FULFILLED = 440,
        JSMSG_DEBUG_PROMISE_NOT_REJECTED = 441,
        JSMSG_DEBUG_NO_BINARY_SOURCE = 442,
        JSMSG_TESTING_SCRIPTS_ONLY = 443,
        JSMSG_TRACELOGGER_ENABLE_FAIL = 444,
        JSMSG_DATE_NOT_FINITE = 445,
        JSMSG_DUPLICATE_VARIANT_SUBTAG = 446,
        JSMSG_INTERNAL_INTL_ERROR = 447,
        JSMSG_INVALID_CURRENCY_CODE = 448,
        JSMSG_INVALID_UNIT_IDENTIFIER = 449,
        JSMSG_INVALID_DIGITS_VALUE = 450,
        JSMSG_INVALID_KEYS_TYPE = 451,
        JSMSG_INVALID_KEY = 452,
        JSMSG_INVALID_LANGUAGE_TAG = 453,
        JSMSG_INVALID_LOCALES_ELEMENT = 454,
        JSMSG_INVALID_LOCALE_MATCHER = 455,
        JSMSG_INVALID_OPTION_VALUE = 456,
        JSMSG_INVALID_TIME_ZONE = 457,
        JSMSG_UNDEFINED_CURRENCY = 458,
        JSMSG_UNDEFINED_UNIT = 459,
        JSMSG_BACK_REF_OUT_OF_RANGE = 460,
        JSMSG_BAD_CLASS_RANGE = 461,
        JSMSG_ESCAPE_AT_END_OF_REGEXP = 462,
        JSMSG_EXEC_NOT_OBJORNULL = 463,
        JSMSG_INVALID_DECIMAL_ESCAPE = 464,
        JSMSG_INVALID_GROUP = 465,
        JSMSG_INVALID_IDENTITY_ESCAPE = 466,
        JSMSG_INVALID_UNICODE_ESCAPE = 467,
        JSMSG_MISSING_PAREN = 468,
        JSMSG_NEWREGEXP_FLAGGED = 469,
        JSMSG_NOTHING_TO_REPEAT = 470,
        JSMSG_NUMBERS_OUT_OF_ORDER = 471,
        JSMSG_RANGE_WITH_CLASS_ESCAPE = 472,
        JSMSG_RAW_BRACE_IN_REGEXP = 473,
        JSMSG_RAW_BRACKET_IN_REGEXP = 474,
        JSMSG_TOO_MANY_PARENS = 475,
        JSMSG_UNICODE_OVERFLOW = 476,
        JSMSG_UNMATCHED_RIGHT_PAREN = 477,
        JSMSG_UNTERM_CLASS = 478,
        JSMSG_DEFAULT_LOCALE_ERROR = 479,
        JSMSG_NO_SUCH_SELF_HOSTED_PROP = 480,
        JSMSG_INVALID_PROTOTYPE = 481,
        JSMSG_TYPEDOBJECT_BAD_ARGS = 482,
        JSMSG_TYPEDOBJECT_BINARYARRAY_BAD_INDEX = 483,
        JSMSG_TYPEDOBJECT_HANDLE_UNATTACHED = 484,
        JSMSG_TYPEDOBJECT_STRUCTTYPE_BAD_ARGS = 485,
        JSMSG_TYPEDOBJECT_STRUCTTYPE_NOT_CALLABLE = 486,
        JSMSG_TYPEDOBJECT_TOO_BIG = 487,
        JSMSG_TYPEDOBJECT_SETTING_IMMUTABLE = 488,
        JSMSG_TYPEDOBJECT_NOT_CONSTRUCTIBLE = 489,
        JSMSG_TOO_LONG_ARRAY = 490,
        JSMSG_BAD_INDEX = 491,
        JSMSG_NON_ARRAY_BUFFER_RETURNED = 492,
        JSMSG_SAME_ARRAY_BUFFER_RETURNED = 493,
        JSMSG_SHORT_ARRAY_BUFFER_RETURNED = 494,
        JSMSG_TYPED_ARRAY_BAD_ARGS = 495,
        JSMSG_TYPED_ARRAY_NEGATIVE_ARG = 496,
        JSMSG_TYPED_ARRAY_DETACHED = 497,
        JSMSG_TYPED_ARRAY_CONSTRUCT_BOUNDS = 498,
        JSMSG_TYPED_ARRAY_CALL_OR_CONSTRUCT = 499,
        JSMSG_NON_TYPED_ARRAY_RETURNED = 500,
        JSMSG_SHORT_TYPED_ARRAY_RETURNED = 501,
        JSMSG_SHARED_ARRAY_BAD_LENGTH = 502,
        JSMSG_NON_SHARED_ARRAY_BUFFER_RETURNED = 503,
        JSMSG_SAME_SHARED_ARRAY_BUFFER_RETURNED = 504,
        JSMSG_SHORT_SHARED_ARRAY_BUFFER_RETURNED = 505,
        JSMSG_BAD_PARSE_NODE = 506,
        JSMSG_SYMBOL_TO_STRING = 507,
        JSMSG_SYMBOL_TO_NUMBER = 508,
        JSMSG_ATOMICS_BAD_ARRAY = 509,
        JSMSG_ATOMICS_TOO_LONG = 510,
        JSMSG_ATOMICS_WAIT_NOT_ALLOWED = 511,
        JSMSG_CANT_SET_INTERPOSED = 512,
        JSMSG_CANT_DEFINE_WINDOW_ELEMENT = 513,
        JSMSG_CANT_DELETE_WINDOW_ELEMENT = 514,
        JSMSG_CANT_DELETE_WINDOW_NAMED_PROPERTY = 515,
        JSMSG_CANT_PREVENT_EXTENSIONS = 516,
        JSMSG_CANT_DEFINE_WINDOW_NC = 517,
        JSMSG_NO_NAMED_SETTER = 518,
        JSMSG_NO_INDEXED_SETTER = 519,
        JSMSG_NOT_DATA_DESCRIPTOR = 520,
        JSMSG_CANT_DELETE_SUPER = 521,
        JSMSG_REINIT_THIS = 522,
        JSMSG_BAD_DEFAULT_EXPORT = 523,
        JSMSG_MISSING_INDIRECT_EXPORT = 524,
        JSMSG_AMBIGUOUS_INDIRECT_EXPORT = 525,
        JSMSG_MISSING_IMPORT = 526,
        JSMSG_AMBIGUOUS_IMPORT = 527,
        JSMSG_MISSING_NAMESPACE_EXPORT = 528,
        JSMSG_MISSING_EXPORT = 529,
        JSMSG_BAD_MODULE_STATUS = 530,
        JSMSG_DYNAMIC_IMPORT_FAILED = 531,
        JSMSG_BAD_MODULE_SPECIFIER = 532,
        JSMSG_CANNOT_RESOLVE_PROMISE_WITH_ITSELF = 533,
        JSMSG_PROMISE_CAPABILITY_HAS_SOMETHING_ALREADY = 534,
        JSMSG_PROMISE_RESOLVE_FUNCTION_NOT_CALLABLE = 535,
        JSMSG_PROMISE_REJECT_FUNCTION_NOT_CALLABLE = 536,
        JSMSG_PROMISE_ERROR_IN_WRAPPED_REJECTION_REASON = 537,
        JSMSG_PROMISE_ANY_REJECTION = 538,
        JSMSG_RETURN_NOT_CALLABLE = 539,
        JSMSG_ITERATOR_NO_THROW = 540,
        JSMSG_UNHANDLABLE_PROMISE_REJECTION_WARNING = 541,
        JSMSG_FOR_AWAIT_NOT_OF = 542,
        JSMSG_NOT_AN_ASYNC_GENERATOR = 543,
        JSMSG_NOT_AN_ASYNC_ITERATOR = 544,
        JSMSG_GET_ASYNC_ITER_RETURNED_PRIMITIVE = 545,
        JSMSG_READABLESTREAM_UNDERLYINGSOURCE_TYPE_WRONG = 546,
        JSMSG_READABLESTREAM_BYTES_TYPE_NOT_IMPLEMENTED = 547,
        JSMSG_READABLESTREAM_BYOB_READERS_NOT_IMPLEMENTED = 548,
        JSMSG_READABLESTREAM_INVALID_READER_MODE = 549,
        JSMSG_NUMBER_MUST_BE_FINITE_NON_NEGATIVE = 550,
        JSMSG_READABLEBYTESTREAMCONTROLLER_INVALID_BYTESWRITTEN = 551,
        JSMSG_READABLEBYTESTREAMCONTROLLER_INVALID_VIEW_SIZE = 552,
        JSMSG_READABLEBYTESTREAMCONTROLLER_INVALID_VIEW_OFFSET = 553,
        JSMSG_READABLESTREAM_LOCKED_METHOD = 554,
        JSMSG_READABLESTREAM_LOCKED = 555,
        JSMSG_READABLESTREAM_NOT_BYTE_STREAM_CONTROLLER = 556,
        JSMSG_READABLESTREAM_NOT_DEFAULT_CONTROLLER = 557,
        JSMSG_READABLESTREAM_CONTROLLER_SET = 558,
        JSMSG_READABLESTREAMREADER_NOT_OWNED = 559,
        JSMSG_READABLESTREAMREADER_NOT_EMPTY = 560,
        JSMSG_READABLESTREAMBYOBREADER_READ_EMPTY_VIEW = 561,
        JSMSG_READABLESTREAMREADER_RELEASED = 562,
        JSMSG_READABLESTREAMCONTROLLER_CLOSED = 563,
        JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE = 564,
        JSMSG_READABLEBYTESTREAMCONTROLLER_BAD_CHUNKSIZE = 565,
        JSMSG_READABLEBYTESTREAMCONTROLLER_BAD_CHUNK = 566,
        JSMSG_READABLEBYTESTREAMCONTROLLER_CLOSE_PENDING_PULL = 567,
        JSMSG_READABLESTREAMBYOBREQUEST_NO_CONTROLLER = 568,
        JSMSG_READABLESTREAMBYOBREQUEST_RESPOND_CLOSED = 569,
        JSMSG_READABLESTREAM_METHOD_NOT_IMPLEMENTED = 570,
        JSMSG_READABLESTREAM_UNDERLYINGSINK_TYPE_WRONG = 571,
        JSMSG_WRITABLESTREAMWRITER_NOT_OWNED = 572,
        JSMSG_WRITABLESTREAM_CLOSED_OR_ERRORED = 573,
        JSMSG_WRITABLESTREAM_RELEASED_DURING_WRITE = 574,
        JSMSG_WRITABLESTREAM_WRITE_CLOSING_OR_CLOSED = 575,
        JSMSG_CANT_USE_LOCKED_WRITABLESTREAM = 576,
        JSMSG_WRITABLESTREAM_CLOSE_CLOSING_OR_CLOSED = 577,
        JSMSG_WRITABLESTREAM_CANT_RELEASE_ALREADY_CLOSED = 578,
        JSMSG_WRITABLESTREAM_ALREADY_LOCKED = 579,
        JSMSG_READABLESTREAM_NYI = 580,
        JSMSG_STREAM_INVALID_HIGHWATERMARK = 581,
        JSMSG_STREAM_CONSUME_ERROR = 582,
        JSMSG_ERROR_CONSUMING_RESPONSE = 583,
        JSMSG_BAD_RESPONSE_VALUE = 584,
        JSMSG_BAD_RESPONSE_MIME_TYPE = 585,
        JSMSG_BAD_RESPONSE_CORS_SAME_ORIGIN = 586,
        JSMSG_BAD_RESPONSE_STATUS = 587,
        JSMSG_RESPONSE_ALREADY_CONSUMED = 588,
        JSMSG_BIGINT_TO_NUMBER = 589,
        JSMSG_NUMBER_TO_BIGINT = 590,
        JSMSG_BIGINT_TOO_LARGE = 591,
        JSMSG_BIGINT_DIVISION_BY_ZERO = 592,
        JSMSG_BIGINT_NEGATIVE_EXPONENT = 593,
        JSMSG_BIGINT_INVALID_SYNTAX = 594,
        JSMSG_NOT_BIGINT = 595,
        JSMSG_BIGINT_NOT_SERIALIZABLE = 596,
        JSMSG_SC_BIGINT_DISABLED = 597,
        JSMSG_BINAST = 598,
        JSMSG_NOT_A_FINALIZATION_GROUP = 599,
        JSMSG_NOT_A_FINALIZATION_ITERATOR = 600,
        JSMSG_BAD_HOLDINGS = 601,
        JSMSG_BAD_UNREGISTER_TOKEN = 602,
        JSMSG_STALE_FINALIZATION_GROUP_ITERATOR = 603,
        JSMSG_BAD_CLEANUP_STATE = 604,
        JSErr_Limit = 605,
    }
    extern "C" {
        #[link_name = "\u{1}_Z15JS_NewInt8ArrayP9JSContextj"]
        pub fn JS_NewInt8Array(cx: *mut root::JSContext, nelements: u32) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_NewUint8ArrayP9JSContextj"]
        pub fn JS_NewUint8Array(cx: *mut root::JSContext, nelements: u32) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_NewUint8ClampedArrayP9JSContextj"]
        pub fn JS_NewUint8ClampedArray(
            cx: *mut root::JSContext,
            nelements: u32,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_NewInt16ArrayP9JSContextj"]
        pub fn JS_NewInt16Array(cx: *mut root::JSContext, nelements: u32) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_NewUint16ArrayP9JSContextj"]
        pub fn JS_NewUint16Array(cx: *mut root::JSContext, nelements: u32) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_NewInt32ArrayP9JSContextj"]
        pub fn JS_NewInt32Array(cx: *mut root::JSContext, nelements: u32) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_NewUint32ArrayP9JSContextj"]
        pub fn JS_NewUint32Array(cx: *mut root::JSContext, nelements: u32) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_NewFloat32ArrayP9JSContextj"]
        pub fn JS_NewFloat32Array(cx: *mut root::JSContext, nelements: u32) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_NewFloat64ArrayP9JSContextj"]
        pub fn JS_NewFloat64Array(cx: *mut root::JSContext, nelements: u32) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_NewInt8ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewInt8ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::HandleObject,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_NewUint8ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewUint8ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::HandleObject,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z32JS_NewUint8ClampedArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewUint8ClampedArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::HandleObject,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_NewInt16ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewInt16ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::HandleObject,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_NewUint16ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewUint16ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::HandleObject,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_NewInt32ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewInt32ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::HandleObject,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_NewUint32ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewUint32ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::HandleObject,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_NewFloat32ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewFloat32ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::HandleObject,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_NewFloat64ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewFloat64ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::HandleObject,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_NewInt8ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEji"]
        pub fn JS_NewInt8ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::HandleObject,
            byteOffset: u32,
            length: i32,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_NewUint8ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEji"]
        pub fn JS_NewUint8ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::HandleObject,
            byteOffset: u32,
            length: i32,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z33JS_NewUint8ClampedArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEji"]
        pub fn JS_NewUint8ClampedArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::HandleObject,
            byteOffset: u32,
            length: i32,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_NewInt16ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEji"]
        pub fn JS_NewInt16ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::HandleObject,
            byteOffset: u32,
            length: i32,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_NewUint16ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEji"]
        pub fn JS_NewUint16ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::HandleObject,
            byteOffset: u32,
            length: i32,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_NewInt32ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEji"]
        pub fn JS_NewInt32ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::HandleObject,
            byteOffset: u32,
            length: i32,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_NewUint32ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEji"]
        pub fn JS_NewUint32ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::HandleObject,
            byteOffset: u32,
            length: i32,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z29JS_NewBigInt64ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEji"]
        pub fn JS_NewBigInt64ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::HandleObject,
            byteOffset: u32,
            length: i32,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z30JS_NewBigUint64ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEji"]
        pub fn JS_NewBigUint64ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::HandleObject,
            byteOffset: u32,
            length: i32,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z28JS_NewFloat32ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEji"]
        pub fn JS_NewFloat32ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::HandleObject,
            byteOffset: u32,
            length: i32,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z28JS_NewFloat64ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEji"]
        pub fn JS_NewFloat64ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::HandleObject,
            byteOffset: u32,
            length: i32,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " Check whether obj supports JS_GetTypedArray* APIs. Note that this may return"]
        #[doc = " false if a security wrapper is encountered that denies the unwrapping. If"]
        #[doc = " this test or one of the JS_Is*Array tests succeeds, then it is safe to call"]
        #[doc = " the various accessor JSAPI calls defined below."]
        #[link_name = "\u{1}_Z21JS_IsTypedArrayObjectP8JSObject"]
        pub fn JS_IsTypedArrayObject(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[doc = " Check whether obj supports JS_GetArrayBufferView* APIs. Note that this may"]
        #[doc = " return false if a security wrapper is encountered that denies the"]
        #[doc = " unwrapping. If this test or one of the more specific tests succeeds, then it"]
        #[doc = " is safe to call the various ArrayBufferView accessor JSAPI calls defined"]
        #[doc = " below."]
        #[link_name = "\u{1}_Z26JS_IsArrayBufferViewObjectP8JSObject"]
        pub fn JS_IsArrayBufferViewObject(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z14JS_IsInt8ArrayP8JSObject"]
        pub fn JS_IsInt8Array(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z15JS_IsUint8ArrayP8JSObject"]
        pub fn JS_IsUint8Array(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_IsUint8ClampedArrayP8JSObject"]
        pub fn JS_IsUint8ClampedArray(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z15JS_IsInt16ArrayP8JSObject"]
        pub fn JS_IsInt16Array(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_IsUint16ArrayP8JSObject"]
        pub fn JS_IsUint16Array(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z15JS_IsInt32ArrayP8JSObject"]
        pub fn JS_IsInt32Array(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_IsUint32ArrayP8JSObject"]
        pub fn JS_IsUint32Array(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_IsFloat32ArrayP8JSObject"]
        pub fn JS_IsFloat32Array(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_IsFloat64ArrayP8JSObject"]
        pub fn JS_IsFloat64Array(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[doc = " Return the isShared flag of a typed array, which denotes whether"]
        #[doc = " the underlying buffer is a SharedArrayBuffer."]
        #[doc = ""]
        #[doc = " |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow"]
        #[doc = " be known that it would pass such a test: it is a typed array or a wrapper of"]
        #[doc = " a typed array, and the unwrapping will succeed."]
        #[link_name = "\u{1}_Z26JS_GetTypedArraySharednessP8JSObject"]
        pub fn JS_GetTypedArraySharedness(obj: *mut root::JSObject) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z23JS_GetObjectAsInt8ArrayP8JSObjectPjPbPPa"]
        pub fn JS_GetObjectAsInt8Array(
            obj: *mut root::JSObject,
            length: *mut u32,
            isSharedMemory: *mut bool,
            data: *mut *mut i8,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_GetObjectAsUint8ArrayP8JSObjectPjPbPPh"]
        pub fn JS_GetObjectAsUint8Array(
            obj: *mut root::JSObject,
            length: *mut u32,
            isSharedMemory: *mut bool,
            data: *mut *mut u8,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z31JS_GetObjectAsUint8ClampedArrayP8JSObjectPjPbPPh"]
        pub fn JS_GetObjectAsUint8ClampedArray(
            obj: *mut root::JSObject,
            length: *mut u32,
            isSharedMemory: *mut bool,
            data: *mut *mut u8,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_GetObjectAsInt16ArrayP8JSObjectPjPbPPs"]
        pub fn JS_GetObjectAsInt16Array(
            obj: *mut root::JSObject,
            length: *mut u32,
            isSharedMemory: *mut bool,
            data: *mut *mut i16,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_GetObjectAsUint16ArrayP8JSObjectPjPbPPt"]
        pub fn JS_GetObjectAsUint16Array(
            obj: *mut root::JSObject,
            length: *mut u32,
            isSharedMemory: *mut bool,
            data: *mut *mut u16,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z24JS_GetObjectAsInt32ArrayP8JSObjectPjPbPPi"]
        pub fn JS_GetObjectAsInt32Array(
            obj: *mut root::JSObject,
            length: *mut u32,
            isSharedMemory: *mut bool,
            data: *mut *mut i32,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_GetObjectAsUint32ArrayP8JSObjectPjPbPS1_"]
        pub fn JS_GetObjectAsUint32Array(
            obj: *mut root::JSObject,
            length: *mut u32,
            isSharedMemory: *mut bool,
            data: *mut *mut u32,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_GetObjectAsFloat32ArrayP8JSObjectPjPbPPf"]
        pub fn JS_GetObjectAsFloat32Array(
            obj: *mut root::JSObject,
            length: *mut u32,
            isSharedMemory: *mut bool,
            data: *mut *mut f32,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_GetObjectAsFloat64ArrayP8JSObjectPjPbPPd"]
        pub fn JS_GetObjectAsFloat64Array(
            obj: *mut root::JSObject,
            length: *mut u32,
            isSharedMemory: *mut bool,
            data: *mut *mut f64,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z29JS_GetObjectAsArrayBufferViewP8JSObjectPjPbPPh"]
        pub fn JS_GetObjectAsArrayBufferView(
            obj: *mut root::JSObject,
            length: *mut u32,
            isSharedMemory: *mut bool,
            data: *mut *mut u8,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[link_name = "\u{1}_Z25JS_GetArrayBufferViewTypeP8JSObject"]
        pub fn JS_GetArrayBufferViewType(obj: *mut root::JSObject) -> root::js::Scalar::Type;
    }
    extern "C" {
        #[link_name = "\u{1}_Z31JS_GetSharedArrayBufferViewTypeP8JSObject"]
        pub fn JS_GetSharedArrayBufferViewType(obj: *mut root::JSObject) -> root::js::Scalar::Type;
    }
    extern "C" {
        #[doc = " Return the number of elements in a typed array."]
        #[doc = ""]
        #[doc = " |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow"]
        #[doc = " be known that it would pass such a test: it is a typed array or a wrapper of"]
        #[doc = " a typed array, and the unwrapping will succeed."]
        #[link_name = "\u{1}_Z22JS_GetTypedArrayLengthP8JSObject"]
        pub fn JS_GetTypedArrayLength(obj: *mut root::JSObject) -> u32;
    }
    extern "C" {
        #[doc = " Return the byte offset from the start of an ArrayBuffer to the start of a"]
        #[doc = " typed array view."]
        #[doc = ""]
        #[doc = " |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow"]
        #[doc = " be known that it would pass such a test: it is a typed array or a wrapper of"]
        #[doc = " a typed array, and the unwrapping will succeed."]
        #[link_name = "\u{1}_Z26JS_GetTypedArrayByteOffsetP8JSObject"]
        pub fn JS_GetTypedArrayByteOffset(obj: *mut root::JSObject) -> u32;
    }
    extern "C" {
        #[doc = " Return the byte length of a typed array."]
        #[doc = ""]
        #[doc = " |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow"]
        #[doc = " be known that it would pass such a test: it is a typed array or a wrapper of"]
        #[doc = " a typed array, and the unwrapping will succeed."]
        #[link_name = "\u{1}_Z26JS_GetTypedArrayByteLengthP8JSObject"]
        pub fn JS_GetTypedArrayByteLength(obj: *mut root::JSObject) -> u32;
    }
    extern "C" {
        #[doc = " More generic name for JS_GetTypedArrayByteLength to cover DataViews as well"]
        #[link_name = "\u{1}_Z31JS_GetArrayBufferViewByteLengthP8JSObject"]
        pub fn JS_GetArrayBufferViewByteLength(obj: *mut root::JSObject) -> u32;
    }
    extern "C" {
        #[doc = " More generic name for JS_GetTypedArrayByteOffset to cover DataViews as well"]
        #[link_name = "\u{1}_Z31JS_GetArrayBufferViewByteOffsetP8JSObject"]
        pub fn JS_GetArrayBufferViewByteOffset(obj: *mut root::JSObject) -> u32;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_GetInt8ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetInt8ArrayData(
            obj: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut i8;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_GetUint8ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetUint8ArrayData(
            obj: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut u8;
    }
    extern "C" {
        #[link_name = "\u{1}_Z27JS_GetUint8ClampedArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetUint8ClampedArrayData(
            obj: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut u8;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_GetInt16ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetInt16ArrayData(
            obj: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut i16;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_GetUint16ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetUint16ArrayData(
            obj: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut u16;
    }
    extern "C" {
        #[link_name = "\u{1}_Z20JS_GetInt32ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetInt32ArrayData(
            obj: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut i32;
    }
    extern "C" {
        #[link_name = "\u{1}_Z21JS_GetUint32ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetUint32ArrayData(
            obj: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut u32;
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_GetFloat32ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetFloat32ArrayData(
            obj: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut f32;
    }
    extern "C" {
        #[link_name = "\u{1}_Z22JS_GetFloat64ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetFloat64ArrayData(
            obj: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut f64;
    }
    extern "C" {
        #[doc = " Same as above, but for any kind of ArrayBufferView. Prefer the type-specific"]
        #[doc = " versions when possible."]
        #[link_name = "\u{1}_Z25JS_GetArrayBufferViewDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetArrayBufferViewData(
            obj: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut ::std::os::raw::c_void;
    }
    extern "C" {
        #[doc = " Return the ArrayBuffer or SharedArrayBuffer underlying an ArrayBufferView."]
        #[doc = " This may return a detached buffer.  |obj| must be an object that would"]
        #[doc = " return true for JS_IsArrayBufferViewObject()."]
        #[link_name = "\u{1}_Z27JS_GetArrayBufferViewBufferP9JSContextN2JS6HandleIP8JSObjectEEPb"]
        pub fn JS_GetArrayBufferViewBuffer(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            isSharedMemory: *mut bool,
        ) -> *mut root::JSObject;
    }
    extern "C" {
        #[doc = " Create a new DataView using the given buffer for storage. The given buffer"]
        #[doc = " must be an ArrayBuffer or SharedArrayBuffer (or a cross-compartment wrapper"]
        #[doc = " of either type), and the offset and length must fit within the bounds of the"]
        #[doc = " buffer. Currently, nullptr will be returned and an exception will be thrown"]
        #[doc = " if these conditions do not hold, but do not depend on that behavior."]
        #[link_name = "\u{1}_Z14JS_NewDataViewP9JSContextN2JS6HandleIP8JSObjectEEji"]
        pub fn JS_NewDataView(
            cx: *mut root::JSContext,
            buffer: root::JS::HandleObject,
            byteOffset: u32,
            byteLength: i32,
        ) -> *mut root::JSObject;
    }
    #[doc = " A class, expected to be passed by value, which represents the CallArgs for a"]
    #[doc = " JSJitGetterOp."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSJitGetterCallArgs {
        pub _base: root::JS::MutableHandleValue,
    }
    #[test]
    fn bindgen_test_layout_JSJitGetterCallArgs() {
        assert_eq!(
            ::std::mem::size_of::<JSJitGetterCallArgs>(),
            8usize,
            concat!("Size of: ", stringify!(JSJitGetterCallArgs))
        );
        assert_eq!(
            ::std::mem::align_of::<JSJitGetterCallArgs>(),
            8usize,
            concat!("Alignment of ", stringify!(JSJitGetterCallArgs))
        );
    }
    #[doc = " A class, expected to be passed by value, which represents the CallArgs for a"]
    #[doc = " JSJitSetterOp."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSJitSetterCallArgs {
        pub _base: root::JS::MutableHandleValue,
    }
    #[test]
    fn bindgen_test_layout_JSJitSetterCallArgs() {
        assert_eq!(
            ::std::mem::size_of::<JSJitSetterCallArgs>(),
            8usize,
            concat!("Size of: ", stringify!(JSJitSetterCallArgs))
        );
        assert_eq!(
            ::std::mem::align_of::<JSJitSetterCallArgs>(),
            8usize,
            concat!("Alignment of ", stringify!(JSJitSetterCallArgs))
        );
    }
    pub type JSJitMethodCallArgs_Base = [u64; 2usize];
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSJitMethodCallArgsTraits {
        pub _address: u8,
    }
    pub const JSJitMethodCallArgsTraits_offsetOfArgv: usize = 0;
    pub const JSJitMethodCallArgsTraits_offsetOfArgc: usize = 8;
    #[test]
    fn bindgen_test_layout_JSJitMethodCallArgsTraits() {
        assert_eq!(
            ::std::mem::size_of::<JSJitMethodCallArgsTraits>(),
            1usize,
            concat!("Size of: ", stringify!(JSJitMethodCallArgsTraits))
        );
        assert_eq!(
            ::std::mem::align_of::<JSJitMethodCallArgsTraits>(),
            1usize,
            concat!("Alignment of ", stringify!(JSJitMethodCallArgsTraits))
        );
    }
    pub type JSJitGetterOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            thisObj: root::JS::HandleObject,
            specializedThis: *mut ::std::os::raw::c_void,
            args: root::JSJitGetterCallArgs,
        ) -> bool,
    >;
    pub type JSJitSetterOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            thisObj: root::JS::HandleObject,
            specializedThis: *mut ::std::os::raw::c_void,
            args: root::JSJitSetterCallArgs,
        ) -> bool,
    >;
    pub type JSJitMethodOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            thisObj: root::JS::HandleObject,
            specializedThis: *mut ::std::os::raw::c_void,
            args: *const root::JSJitMethodCallArgs,
        ) -> bool,
    >;
    #[doc = " This struct contains metadata passed from the DOM to the JS Engine for JIT"]
    #[doc = " optimizations on DOM property accessors. Eventually, this should be made"]
    #[doc = " available to general JSAPI users, but we are not currently ready to do so."]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct JSJitInfo {
        pub __bindgen_anon_1: root::JSJitInfo__bindgen_ty_1,
        pub __bindgen_anon_2: root::JSJitInfo__bindgen_ty_2,
        pub __bindgen_anon_3: root::JSJitInfo__bindgen_ty_3,
        pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 4usize], u16>,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum JSJitInfo_OpType {
        Getter = 0,
        Setter = 1,
        Method = 2,
        StaticMethod = 3,
        InlinableNative = 4,
        IgnoresReturnValueNative = 5,
        OpTypeCount = 6,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum JSJitInfo_ArgType {
        String = 1,
        Integer = 2,
        Double = 4,
        Boolean = 8,
        Object = 16,
        Null = 32,
        Numeric = 6,
        Primitive = 47,
        ObjectOrNull = 48,
        Any = 63,
        ArgTypeListEnd = -2147483648,
    }
    #[repr(u32)]
    #[doc = " An enum that describes what this getter/setter/method aliases.  This"]
    #[doc = " determines what things can be hoisted past this call, and if this"]
    #[doc = " call is movable what it can be hoisted past."]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum JSJitInfo_AliasSet {
        #[doc = " Alias nothing: a constant value, getting it can't affect any other"]
        #[doc = " values, nothing can affect it."]
        AliasNone = 0,
        #[doc = " Alias things that can modify the DOM but nothing else.  Doing the"]
        #[doc = " call can't affect the behavior of any other function."]
        AliasDOMSets = 1,
        #[doc = " Alias the world.  Calling this can change arbitrary values anywhere"]
        #[doc = " in the system.  Most things fall in this bucket."]
        AliasEverything = 2,
        #[doc = " Must be last."]
        AliasSetCount = 3,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union JSJitInfo__bindgen_ty_1 {
        pub getter: root::JSJitGetterOp,
        pub setter: root::JSJitSetterOp,
        pub method: root::JSJitMethodOp,
        #[doc = " A DOM static method, used for Promise wrappers"]
        pub staticMethod: root::JSNative,
        pub ignoresReturnValueMethod: root::JSNative,
        _bindgen_union_align: u64,
    }
    #[test]
    fn bindgen_test_layout_JSJitInfo__bindgen_ty_1() {
        assert_eq!(
            ::std::mem::size_of::<JSJitInfo__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(JSJitInfo__bindgen_ty_1))
        );
        assert_eq!(
            ::std::mem::align_of::<JSJitInfo__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(JSJitInfo__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSJitInfo__bindgen_ty_1>())).getter as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSJitInfo__bindgen_ty_1),
                "::",
                stringify!(getter)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSJitInfo__bindgen_ty_1>())).setter as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSJitInfo__bindgen_ty_1),
                "::",
                stringify!(setter)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSJitInfo__bindgen_ty_1>())).method as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSJitInfo__bindgen_ty_1),
                "::",
                stringify!(method)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSJitInfo__bindgen_ty_1>())).staticMethod as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSJitInfo__bindgen_ty_1),
                "::",
                stringify!(staticMethod)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSJitInfo__bindgen_ty_1>())).ignoresReturnValueMethod
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSJitInfo__bindgen_ty_1),
                "::",
                stringify!(ignoresReturnValueMethod)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union JSJitInfo__bindgen_ty_2 {
        pub protoID: u16,
        pub inlinableNative: root::js::jit::InlinableNative,
        _bindgen_union_align: u16,
    }
    #[test]
    fn bindgen_test_layout_JSJitInfo__bindgen_ty_2() {
        assert_eq!(
            ::std::mem::size_of::<JSJitInfo__bindgen_ty_2>(),
            2usize,
            concat!("Size of: ", stringify!(JSJitInfo__bindgen_ty_2))
        );
        assert_eq!(
            ::std::mem::align_of::<JSJitInfo__bindgen_ty_2>(),
            2usize,
            concat!("Alignment of ", stringify!(JSJitInfo__bindgen_ty_2))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSJitInfo__bindgen_ty_2>())).protoID as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSJitInfo__bindgen_ty_2),
                "::",
                stringify!(protoID)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSJitInfo__bindgen_ty_2>())).inlinableNative as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSJitInfo__bindgen_ty_2),
                "::",
                stringify!(inlinableNative)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union JSJitInfo__bindgen_ty_3 {
        pub depth: u16,
        pub nativeOp: u16,
        _bindgen_union_align: u16,
    }
    #[test]
    fn bindgen_test_layout_JSJitInfo__bindgen_ty_3() {
        assert_eq!(
            ::std::mem::size_of::<JSJitInfo__bindgen_ty_3>(),
            2usize,
            concat!("Size of: ", stringify!(JSJitInfo__bindgen_ty_3))
        );
        assert_eq!(
            ::std::mem::align_of::<JSJitInfo__bindgen_ty_3>(),
            2usize,
            concat!("Alignment of ", stringify!(JSJitInfo__bindgen_ty_3))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSJitInfo__bindgen_ty_3>())).depth as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSJitInfo__bindgen_ty_3),
                "::",
                stringify!(depth)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSJitInfo__bindgen_ty_3>())).nativeOp as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSJitInfo__bindgen_ty_3),
                "::",
                stringify!(nativeOp)
            )
        );
    }
    pub const JSJitInfo_maxSlotIndex: usize = 1023;
    #[test]
    fn bindgen_test_layout_JSJitInfo() {
        assert_eq!(
            ::std::mem::size_of::<JSJitInfo>(),
            16usize,
            concat!("Size of: ", stringify!(JSJitInfo))
        );
        assert_eq!(
            ::std::mem::align_of::<JSJitInfo>(),
            8usize,
            concat!("Alignment of ", stringify!(JSJitInfo))
        );
    }
    impl JSJitInfo {
        #[inline]
        pub fn type_(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
        }
        #[inline]
        pub fn set_type_(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(0usize, 4u8, val as u64)
            }
        }
        #[inline]
        pub fn aliasSet_(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
        }
        #[inline]
        pub fn set_aliasSet_(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(4usize, 4u8, val as u64)
            }
        }
        #[inline]
        pub fn returnType_(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
        }
        #[inline]
        pub fn set_returnType_(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(8usize, 8u8, val as u64)
            }
        }
        #[inline]
        pub fn isInfallible(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_isInfallible(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(16usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn isMovable(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_isMovable(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(17usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn isEliminatable(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_isEliminatable(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(18usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn isAlwaysInSlot(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_isAlwaysInSlot(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(19usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn isLazilyCachedInSlot(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_isLazilyCachedInSlot(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(20usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn isTypedMethod(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_isTypedMethod(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(21usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn slotIndex(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
        }
        #[inline]
        pub fn set_slotIndex(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(22usize, 10u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            type_: u32,
            aliasSet_: u32,
            returnType_: u32,
            isInfallible: u32,
            isMovable: u32,
            isEliminatable: u32,
            isAlwaysInSlot: u32,
            isLazilyCachedInSlot: u32,
            isTypedMethod: u32,
            slotIndex: u32,
        ) -> root::__BindgenBitfieldUnit<[u8; 4usize], u16> {
            let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 4usize], u16> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 4u8, {
                let type_: u32 = unsafe { ::std::mem::transmute(type_) };
                type_ as u64
            });
            __bindgen_bitfield_unit.set(4usize, 4u8, {
                let aliasSet_: u32 = unsafe { ::std::mem::transmute(aliasSet_) };
                aliasSet_ as u64
            });
            __bindgen_bitfield_unit.set(8usize, 8u8, {
                let returnType_: u32 = unsafe { ::std::mem::transmute(returnType_) };
                returnType_ as u64
            });
            __bindgen_bitfield_unit.set(16usize, 1u8, {
                let isInfallible: u32 = unsafe { ::std::mem::transmute(isInfallible) };
                isInfallible as u64
            });
            __bindgen_bitfield_unit.set(17usize, 1u8, {
                let isMovable: u32 = unsafe { ::std::mem::transmute(isMovable) };
                isMovable as u64
            });
            __bindgen_bitfield_unit.set(18usize, 1u8, {
                let isEliminatable: u32 = unsafe { ::std::mem::transmute(isEliminatable) };
                isEliminatable as u64
            });
            __bindgen_bitfield_unit.set(19usize, 1u8, {
                let isAlwaysInSlot: u32 = unsafe { ::std::mem::transmute(isAlwaysInSlot) };
                isAlwaysInSlot as u64
            });
            __bindgen_bitfield_unit.set(20usize, 1u8, {
                let isLazilyCachedInSlot: u32 =
                    unsafe { ::std::mem::transmute(isLazilyCachedInSlot) };
                isLazilyCachedInSlot as u64
            });
            __bindgen_bitfield_unit.set(21usize, 1u8, {
                let isTypedMethod: u32 = unsafe { ::std::mem::transmute(isTypedMethod) };
                isTypedMethod as u64
            });
            __bindgen_bitfield_unit.set(22usize, 10u8, {
                let slotIndex: u32 = unsafe { ::std::mem::transmute(slotIndex) };
                slotIndex as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct JSTypedMethodJitInfo {
        pub base: root::JSJitInfo,
        pub argTypes: *const root::JSJitInfo_ArgType,
    }
    #[test]
    fn bindgen_test_layout_JSTypedMethodJitInfo() {
        assert_eq!(
            ::std::mem::size_of::<JSTypedMethodJitInfo>(),
            24usize,
            concat!("Size of: ", stringify!(JSTypedMethodJitInfo))
        );
        assert_eq!(
            ::std::mem::align_of::<JSTypedMethodJitInfo>(),
            8usize,
            concat!("Alignment of ", stringify!(JSTypedMethodJitInfo))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSTypedMethodJitInfo>())).base as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSTypedMethodJitInfo),
                "::",
                stringify!(base)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSTypedMethodJitInfo>())).argTypes as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(JSTypedMethodJitInfo),
                "::",
                stringify!(argTypes)
            )
        );
    }
    extern "C" {
        #[doc = " Given a buffer, return false if the buffer might become a valid JavaScript"]
        #[doc = " script with the addition of more lines, or true if the validity of such a"]
        #[doc = " script is conclusively known (because it's the prefix of a valid script --"]
        #[doc = " and possibly the entirety of such a script)."]
        #[doc = ""]
        #[doc = " The intent of this function is to enable interactive compilation: accumulate"]
        #[doc = " lines in a buffer until JS_Utf8BufferIsCompilableUnit is true, then pass it"]
        #[doc = " to the compiler."]
        #[doc = ""]
        #[doc = " The provided buffer is interpreted as UTF-8 data.  An error is reported if"]
        #[doc = " a UTF-8 encoding error is encountered."]
        #[link_name = "\u{1}_Z29JS_Utf8BufferIsCompilableUnitP9JSContextN2JS6HandleIP8JSObjectEEPKcm"]
        pub fn JS_Utf8BufferIsCompilableUnit(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            utf8: *const ::std::os::raw::c_char,
            length: usize,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Evaluate a script in the scope of the current global of cx."]
        #[link_name = "\u{1}_Z16JS_ExecuteScriptP9JSContextN2JS6HandleIP8JSScriptEENS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_ExecuteScript(
            cx: *mut root::JSContext,
            script: root::JS::Handle<*mut root::JSScript>,
            rval: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_ExecuteScriptP9JSContextN2JS6HandleIP8JSScriptEE"]
        pub fn JS_ExecuteScript1(
            cx: *mut root::JSContext,
            script: root::JS::Handle<*mut root::JSScript>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " As above, but providing an explicit scope chain.  envChain must not include"]
        #[doc = " the global object on it; that's implicit.  It needs to contain the other"]
        #[doc = " objects that should end up on the script's scope chain."]
        #[link_name = "\u{1}_Z16JS_ExecuteScriptP9JSContextN2JS6HandleINS1_13StackGCVectorIP8JSObjectN2js15TempAllocPolicyEEEEENS2_IP8JSScriptEENS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_ExecuteScript2(
            cx: *mut root::JSContext,
            envChain: root::JS::HandleObjectVector,
            script: root::JS::Handle<*mut root::JSScript>,
            rval: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z16JS_ExecuteScriptP9JSContextN2JS6HandleINS1_13StackGCVectorIP8JSObjectN2js15TempAllocPolicyEEEEENS2_IP8JSScriptEE"]
        pub fn JS_ExecuteScript3(
            cx: *mut root::JSContext,
            envChain: root::JS::HandleObjectVector,
            script: root::JS::Handle<*mut root::JSScript>,
        ) -> bool;
    }
    pub type JS_ICUAllocFn = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_void,
            size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >;
    pub type JS_ICUReallocFn = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_void,
            p: *mut ::std::os::raw::c_void,
            size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >;
    pub type JS_ICUFreeFn = ::std::option::Option<
        unsafe extern "C" fn(arg1: *const ::std::os::raw::c_void, p: *mut ::std::os::raw::c_void),
    >;
    extern "C" {
        #[doc = " This function can be used to track memory used by ICU.  If it is called, it"]
        #[doc = " *must* be called before JS_Init.  Don't use it unless you know what you're"]
        #[doc = " doing!"]
        #[link_name = "\u{1}_Z24JS_SetICUMemoryFunctionsPFPvPKvmEPFS_S1_S_mEPFvS1_S_E"]
        pub fn JS_SetICUMemoryFunctions(
            allocFn: root::JS_ICUAllocFn,
            reallocFn: root::JS_ICUReallocFn,
            freeFn: root::JS_ICUFreeFn,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Destroy free-standing resources allocated by SpiderMonkey, not associated"]
        #[doc = " with any runtime, context, or other structure."]
        #[doc = ""]
        #[doc = " This method should be called after all other JSAPI data has been properly"]
        #[doc = " cleaned up: every new runtime must have been destroyed, every new context"]
        #[doc = " must have been destroyed, and so on.  Calling this method before all other"]
        #[doc = " resources have been destroyed has undefined behavior."]
        #[doc = ""]
        #[doc = " Failure to call this method, at present, has no adverse effects other than"]
        #[doc = " leaking memory.  This may not always be the case; it's recommended that all"]
        #[doc = " embedders call this method when all other JSAPI operations have completed."]
        #[doc = ""]
        #[doc = " It is currently not possible to initialize SpiderMonkey multiple times (that"]
        #[doc = " is, calling JS_Init/JSAPI methods/JS_ShutDown in that order, then doing so"]
        #[doc = " again).  This restriction may eventually be lifted."]
        #[link_name = "\u{1}_Z11JS_ShutDownv"]
        pub fn JS_ShutDown();
    }
    pub type JSONWriteCallback = ::std::option::Option<
        unsafe extern "C" fn(buf: *const u16, len: u32, data: *mut ::std::os::raw::c_void) -> bool,
    >;
    extern "C" {
        #[doc = " Performs the JSON.stringify operation, as specified by ECMAScript, except"]
        #[doc = " writing stringified data by repeated calls of |callback|, with each such"]
        #[doc = " call passed |data| as argument."]
        #[link_name = "\u{1}_Z12JS_StringifyP9JSContextN2JS13MutableHandleINS1_5ValueEEENS1_6HandleIP8JSObjectEENS5_IS3_EEPFbPKDsjPvESC_"]
        pub fn JS_Stringify(
            cx: *mut root::JSContext,
            value: root::JS::MutableHandle<root::JS::Value>,
            replacer: root::JS::Handle<*mut root::JSObject>,
            space: root::JS::Handle<root::JS::Value>,
            callback: root::JSONWriteCallback,
            data: *mut ::std::os::raw::c_void,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Performs the JSON.parse operation as specified by ECMAScript."]
        #[link_name = "\u{1}_Z12JS_ParseJSONP9JSContextPKDsjN2JS13MutableHandleINS3_5ValueEEE"]
        pub fn JS_ParseJSON(
            cx: *mut root::JSContext,
            chars: *const u16,
            len: u32,
            vp: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Performs the JSON.parse operation as specified by ECMAScript."]
        #[link_name = "\u{1}_Z12JS_ParseJSONP9JSContextN2JS6HandleIP8JSStringEENS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_ParseJSON1(
            cx: *mut root::JSContext,
            str: root::JS::Handle<*mut root::JSString>,
            vp: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Performs the JSON.parse operation as specified by ECMAScript, using the"]
        #[doc = " given |reviver| argument as the corresponding optional argument to that"]
        #[doc = " function."]
        #[link_name = "\u{1}_Z23JS_ParseJSONWithReviverP9JSContextPKDsjN2JS6HandleINS3_5ValueEEENS3_13MutableHandleIS5_EE"]
        pub fn JS_ParseJSONWithReviver(
            cx: *mut root::JSContext,
            chars: *const u16,
            len: u32,
            reviver: root::JS::Handle<root::JS::Value>,
            vp: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Performs the JSON.parse operation as specified by ECMAScript, using the"]
        #[doc = " given |reviver| argument as the corresponding optional argument to that"]
        #[doc = " function."]
        #[link_name = "\u{1}_Z23JS_ParseJSONWithReviverP9JSContextN2JS6HandleIP8JSStringEENS2_INS1_5ValueEEENS1_13MutableHandleIS6_EE"]
        pub fn JS_ParseJSONWithReviver1(
            cx: *mut root::JSContext,
            str: root::JS::Handle<*mut root::JSString>,
            reviver: root::JS::Handle<root::JS::Value>,
            vp: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
    }
    #[doc = " Read structured data from the reader r. This hook is used to read a value"]
    #[doc = " previously serialized by a call to the WriteStructuredCloneOp hook."]
    #[doc = ""]
    #[doc = " tag and data are the pair of uint32_t values from the header. The callback"]
    #[doc = " may use the JS_Read* APIs to read any other relevant parts of the object"]
    #[doc = " from the reader r. closure is any value passed to the JS_ReadStructuredClone"]
    #[doc = " function. Return the new object on success, nullptr on error/exception."]
    pub type ReadStructuredCloneOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            r: *mut root::JSStructuredCloneReader,
            tag: u32,
            data: u32,
            closure: *mut ::std::os::raw::c_void,
        ) -> *mut root::JSObject,
    >;
    #[doc = " Structured data serialization hook. The engine can write primitive values,"]
    #[doc = " Objects, Arrays, Dates, RegExps, TypedArrays, ArrayBuffers, Sets, Maps,"]
    #[doc = " and SharedTypedArrays. Any other type of object requires application support."]
    #[doc = " This callback must first use the JS_WriteUint32Pair API to write an object"]
    #[doc = " header, passing a value greater than JS_SCTAG_USER to the tag parameter."]
    #[doc = " Then it can use the JS_Write* APIs to write any other relevant parts of"]
    #[doc = " the value v to the writer w. closure is any value passed to the"]
    #[doc = " JS_WriteStructuredClone function."]
    #[doc = ""]
    #[doc = " Return true on success, false on error/exception."]
    pub type WriteStructuredCloneOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            w: *mut root::JSStructuredCloneWriter,
            obj: root::JS::HandleObject,
            closure: *mut ::std::os::raw::c_void,
        ) -> bool,
    >;
    #[doc = " This is called when JS_WriteStructuredClone is given an invalid transferable."]
    #[doc = " To follow HTML5, the application must throw a DATA_CLONE_ERR DOMException"]
    #[doc = " with error set to one of the JS_SCERR_* values."]
    pub type StructuredCloneErrorOp =
        ::std::option::Option<unsafe extern "C" fn(cx: *mut root::JSContext, errorid: u32)>;
    #[doc = " This is called when JS_ReadStructuredClone receives a transferable object"]
    #[doc = " not known to the engine. If this hook does not exist or returns false, the"]
    #[doc = " JS engine calls the reportError op if set, otherwise it throws a"]
    #[doc = " DATA_CLONE_ERR DOM Exception. This method is called before any other"]
    #[doc = " callback and must return a non-null object in returnObject on success."]
    pub type ReadTransferStructuredCloneOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            r: *mut root::JSStructuredCloneReader,
            tag: u32,
            content: *mut ::std::os::raw::c_void,
            extraData: u64,
            closure: *mut ::std::os::raw::c_void,
            returnObject: root::JS::MutableHandleObject,
        ) -> bool,
    >;
    #[doc = " Called when JS_WriteStructuredClone receives a transferable object not"]
    #[doc = " handled by the engine. If this hook does not exist or returns false, the JS"]
    #[doc = " engine will call the reportError hook or fall back to throwing a"]
    #[doc = " DATA_CLONE_ERR DOM Exception. This method is called before any other"]
    #[doc = " callback."]
    #[doc = ""]
    #[doc = "  tag: indicates what type of transferable this is. Must be greater than"]
    #[doc = "       0xFFFF0201 (value of the internal SCTAG_TRANSFER_MAP_PENDING_ENTRY)"]
    #[doc = ""]
    #[doc = "  ownership: see TransferableOwnership, above. Used to communicate any needed"]
    #[doc = "       ownership info to the FreeTransferStructuredCloneOp."]
    #[doc = ""]
    #[doc = "  content, extraData: what the ReadTransferStructuredCloneOp will receive"]
    pub type TransferStructuredCloneOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            closure: *mut ::std::os::raw::c_void,
            tag: *mut u32,
            ownership: *mut root::JS::TransferableOwnership,
            content: *mut *mut ::std::os::raw::c_void,
            extraData: *mut u64,
        ) -> bool,
    >;
    #[doc = " Called when freeing an unknown transferable object. Note that it"]
    #[doc = " should never trigger a garbage collection (and will assert in a"]
    #[doc = " debug build if it does.)"]
    pub type FreeTransferStructuredCloneOp = ::std::option::Option<
        unsafe extern "C" fn(
            tag: u32,
            ownership: root::JS::TransferableOwnership,
            content: *mut ::std::os::raw::c_void,
            extraData: u64,
            closure: *mut ::std::os::raw::c_void,
        ),
    >;
    #[doc = " Called when the transferring objects are checked. If this function returns"]
    #[doc = " false, the serialization ends throwing a DataCloneError exception."]
    pub type CanTransferStructuredCloneOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            closure: *mut ::std::os::raw::c_void,
        ) -> bool,
    >;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSStructuredCloneCallbacks {
        pub read: root::ReadStructuredCloneOp,
        pub write: root::WriteStructuredCloneOp,
        pub reportError: root::StructuredCloneErrorOp,
        pub readTransfer: root::ReadTransferStructuredCloneOp,
        pub writeTransfer: root::TransferStructuredCloneOp,
        pub freeTransfer: root::FreeTransferStructuredCloneOp,
        pub canTransfer: root::CanTransferStructuredCloneOp,
    }
    #[test]
    fn bindgen_test_layout_JSStructuredCloneCallbacks() {
        assert_eq!(
            ::std::mem::size_of::<JSStructuredCloneCallbacks>(),
            56usize,
            concat!("Size of: ", stringify!(JSStructuredCloneCallbacks))
        );
        assert_eq!(
            ::std::mem::align_of::<JSStructuredCloneCallbacks>(),
            8usize,
            concat!("Alignment of ", stringify!(JSStructuredCloneCallbacks))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSStructuredCloneCallbacks>())).read as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSStructuredCloneCallbacks),
                "::",
                stringify!(read)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSStructuredCloneCallbacks>())).write as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSStructuredCloneCallbacks),
                "::",
                stringify!(write)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSStructuredCloneCallbacks>())).reportError as *const _
                    as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(JSStructuredCloneCallbacks),
                "::",
                stringify!(reportError)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSStructuredCloneCallbacks>())).readTransfer as *const _
                    as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(JSStructuredCloneCallbacks),
                "::",
                stringify!(readTransfer)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSStructuredCloneCallbacks>())).writeTransfer as *const _
                    as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(JSStructuredCloneCallbacks),
                "::",
                stringify!(writeTransfer)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSStructuredCloneCallbacks>())).freeTransfer as *const _
                    as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(JSStructuredCloneCallbacks),
                "::",
                stringify!(freeTransfer)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSStructuredCloneCallbacks>())).canTransfer as *const _
                    as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(JSStructuredCloneCallbacks),
                "::",
                stringify!(canTransfer)
            )
        );
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
    pub enum OwnTransferablePolicy {
        #[doc = " The buffer owns any Transferables that it might contain, and should"]
        #[doc = " properly release them upon destruction."]
        OwnsTransferablesIfAny = 0,
        #[doc = " Do not free any Transferables within this buffer when deleting it. This"]
        #[doc = " is used to mark as clone buffer as containing data from another process,"]
        #[doc = " and so it can't legitimately contain pointers. If the buffer claims to"]
        #[doc = " have transferables, it's a bug or an attack. This is also used for"]
        #[doc = " abandon(), where a buffer still contains raw data but the ownership has"]
        #[doc = " been given over to some other entity."]
        IgnoreTransferablesIfAny = 1,
        #[doc = " A buffer that cannot contain Transferables at all. This usually means"]
        #[doc = " the buffer is empty (not yet filled in, or having been cleared)."]
        NoTransferables = 2,
    }
    #[doc = " JSStructuredCloneData represents structured clone data together with the"]
    #[doc = " information needed to read/write/transfer/free the records within it, in the"]
    #[doc = " form of a set of callbacks."]
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSStructuredCloneData {
        pub bufList_: root::JSStructuredCloneData_BufferList,
        pub scope_: root::JS::StructuredCloneScope,
        pub callbacks_: *const root::JSStructuredCloneCallbacks,
        pub closure_: *mut ::std::os::raw::c_void,
        pub ownTransferables_: root::OwnTransferablePolicy,
        pub refsHeld_: root::js::SharedArrayRawBufferRefs,
    }
    pub type JSStructuredCloneData_BufferList = [u64; 9usize];
    pub type JSStructuredCloneData_Iterator = root::IterImpl;
    pub const JSStructuredCloneData_kStandardCapacity: usize = 4096;
    #[test]
    fn bindgen_test_layout_JSStructuredCloneData() {
        assert_eq!(
            ::std::mem::size_of::<JSStructuredCloneData>(),
            128usize,
            concat!("Size of: ", stringify!(JSStructuredCloneData))
        );
        assert_eq!(
            ::std::mem::align_of::<JSStructuredCloneData>(),
            8usize,
            concat!("Alignment of ", stringify!(JSStructuredCloneData))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSStructuredCloneData>())).bufList_ as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSStructuredCloneData),
                "::",
                stringify!(bufList_)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSStructuredCloneData>())).scope_ as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(JSStructuredCloneData),
                "::",
                stringify!(scope_)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSStructuredCloneData>())).callbacks_ as *const _ as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(JSStructuredCloneData),
                "::",
                stringify!(callbacks_)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSStructuredCloneData>())).closure_ as *const _ as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(JSStructuredCloneData),
                "::",
                stringify!(closure_)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSStructuredCloneData>())).ownTransferables_ as *const _
                    as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(JSStructuredCloneData),
                "::",
                stringify!(ownTransferables_)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSStructuredCloneData>())).refsHeld_ as *const _ as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(JSStructuredCloneData),
                "::",
                stringify!(refsHeld_)
            )
        );
    }
    extern "C" {
        #[doc = " Implements StructuredDeserialize and StructuredDeserializeWithTransfer."]
        #[doc = ""]
        #[doc = " Note: If `data` contains transferable objects, it can be read only once."]
        #[link_name = "\u{1}_Z22JS_ReadStructuredCloneP9JSContextR21JSStructuredCloneDatajN2JS20StructuredCloneScopeENS3_13MutableHandleINS3_5ValueEEENS3_15CloneDataPolicyEPK26JSStructuredCloneCallbacksPv"]
        pub fn JS_ReadStructuredClone(
            cx: *mut root::JSContext,
            data: *mut root::JSStructuredCloneData,
            version: u32,
            scope: root::JS::StructuredCloneScope,
            vp: root::JS::MutableHandleValue,
            cloneDataPolicy: root::JS::CloneDataPolicy,
            optionalCallbacks: *const root::JSStructuredCloneCallbacks,
            closure: *mut ::std::os::raw::c_void,
        ) -> bool;
    }
    extern "C" {
        #[doc = " Implements StructuredSerialize, StructuredSerializeForStorage, and"]
        #[doc = " StructuredSerializeWithTransfer."]
        #[doc = ""]
        #[doc = " Note: If the scope is DifferentProcess then the cloneDataPolicy must deny"]
        #[doc = " shared-memory objects, or an error will be signaled if a shared memory object"]
        #[doc = " is seen."]
        #[link_name = "\u{1}_Z23JS_WriteStructuredCloneP9JSContextN2JS6HandleINS1_5ValueEEEP21JSStructuredCloneDataNS1_20StructuredCloneScopeENS1_15CloneDataPolicyEPK26JSStructuredCloneCallbacksPvS4_"]
        pub fn JS_WriteStructuredClone(
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
            data: *mut root::JSStructuredCloneData,
            scope: root::JS::StructuredCloneScope,
            cloneDataPolicy: root::JS::CloneDataPolicy,
            optionalCallbacks: *const root::JSStructuredCloneCallbacks,
            closure: *mut ::std::os::raw::c_void,
            transferable: root::JS::HandleValue,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z34JS_StructuredCloneHasTransferablesR21JSStructuredCloneDataPb"]
        pub fn JS_StructuredCloneHasTransferables(
            data: *mut root::JSStructuredCloneData,
            hasTransferable: *mut bool,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_StructuredCloneP9JSContextN2JS6HandleINS1_5ValueEEENS1_13MutableHandleIS3_EEPK26JSStructuredCloneCallbacksPv"]
        pub fn JS_StructuredClone(
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
            vp: root::JS::MutableHandleValue,
            optionalCallbacks: *const root::JSStructuredCloneCallbacks,
            closure: *mut ::std::os::raw::c_void,
        ) -> bool;
    }
    #[doc = " The C-style API calls to read and write structured clones are fragile --"]
    #[doc = " they rely on the caller to properly handle ownership of the clone data, and"]
    #[doc = " the handling of the input data as well as the interpretation of the contents"]
    #[doc = " of the clone buffer are dependent on the callbacks passed in. If you"]
    #[doc = " serialize and deserialize with different callbacks, the results are"]
    #[doc = " questionable."]
    #[doc = ""]
    #[doc = " JSAutoStructuredCloneBuffer wraps things up in an RAII class for data"]
    #[doc = " management, and uses the same callbacks for both writing and reading"]
    #[doc = " (serializing and deserializing)."]
    #[repr(C)]
    #[derive(Debug)]
    pub struct JSAutoStructuredCloneBuffer {
        pub scope_: root::JS::StructuredCloneScope,
        pub data_: root::JSStructuredCloneData,
        pub version_: u32,
    }
    #[test]
    fn bindgen_test_layout_JSAutoStructuredCloneBuffer() {
        assert_eq!(
            ::std::mem::size_of::<JSAutoStructuredCloneBuffer>(),
            144usize,
            concat!("Size of: ", stringify!(JSAutoStructuredCloneBuffer))
        );
        assert_eq!(
            ::std::mem::align_of::<JSAutoStructuredCloneBuffer>(),
            8usize,
            concat!("Alignment of ", stringify!(JSAutoStructuredCloneBuffer))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSAutoStructuredCloneBuffer>())).scope_ as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSAutoStructuredCloneBuffer),
                "::",
                stringify!(scope_)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSAutoStructuredCloneBuffer>())).data_ as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSAutoStructuredCloneBuffer),
                "::",
                stringify!(data_)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<JSAutoStructuredCloneBuffer>())).version_ as *const _
                    as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(JSAutoStructuredCloneBuffer),
                "::",
                stringify!(version_)
            )
        );
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_ReadUint32PairP23JSStructuredCloneReaderPjS1_"]
        pub fn JS_ReadUint32Pair(
            r: *mut root::JSStructuredCloneReader,
            p1: *mut u32,
            p2: *mut u32,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z12JS_ReadBytesP23JSStructuredCloneReaderPvm"]
        pub fn JS_ReadBytes(
            r: *mut root::JSStructuredCloneReader,
            p: *mut ::std::os::raw::c_void,
            len: usize,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z17JS_ReadTypedArrayP23JSStructuredCloneReaderN2JS13MutableHandleINS1_5ValueEEE"]
        pub fn JS_ReadTypedArray(
            r: *mut root::JSStructuredCloneReader,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_WriteUint32PairP23JSStructuredCloneWriterjj"]
        pub fn JS_WriteUint32Pair(
            w: *mut root::JSStructuredCloneWriter,
            tag: u32,
            data: u32,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z13JS_WriteBytesP23JSStructuredCloneWriterPKvm"]
        pub fn JS_WriteBytes(
            w: *mut root::JSStructuredCloneWriter,
            p: *const ::std::os::raw::c_void,
            len: usize,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z14JS_WriteStringP23JSStructuredCloneWriterN2JS6HandleIP8JSStringEE"]
        pub fn JS_WriteString(
            w: *mut root::JSStructuredCloneWriter,
            str: root::JS::HandleString,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z18JS_WriteTypedArrayP23JSStructuredCloneWriterN2JS6HandleINS1_5ValueEEE"]
        pub fn JS_WriteTypedArray(
            w: *mut root::JSStructuredCloneWriter,
            v: root::JS::HandleValue,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z19JS_ObjectNotWrittenP23JSStructuredCloneWriterN2JS6HandleIP8JSObjectEE"]
        pub fn JS_ObjectNotWritten(
            w: *mut root::JSStructuredCloneWriter,
            obj: root::JS::HandleObject,
        ) -> bool;
    }
    extern "C" {
        #[link_name = "\u{1}_Z26JS_GetStructuredCloneScopeP23JSStructuredCloneWriter"]
        pub fn JS_GetStructuredCloneScope(
            w: *mut root::JSStructuredCloneWriter,
        ) -> root::JS::StructuredCloneScope;
    }
    pub mod glue {
        #[allow(unused_imports)]
        use self::super::super::root;
        extern "C" {
            #[link_name = "\u{1}_ZN4glue7JS_InitEv"]
            pub fn JS_Init() -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue18JS_NewRealmOptionsEv"]
            pub fn JS_NewRealmOptions() -> *mut root::JS::RealmOptions;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue18DeleteRealmOptionsEPN2JS12RealmOptionsE"]
            pub fn DeleteRealmOptions(options: *mut root::JS::RealmOptions);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue26JS_NewOwningCompileOptionsEP9JSContext"]
            pub fn JS_NewOwningCompileOptions(
                cx: *mut root::JSContext,
            ) -> root::JS::OwningCompileOptions;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue25JS_StackCapture_AllFramesEv"]
            pub fn JS_StackCapture_AllFrames() -> root::JS::StackCapture;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue25JS_StackCapture_MaxFramesEj"]
            pub fn JS_StackCapture_MaxFrames(max: u32) -> root::JS::StackCapture;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue34JS_StackCapture_FirstSubsumedFrameEP9JSContextb"]
            pub fn JS_StackCapture_FirstSubsumedFrame(
                cx: *mut root::JSContext,
                ignoreSelfHostedFrames: bool,
            ) -> root::JS::StackCapture;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue20JS_ForOfIteratorInitEPN2JS13ForOfIteratorENS0_6HandleINS0_5ValueEEENS1_19NonIterableBehaviorE"]
            pub fn JS_ForOfIteratorInit(
                iterator: *mut root::JS::ForOfIterator,
                iterable: root::JS::HandleValue,
                nonIterableBehavior: root::JS::ForOfIterator_NonIterableBehavior,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue20JS_ForOfIteratorNextEPN2JS13ForOfIteratorENS0_13MutableHandleINS0_5ValueEEEPb"]
            pub fn JS_ForOfIteratorNext(
                iterator: *mut root::JS::ForOfIterator,
                val: root::JS::MutableHandleValue,
                done: *mut bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue15JS_AsShadowZoneEPN2JS4ZoneE"]
            pub fn JS_AsShadowZone(zone: *mut root::JS::Zone) -> *mut root::JS::shadow::Zone;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue17JS_CallArgsFromVpEjPN2JS5ValueE"]
            pub fn JS_CallArgsFromVp(
                argc: ::std::os::raw::c_uint,
                vp: *mut root::JS::Value,
            ) -> root::JS::CallArgs;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue18JS_ValueSetBooleanEPN2JS5ValueEb"]
            pub fn JS_ValueSetBoolean(value: *mut root::JS::Value, x: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue17JS_ValueIsBooleanEPKN2JS5ValueE"]
            pub fn JS_ValueIsBoolean(value: *const root::JS::Value) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue17JS_ValueToBooleanEPKN2JS5ValueE"]
            pub fn JS_ValueToBoolean(value: *const root::JS::Value) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue17JS_ValueSetDoubleEPN2JS5ValueEd"]
            pub fn JS_ValueSetDouble(value: *mut root::JS::Value, x: f64);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue16JS_ValueIsDoubleEPKN2JS5ValueE"]
            pub fn JS_ValueIsDouble(value: *const root::JS::Value) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue16JS_ValueToDoubleEPKN2JS5ValueE"]
            pub fn JS_ValueToDouble(value: *const root::JS::Value) -> f64;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue16JS_ValueSetInt32EPN2JS5ValueEi"]
            pub fn JS_ValueSetInt32(value: *mut root::JS::Value, x: i32);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue15JS_ValueIsInt32EPKN2JS5ValueE"]
            pub fn JS_ValueIsInt32(value: *const root::JS::Value) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue15JS_ValueToInt32EPKN2JS5ValueE"]
            pub fn JS_ValueToInt32(value: *const root::JS::Value) -> i32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue16JS_ValueIsNumberEPKN2JS5ValueE"]
            pub fn JS_ValueIsNumber(value: *const root::JS::Value) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue16JS_ValueToNumberEPKN2JS5ValueE"]
            pub fn JS_ValueToNumber(value: *const root::JS::Value) -> f64;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue15JS_ValueSetNullEPN2JS5ValueE"]
            pub fn JS_ValueSetNull(value: *mut root::JS::Value);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue14JS_ValueIsNullEPKN2JS5ValueE"]
            pub fn JS_ValueIsNull(value: *const root::JS::Value) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4glue19JS_ValueIsUndefinedEPKN2JS5ValueE"]
            pub fn JS_ValueIsUndefined(value: *const root::JS::Value) -> bool;
        }
    }
    #[doc = " <div rustbindgen replaces=\"JSJitMethodCallArgs\"></div>"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSJitMethodCallArgs {
        pub argv_: *mut root::JS::Value,
        pub argc_: ::std::os::raw::c_uint,
        pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 1usize], u8>,
        pub __bindgen_padding_0: [u8; 3usize],
    }
    #[test]
    fn bindgen_test_layout_JSJitMethodCallArgs() {
        assert_eq!(
            ::std::mem::size_of::<JSJitMethodCallArgs>(),
            16usize,
            concat!("Size of: ", stringify!(JSJitMethodCallArgs))
        );
        assert_eq!(
            ::std::mem::align_of::<JSJitMethodCallArgs>(),
            8usize,
            concat!("Alignment of ", stringify!(JSJitMethodCallArgs))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSJitMethodCallArgs>())).argv_ as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(JSJitMethodCallArgs),
                "::",
                stringify!(argv_)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<JSJitMethodCallArgs>())).argc_ as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(JSJitMethodCallArgs),
                "::",
                stringify!(argc_)
            )
        );
    }
    impl JSJitMethodCallArgs {
        #[inline]
        pub fn constructing_(&self) -> bool {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_constructing_(&mut self, val: bool) {
            unsafe {
                let val: u8 = ::std::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn ignoresReturnValue_(&self) -> bool {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_ignoresReturnValue_(&mut self, val: bool) {
            unsafe {
                let val: u8 = ::std::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            constructing_: bool,
            ignoresReturnValue_: bool,
        ) -> root::__BindgenBitfieldUnit<[u8; 1usize], u8> {
            let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 1usize], u8> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let constructing_: u8 = unsafe { ::std::mem::transmute(constructing_) };
                constructing_ as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let ignoresReturnValue_: u8 = unsafe { ::std::mem::transmute(ignoresReturnValue_) };
                ignoresReturnValue_ as u64
            });
            __bindgen_bitfield_unit
        }
    }
    pub type __builtin_va_list = [root::__va_list_tag; 1usize];
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __va_list_tag {
        pub gp_offset: ::std::os::raw::c_uint,
        pub fp_offset: ::std::os::raw::c_uint,
        pub overflow_arg_area: *mut ::std::os::raw::c_void,
        pub reg_save_area: *mut ::std::os::raw::c_void,
    }
    #[test]
    fn bindgen_test_layout___va_list_tag() {
        assert_eq!(
            ::std::mem::size_of::<__va_list_tag>(),
            24usize,
            concat!("Size of: ", stringify!(__va_list_tag))
        );
        assert_eq!(
            ::std::mem::align_of::<__va_list_tag>(),
            8usize,
            concat!("Alignment of ", stringify!(__va_list_tag))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(gp_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(fp_offset)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(overflow_arg_area)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(reg_save_area)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_27 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_28 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_29 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_30 {
        pub _address: u8,
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSFunction_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSFunction>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSFunction>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSFunction>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSFunction>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_PropertyKey_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::PropertyKey>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::PropertyKey>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::PropertyKey>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::PropertyKey>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSString_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSString>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSString>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSString>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSString>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_ptr_JSFunction_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSFunction>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSFunction>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSFunction>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSFunction>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_PropertyKey_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::PropertyKey>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::PropertyKey>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::PropertyKey>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::PropertyKey>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_ptr_JSObject_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_StackGCVector_open1_PropertyKey_TempAllocPolicy_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<u64>(),
            8usize,
            concat!("Size of template specialization: ", stringify!(u64))
        );
        assert_eq!(
            ::std::mem::align_of::<u64>(),
            8usize,
            concat!("Alignment of template specialization: ", stringify!(u64))
        );
    }
    #[test]
    fn __bindgen_test_layout_Opaque_open0_uint64_t_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Opaque<u64>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Opaque<u64>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Opaque<u64>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Opaque<u64>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_TenuredHeap_open0_ptr_JSObject_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::TenuredHeap>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::TenuredHeap)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::TenuredHeap>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::TenuredHeap)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_BaseTimeDuration_open0_TimeDurationValueCalculator_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::BaseTimeDuration>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::BaseTimeDuration)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::BaseTimeDuration>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::BaseTimeDuration)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Range_open0_Latin1Char_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Range<root::JS::Latin1Char>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Range<root::JS::Latin1Char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Range<root::JS::Latin1Char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Range<root::JS::Latin1Char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Range_open0_Latin1Char_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Range<root::JS::Latin1Char>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Range<root::JS::Latin1Char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Range<root::JS::Latin1Char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Range<root::JS::Latin1Char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_RangedPtr_open0_Latin1Char_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::RangedPtr<root::JS::Latin1Char>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::RangedPtr<root::JS::Latin1Char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::RangedPtr<root::JS::Latin1Char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::RangedPtr<root::JS::Latin1Char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_RangedPtr_open0_Latin1Char_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::RangedPtr<root::JS::Latin1Char>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::RangedPtr<root::JS::Latin1Char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::RangedPtr<root::JS::Latin1Char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::RangedPtr<root::JS::Latin1Char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Range_open0_unsigned_char_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Range<::std::os::raw::c_uchar>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Range<::std::os::raw::c_uchar>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Range<::std::os::raw::c_uchar>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Range<::std::os::raw::c_uchar>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Range_open0_unsigned_char_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Range<::std::os::raw::c_uchar>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Range<::std::os::raw::c_uchar>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Range<::std::os::raw::c_uchar>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Range<::std::os::raw::c_uchar>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Range_open0_unsigned_char_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Range<::std::os::raw::c_uchar>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Range<::std::os::raw::c_uchar>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Range<::std::os::raw::c_uchar>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Range<::std::os::raw::c_uchar>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Range_open0_unsigned_char_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Range<::std::os::raw::c_uchar>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Range<::std::os::raw::c_uchar>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Range<::std::os::raw::c_uchar>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Range<::std::os::raw::c_uchar>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_RangedPtr_open0_unsigned_char_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::RangedPtr<::std::os::raw::c_uchar>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::RangedPtr<::std::os::raw::c_uchar>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::RangedPtr<::std::os::raw::c_uchar>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::RangedPtr<::std::os::raw::c_uchar>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_RangedPtr_open0_unsigned_char_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::RangedPtr<::std::os::raw::c_uchar>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::RangedPtr<::std::os::raw::c_uchar>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::RangedPtr<::std::os::raw::c_uchar>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::RangedPtr<::std::os::raw::c_uchar>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Range_open0_char16_t_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Range<u16>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Range<u16>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Range<u16>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Range<u16>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Range_open0_char16_t_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Range<u16>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Range<u16>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Range<u16>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Range<u16>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_RangedPtr_open0_char16_t_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::RangedPtr<u16>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::RangedPtr<u16>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::RangedPtr<u16>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::RangedPtr<u16>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_RangedPtr_open0_char16_t_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::RangedPtr<u16>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::RangedPtr<u16>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::RangedPtr<u16>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::RangedPtr<u16>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_RangedPtr_open0_const_char16_t_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::RangedPtr<u16>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::RangedPtr<u16>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::RangedPtr<u16>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::RangedPtr<u16>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Range_open0_const_char16_t_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Range<u16>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Range<u16>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Range<u16>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Range<u16>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Range_open0_const_char16_t_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Range<u16>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Range<u16>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Range<u16>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Range<u16>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Range_open0_const_char16_t_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Range<u16>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Range<u16>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Range<u16>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Range<u16>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSString_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSString>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSString>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSString>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSString>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_open0_JSErrorNotes_Note_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_open0_JSErrorNotes_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_open0_JSErrorNotes_Note_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_open0_JSErrorNotes_Note_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_open0_JSErrorNotes_Note_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_open0_JSErrorNotes_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Range_open0_uint8_t_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Range<u8>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Range<u8>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Range<u8>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Range<u8>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_ptr_JSFunction_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSFunction>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSFunction>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSFunction>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSFunction>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Range_open0_uint8_t_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Range<u8>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Range<u8>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Range<u8>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Range<u8>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSString_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSString>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSString>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSString>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSString>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSString_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSString>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSString>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSString>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSString>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_ptr_JSObject_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_ptr_JSObject_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_5() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_6() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_7() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_8() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_9() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_10() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_11() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_12() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_13() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_14() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_15() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_16() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_17() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_18() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_jsid_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::jsid>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::jsid>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSFunction_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSFunction>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSFunction>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSFunction>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSFunction>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Range_open0_char16_t_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Range<u16>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Range<u16>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Range<u16>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Range<u16>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_AtomicRefCounted_open0_WasmModule_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::js::AtomicRefCounted>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::js::AtomicRefCounted)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::js::AtomicRefCounted>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::js::AtomicRefCounted)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Range_open0_Latin1Char_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Range<root::JS::Latin1Char>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Range<root::JS::Latin1Char>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Range<root::JS::Latin1Char>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Range<root::JS::Latin1Char>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Range_open0_const_char16_t_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::mozilla::Range<u16>>(),
            16usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::mozilla::Range<u16>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::mozilla::Range<u16>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::mozilla::Range<u16>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_19() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_20() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_21() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_22() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_23() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_24() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_25() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_5() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_6() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_7() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_8() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_9() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_10() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_11() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_12() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_13() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_26() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSString_close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSString>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSString>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSString>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSString>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_27() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_5() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_6() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_7() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_8() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_9() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_10() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_11() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_14() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_15() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_16() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_28() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_12() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_29() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_17() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSString_close0_instantiation_5() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSString>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSString>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSString>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSString>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_18() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_13() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_19() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSString_close0_instantiation_6() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSString>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSString>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSString>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSString>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_14() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_20() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_15() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSString_close0_instantiation_7() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSString>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSString>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSString>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSString>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_16() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_30() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_17() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSString_close0_instantiation_8() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSString>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSString>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSString>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSString>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_31() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_18() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSString_close0_instantiation_9() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSString>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSString>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSString>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSString>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_32() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_33() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_34() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_35() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_19() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_Value_close0_instantiation_20() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_36() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_open0_JobQueue_SavedJobQueue_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_DeletePolicy_open0_JobQueue_SavedJobQueue_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::DeletePolicy>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::DeletePolicy)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_37() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSString_close0_instantiation_10() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSString>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSString>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSString>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSString>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_38() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_39() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_40() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_21() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_41() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_Value_close0_instantiation_22() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<root::JS::Value>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<root::JS::Value>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_42() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_43() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_44() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_45() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_46() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_47() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_48() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_49() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_50() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_51() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_ptr_JSObject_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_52() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_MutableHandle_open0_ptr_JSObject_close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::MutableHandle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::MutableHandle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::MutableHandle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_53() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_54() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_Handle_open0_ptr_JSObject_close0_instantiation_55() {
        assert_eq!(
            ::std::mem::size_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::JS::Handle<*mut root::JSObject>>(),
            8usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::JS::Handle<*mut root::JSObject>)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct IterImpl {
        pub mSegment: usize,
        pub mData: *mut ::std::os::raw::c_char,
        pub mDataEnd: *mut ::std::os::raw::c_char,
    }
    #[test]
    fn bindgen_test_layout_IterImpl() {
        assert_eq!(
            ::std::mem::size_of::<IterImpl>(),
            24usize,
            concat!("Size of: ", stringify!(IterImpl))
        );
        assert_eq!(
            ::std::mem::align_of::<IterImpl>(),
            8usize,
            concat!("Alignment of ", stringify!(IterImpl))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<IterImpl>())).mSegment as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(IterImpl),
                "::",
                stringify!(mSegment)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<IterImpl>())).mData as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(IterImpl),
                "::",
                stringify!(mData)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<IterImpl>())).mDataEnd as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(IterImpl),
                "::",
                stringify!(mDataEnd)
            )
        );
    }
}
